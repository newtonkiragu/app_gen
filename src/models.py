
# coding: utf-8
# AUTOGENERATED BY appgen 
# Copyright (C) Nyimbi Odero, 2024 


 
import datetime, enum
from flask_appbuilder import Model
from sqlalchemy import Column, Integer, Boolean, String, Float, Enum, ForeignKey, Date, DateTime, Text
from sqlalchemy.orm import relationship, backref


import os
import sys
import enum
import inspect
import datetime
import shutils
from datetime import timedelta, datetime, date

from sqlalchemy.orm import relationship, query, defer, deferred, column_property, mapper
from sqlalchemy.schema import FetchedValue
from sqlalchemy.ext.hybrid import hybrid_property, hybrid_method
from sqlalchemy import (Column, Integer, String, ForeignKey,
    Sequence, Float, Text, BigInteger, Date, SmallInteger, BigInteger, 
    DateTime, Time, Boolean, Index, CheckConstraint, Interval, # MatchType  
    UniqueConstraint, ForeignKeyConstraint, Numeric, LargeBinary , Table, func, Enum,
    text)

# IMPORT Postgresql Specific Types
from sqlalchemy.dialects.postgresql import *
from sqlalchemy.dialects.postgresql import (
    ARRAY, BIGINT, BIT, BOOLEAN, BYTEA, CHAR, CIDR, DATE,
    DOUBLE_PRECISION, ENUM, FLOAT, HSTORE, INET, INTEGER,
    INTERVAL, JSON, JSONB, MACADDR, NUMERIC, OID, REAL, SMALLINT, TEXT,
    TIME, TIMESTAMP, UUID, VARCHAR, INT4RANGE, INT8RANGE, NUMRANGE,
    DATERANGE, TSRANGE, TSTZRANGE, TSVECTOR, aggregate_order_by )

from flask_appbuilder import Model
from flask_appbuilder.models.mixins import AuditMixin, FileColumn, ImageColumn, UserExtensionMixin
from flask_appbuilder.security.sqla.models import User
from flask_appbuilder.filemanager import ImageManager

from flask_appbuilder.models.decorators import renders
from sqlalchemy_utils import aggregated, force_auto_coercion, observes
from sqlalchemy_utils.types import TSVectorType   #Searchability look at DocMixin
from sqlalchemy.ext.associationproxy import association_proxy

from flask_appbuilder.security.sqla.models import User
from geoalchemy2 import Geometry
from flask_mail import Mail, Message  # Requires Flask-Mail
# To create GraphSQL API
# import graphene
# from graphene_sqlalchemy import SQLAlchemyObjectType

# Versioning Mixin
# from sqlalchemy_continuum import make_versioned
#Add __versioned__ = {}


# from sqlalchemy_searchable import make_searchable
# from flask_graphql import GraphQLView

# ActiveRecord Model Features
# from sqlalchemy_mixins import AllFeaturesMixin, ActiveRecordMixin


# from .model_mixins import *

# Here is how to extend the User model
#class UserExtended(Model, UserExtensionMixin):
#    contact_group_id = Column(Integer, ForeignKey('contact_group.id'), nullable=True)
#    contact_group = relationship('ContactGroup')

# UTILITY CLASSES
# import arrow,


# Initialize sqlalchemy_utils
#force_auto_coercion()
# Keep versions of all data
# make_versioned()
# make_searchable()



# Domains defined in the database

 
# Enums defined in the database

class t_agent_role(enum.Enum):
   AGENT = 'agent'
   SUB_AGENT = 'sub_agent'
   SUPER_AGENT = 'super_agent'
   AGGREGATOR = 'aggregator'

class t_card_trans_type(enum.Enum):
   PURCHASE = 'purchase'
   BALANCE = 'balance'
   REFUND = 'refund'
   CASH_ADVANCE = 'cash_advance'
   CASH_BACK = 'cash_back'
   PRE_AUTHORIZATION = 'pre_authorization'
   PRE_AUTHORIZATION_COMPLETION = 'pre_authorization_completion'
   CARD_VERIFICATION = 'card_verification'
   TRANSACTION = 'transaction'
   SETTLEMENT = 'settlement'
   SETTLEMENT_BATCH_UPLOAD = 'settlement_batch_upload'
   WITHDRAWAL = 'withdrawal'
   DEPOSIT = 'deposit'
   TRANSFER = 'transfer'
   BILL_PAYMENT = 'bill_payment'
   CASH_DEPOSIT = 'cash_deposit'
   CARD_ACTIVATION = 'card_activation'

class t_date_macro(enum.Enum):
   ALL = 'All'
   TODAY = 'Today'
   THISWEEK = 'ThisWeek'
   THISWEEKTODATE = 'ThisWeekToDate'
   THISMONTH = 'ThisMonth'
   THISMONTHTODATE = 'ThisMonthToDate'
   THISCALENDARQUARTER = 'ThisCalendarQuarter'
   THISCALENDARQUARTERTODATE = 'ThisCalendarQuarterToDate'
   THISFISCALQUARTER = 'ThisFiscalQuarter'
   THISFISCALQUARTERTODATE = 'ThisFiscalQuarterToDate'
   THISCALENDARYEAR = 'ThisCalendarYear'
   THISCALENDARYEARTODATE = 'ThisCalendarYearToDate'
   THISFISCALYEAR = 'ThisFiscalYear'
   THISFISCALYEARTODATE = 'ThisFiscalYearToDate'
   YESTERDAY = 'Yesterday'
   LASTWEEK = 'LastWeek'
   LASTWEEKTODATE = 'LastWeekToDate'
   LASTMONTH = 'LastMonth'
   LASTMONTHTODATE = 'LastMonthToDate'
   LASTCALENDARQUARTER = 'LastCalendarQuarter'
   LASTCALENDARQUARTERTODATE = 'LastCalendarQuarterToDate'
   LASTFISCALQUARTER = 'LastFiscalQuarter'
   LASTFISCALQUARTERTODATE = 'LastFiscalQuarterToDate'
   LASTCALENDARYEAR = 'LastCalendarYear'
   LASTCALENDARYEARTODATE = 'LastCalendarYearToDate'
   LASTFISCALYEAR = 'LastFiscalYear'
   LASTFISCALYEARTODATE = 'LastFiscalYearToDate'
   NEXTWEEK = 'NextWeek'
   NEXTFOURWEEKS = 'NextFourWeeks'
   NEXTMONTH = 'NextMonth'
   NEXTCALENDARQUARTER = 'NextCalendarQuarter'
   NEXTCALENDARYEAR = 'NextCalendarYear'
   NEXTFISCALQUARTER = 'NextFiscalQuarter'
   NEXTFISCALYEAR = 'NextFiscalYear'

class t_doc_category(enum.Enum):
   IDENTIFICATION = 'Identification'
   CERTIFICATION = 'Certification'
   FINANCIAL = 'Financial'
   EDUCATIONAL = 'Educational'
   LEGAL_DOCUMENT = 'Legal_Document'
   UTILITY_BILL = 'Utility_Bill'
   MEDICAL_REPORT = 'Medical_Report'
   CONTRACT = 'Contract'
   INSURANCE_POLICY = 'Insurance_Policy'
   TAX_DOCUMENT = 'Tax_Document'

class t_doc_status(enum.Enum):
   NOT_STARTED = 'Not_Started'
   DRAFT = 'Draft'
   IN_PROGRESS = 'In_Progress'
   AWAITING_REVIEW = 'Awaiting_Review'
   UNDER_REVIEW = 'Under_Review'
   REVIEW_COMPLETED = 'Review_Completed'
   REVISIONS_NEEDED = 'Revisions_Needed'
   SUBMITTED = 'Submitted'
   APPROVED = 'Approved'
   PARTIALLY_APPROVED = 'Partially_Approved'
   REJECTED = 'Rejected'
   CANCELLED = 'Cancelled'
   ARCHIVED = 'Archived'
   PUBLISHED = 'Published'
   SUSPENDED = 'Suspended'
   VOIDED = 'Voided'
   COMPLETED = 'Completed'
   EXPIRED = 'Expired'
   RENEWED = 'Renewed'
   LOCKED = 'Locked'
   MERGED = 'Merged'
   ROLLBACK = 'Rollback'
   CONFLICT = 'Conflict'
   QUEUED_FOR_REVIEW = 'Queued_for_Review'
   QUEUED_FOR_PUBLISH = 'Queued_for_Publish'
   DEPRECATED = 'Deprecated'
   UNPUBLISHED = 'Unpublished'
   IN_TRANSLATION = 'In_Translation'
   VALIDATION_FAILED = 'Validation_Failed'
   VALIDATION_PASSED = 'Validation_Passed'
   DIGITIZED = 'Digitized'
   IN_SIGNATURE_PROCESS = 'In_Signature_Process'
   SIGNATURE_COMPLETED = 'Signature_Completed'
   SIGNATURE_FAILED = 'Signature_Failed'
   IN_AUDIT = 'In_Audit'
   AUDIT_COMPLETED = 'Audit_Completed'
   IN_TRANSIT = 'In_Transit'
   RECEIVED = 'Received'
   SENT = 'Sent'

class t_gender(enum.Enum):
   MALE = 'Male'
   FEMALE = 'Female'
   NON_BINARY = 'Non_Binary'
   PREFER_NOT_TO_SAY = 'Prefer_Not_to_Say'
   OTHER = 'Other'

class t_interval(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'

class t_org_type(enum.Enum):
   INDIVIDUAL = 'Individual'
   BUSINESS_NAME = 'Business_Name'
   SOLE_PROPRIETORSHIP = 'Sole_Proprietorship'
   PRIVATE_LIMITED_COMPANY = 'Private_Limited_Company'
   PUBLIC_LIMITED_COMPANY = 'Public_Limited_Company'
   PUBLIC_COMPANY_LIMITED_BY_GUARANTEE = 'Public_Company_Limited_by_Guarantee'
   PRIVATE_UNLIMITED_COMPANY = 'Private_Unlimited_Company'
   PUBLIC_UNLIMITED_COMPANY = 'Public_Unlimited_Company'

class t_payment_method(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'

class t_person_role(enum.Enum):
   NEXT_OF_KIN = 'next_of_kin'
   COMPANY_DIRECTOR = 'company_director'
   POS_OPERATOR = 'pos_operator'
   FIELD_SUPPORT = 'field_support'
   CUSTOMER = 'customer'
   REFEREE = 'referee'
   SUPERVISOR = 'supervisor'
   AGENT = 'agent'

class t_severity_level(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'

class t_transaction_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'

class t_verification_status(enum.Enum):
   PENDING = 'pending'
   KYC_SUBMITTED = 'kyc_submitted'
   KYC_APPROVED = 'kyc_approved'
   KYC_REJECTED = 'kyc_rejected'
   ESCALATED = 'escalated'
   CONTRACTED = 'contracted'
   ACTIVE = 'active'
   SUSPENDED = 'suspended'
   INACTIVE = 'inactive'
   CONTRACT_TERMINATED = 'contract_terminated'
   DOCS_EXPIRED = 'docs_expired'
   UNDER_REVIEW = 'under_review'
   LOCKED = 'locked'
   AWAITING_RENEWAL = 'awaiting_renewal'
   RENEWAL_REJECTED = 'renewal_rejected'
   VERIFICATION_FAILED = 'verification_failed'



class Doc_category(enum.Enum):
   IDENTIFICATION = 'Identification'
   CERTIFICATION = 'Certification'
   FINANCIAL = 'Financial'
   EDUCATIONAL = 'Educational'
   LEGAL_DOCUMENT = 'Legal_Document'
   UTILITY_BILL = 'Utility_Bill'
   MEDICAL_REPORT = 'Medical_Report'
   CONTRACT = 'Contract'
   INSURANCE_POLICY = 'Insurance_Policy'
   TAX_DOCUMENT = 'Tax_Document'



class Verification_status(enum.Enum):
   PENDING = 'pending'
   KYC_SUBMITTED = 'kyc_submitted'
   KYC_APPROVED = 'kyc_approved'
   KYC_REJECTED = 'kyc_rejected'
   ESCALATED = 'escalated'
   CONTRACTED = 'contracted'
   ACTIVE = 'active'
   SUSPENDED = 'suspended'
   INACTIVE = 'inactive'
   CONTRACT_TERMINATED = 'contract_terminated'
   DOCS_EXPIRED = 'docs_expired'
   UNDER_REVIEW = 'under_review'
   LOCKED = 'locked'
   AWAITING_RENEWAL = 'awaiting_renewal'
   RENEWAL_REJECTED = 'renewal_rejected'
   VERIFICATION_FAILED = 'verification_failed'



class Agent_type(enum.Enum):
   INDIVIDUAL = 'Individual'
   BUSINESS_NAME = 'Business_Name'
   SOLE_PROPRIETORSHIP = 'Sole_Proprietorship'
   PRIVATE_LIMITED_COMPANY = 'Private_Limited_Company'
   PUBLIC_LIMITED_COMPANY = 'Public_Limited_Company'
   PUBLIC_COMPANY_LIMITED_BY_GUARANTEE = 'Public_Company_Limited_by_Guarantee'
   PRIVATE_UNLIMITED_COMPANY = 'Private_Unlimited_Company'
   PUBLIC_UNLIMITED_COMPANY = 'Public_Unlimited_Company'



class Agent_role(enum.Enum):
   AGENT = 'agent'
   SUB_AGENT = 'sub_agent'
   SUPER_AGENT = 'super_agent'
   AGGREGATOR = 'aggregator'



class Kyc_verification_status(enum.Enum):
   PENDING = 'pending'
   KYC_SUBMITTED = 'kyc_submitted'
   KYC_APPROVED = 'kyc_approved'
   KYC_REJECTED = 'kyc_rejected'
   ESCALATED = 'escalated'
   CONTRACTED = 'contracted'
   ACTIVE = 'active'
   SUSPENDED = 'suspended'
   INACTIVE = 'inactive'
   CONTRACT_TERMINATED = 'contract_terminated'
   DOCS_EXPIRED = 'docs_expired'
   UNDER_REVIEW = 'under_review'
   LOCKED = 'locked'
   AWAITING_RENEWAL = 'awaiting_renewal'
   RENEWAL_REJECTED = 'renewal_rejected'
   VERIFICATION_FAILED = 'verification_failed'






class Person_role(enum.Enum):
   NEXT_OF_KIN = 'next_of_kin'
   COMPANY_DIRECTOR = 'company_director'
   POS_OPERATOR = 'pos_operator'
   FIELD_SUPPORT = 'field_support'
   CUSTOMER = 'customer'
   REFEREE = 'referee'
   SUPERVISOR = 'supervisor'
   AGENT = 'agent'



class Gender(enum.Enum):
   MALE = 'Male'
   FEMALE = 'Female'
   NON_BINARY = 'Non_Binary'
   PREFER_NOT_TO_SAY = 'Prefer_Not_to_Say'
   OTHER = 'Other'



class Transaction_type(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'



class Card_trans_type(enum.Enum):
   PURCHASE = 'purchase'
   BALANCE = 'balance'
   REFUND = 'refund'
   CASH_ADVANCE = 'cash_advance'
   CASH_BACK = 'cash_back'
   PRE_AUTHORIZATION = 'pre_authorization'
   PRE_AUTHORIZATION_COMPLETION = 'pre_authorization_completion'
   CARD_VERIFICATION = 'card_verification'
   TRANSACTION = 'transaction'
   SETTLEMENT = 'settlement'
   SETTLEMENT_BATCH_UPLOAD = 'settlement_batch_upload'
   WITHDRAWAL = 'withdrawal'
   DEPOSIT = 'deposit'
   TRANSFER = 'transfer'
   BILL_PAYMENT = 'bill_payment'
   CASH_DEPOSIT = 'cash_deposit'
   CARD_ACTIVATION = 'card_activation'



class Trans_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Origin_source(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'



class Trans_dest(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'









class AgentTier(Model):
    __tablename__ = "agent_tier"
    # __table_args__ = ( ) # tuple
    __doc__ = "Agent Tier"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Identity column - Unique identifier for the agent tier.")
    name = Column(String, nullable=True
		, comment="Name of the agent tier - Descriptive name or title of the agent tier.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or remarks about the agent tier, if necessary.")

    def __repr__(self):
       return self.name

 ### 


class Bank(Model):
    __tablename__ = "bank"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the bank.")
    code = Column(String
		, comment="NIBSS institutionCode, a unique code identifying the bank.")
    name = Column(String
		, comment="Name of the Bank.")
    category = Column(Integer, nullable=True
		, comment="Bank Category, representing the category of the bank.")
    swift_code = Column(String, nullable=True
		, comment="SWIFT Code, a unique international bank identifier.")
    sort_code = Column(String, nullable=True
		, comment="SORT Code, a unique bank sorting code.")
    iban = Column(String, nullable=True
		, comment="IBAN Code, a unique international bank account number.")
    cust_care_phone = Column(String, nullable=True
		, comment="Contact phone number for customer care.")
    cust_care_email = Column(String, nullable=True
		, comment="Contact email for customer care.")
    escalation_contact = Column(Text, nullable=True
		, comment="Contact information for escalation purposes.")

    def __repr__(self):
       return self.name

 ### 


class BillerCategory(Model):
    __tablename__ = "biller_category"
    # __table_args__ = ( ) # tuple
    __doc__ = "Category of Biller"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the biller category.")
    name = Column(String, nullable=True
		, comment="Name or title of the biller category.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or remarks about the biller category.")

    def __repr__(self):
       return self.name

 ### 


class ContactType(Model):
    __tablename__ = "contact_type"
    # __table_args__ = ( ) # tuple
    __doc__ = " phone, mobile, email, messaging, whatsapp, viber, instagram, website, etc"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the address type.")
    name = Column(String
		, comment="Name or type of contact method, e.g., Mobile, Email, WhatsApp.")
    description = Column(Text, nullable=True
		, comment="Brief description about the address type, providing context or usage scenarios.")
    is_digital = Column(Boolean, default=True, nullable=True
		, comment="Indicates if the contact method is digital or physical.")
    requires_verification = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the address type typically requires a verification process, e.g., email confirmation.")
    max_length = Column(Integer, nullable=True
		, comment="If applicable, the maximum character length of a value of this address type. Useful for validation.")
    icon_url = Column(String, nullable=True
		, comment="URL or link to an icon or image representing this address type. Useful for UI/UX purposes.")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the address type was added to the system.")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the address type was last updated.")

    def __repr__(self):
       return self.name

 ### 


class Country(Model):
    __tablename__ = "country"
    # __table_args__ = ( ) # tuple
    __doc__ = "List of Countries"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=True
		, comment=" Country Name")
    code = Column(String, nullable=True
		, comment="Country Code")
    phone_code = Column(Integer, nullable=True
		, comment="Dialling prefix of the country e.g +234 for Nigeria")

    def __repr__(self):
       return self.name

 ### 


class Coupon(Model):
    __tablename__ = "coupon"
    # __table_args__ = ( ) # tuple
    __doc__ = "A coupon can be shared electronically and redeemed at any agent."
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the coupon.")
    value = Column(Numeric, nullable=True
		, comment="The monetary value of the coupon.")
    serial_no = Column(String, nullable=True
		, comment="Serial number or code associated with the coupon.")
    active = Column(Boolean, nullable=True
		, comment="Indicates whether the coupon is active.")
    used = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the coupon has been used.")
    used_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Date and time when the coupon was used.")
    primary_scan_code_label = Column(String, nullable=True
		, comment="Primary scan code label associated with the coupon.")
    is_return_coupon = Column(Boolean, nullable=True
		, comment="Indicates whether the coupon is a return coupon.")
    expiration_date = Column(Date, nullable=True
		, comment="Date when the coupon expires.")
    generation_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Date and time when the coupon was generated.")
    activation_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Date and time when the coupon was activated.")
    secondary_scan_code_label = Column(String, nullable=True
		, comment="Secondary scan code label associated with the coupon.")
    scan_code_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    coupon_code = Column(String, nullable=True
		, comment="Code associated with the coupon.")
    return_coupon_reason = Column(String, nullable=True
		, comment="Reason for returning the coupon.")
    is_valid = Column(Boolean, default=True, nullable=True
		, comment="Indicates whether the coupon is valid.")
    coupon_status = Column(String, nullable=True
		, comment="Status of the coupon.")
    discount_percentage = Column(Integer, nullable=True
		, comment="Percentage discount offered by the coupon.")
    coupon_count = Column(Integer, nullable=True
		, comment="Number of coupons available.")
    payment_method_status = Column(String
		, comment="Status of the payment method associated with the coupon.")

    def __repr__(self):
       return self.id

 ### 


class Currency(Model):
    __tablename__ = "currency"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the currency.")
    name = Column(String, nullable=True
		, comment="Short name or code of the currency.")
    symbol = Column(String, nullable=True
		, comment="Symbol representing the currency.")
    numeric_code = Column(String, nullable=True
		, comment="Numeric code for the currency.")
    full_name = Column(String, nullable=True
		, comment="Full name or description of the currency.")
    decimal_places = Column(SmallInteger, nullable=True
		, comment="Number of decimal places for the currency.")
    internationalized_name_code = Column(String, nullable=True
		, comment="Code for the internationalized name of the currency.")

    def __repr__(self):
       return self.name

 ### 


class CustomerSegment(Model):
    __tablename__ = "customer_segment"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the customer segment.")
    name = Column(String, nullable=True
		, comment="Name or title of the customer segment.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or descriptions related to the customer segment.")

    def __repr__(self):
       return self.name

 ### 


class DocType(Model):
    __tablename__ = "doc_type"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the document type.")
    name = Column(String, nullable=True
		, comment="Name or title of the document type e.g. Passport, Drivers License.")
    doc_category = Column(Enum(t_doc_category), nullable=False)
    notes = Column(Text, nullable=True
		, comment="Any additional remarks or details about the document type.")
    required_information = Column(Text, nullable=True
		, comment="List or description of required fields/information for this document type.")
    is_serialized = Column(Boolean, default=False, nullable=True
		, comment="Does this document type have a serial number")
    serial_length = Column(Integer, nullable=True
		, comment="Typical length of a serial number for this document type")
    expires = Column(Boolean, default=False, nullable=True
		, comment="Does this type of document expire")
    validity_period = Column(Integer, nullable=True
		, comment="Standard validity duration of this type of document in days.")
    renewal_frequency = Column(Integer, nullable=True
		, comment="Frequency at which this document typically needs renewal, in days. Useful for setting reminders.")
    is_government_issued = Column(Boolean, default=False, nullable=True
		, comment="Indicates if this document is typically issued by a government authority.")
    is_digital = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the document is typically in digital format.")
    template_url = Column(String, nullable=True
		, comment="URL or link to a template or sample of this document type, if available.")
    example_image_url = Column(String, nullable=True
		, comment="URL or link to an example image of this document type.")
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document type was added to the system.")
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document type was last updated.")

    def __repr__(self):
       return self.name

 ### 


class MimeType(Model):
    __tablename__ = "mime_type"
    # __table_args__ = ( ) # tuple
    __doc__ = "Standard MIME types recognized by the content management system."
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    label = Column(String, nullable=True
		, comment="Label of this mime type")
    mime_type = Column(String, nullable=True)
    file_extension = Column(String, nullable=True
		, comment="File extensions for this mime type")

    def __repr__(self):
       return self.label

 ### 


class MimeTypeMap(Model):
    __tablename__ = "mime_type_map"
    # __table_args__ = ( ) # tuple
    __doc__ = "Maps extensions to mime types"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the MIME type mapping.")
    extension = Column(String, nullable=True
		, comment="File extension, such as jpg or pdf")
    mime_type = Column(String, nullable=True
		, comment="MIME type associated with the file extension.")

    def __repr__(self):
       return self.id

 ### 


class PaymentCard(Model):
    __tablename__ = "payment_card"
    # __table_args__ = ( ) # tuple
    __doc__ = "We want to store as little data as possible about peoples cards."
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the payment card.")
    bin = Column(String, nullable=True
		, comment="Bank Identification Number (BIN) of the card.")
    pan = Column(String, nullable=True
		, comment="Primary Account Number (PAN) of the card.")
    credit_card_expired = Column(Boolean, default=False
		, comment="Indicates whether the credit card has expired.")
    card_token = Column(String
		, comment="Tokenized representation of the card.")
    issue_number = Column(String
		, comment="Issue number of the card.")
    bill_to_city = Column(String, nullable=True
		, comment="City associated with the billing address.")
    masked_number = Column(String
		, comment="Masked version of the card number.")
    name = Column(String
		, comment="Name associated with the card.")
    company_name = Column(String, nullable=True
		, comment="Company name associated with the card.")
    card_holder_name = Column(String
		, comment="Name of the cardholder.")
    number_last_digits = Column(String
		, comment="Last digits of the card number.")
    payment_card_type = Column(String
		, comment="Type of payment card (e.g., Visa, Mastercard).")
    derived_card_type_code = Column(String, nullable=True
		, comment="Derived card type code.")
    expiration_year = Column(Integer, nullable=True
		, comment="Year of card expiration.")
    expiration_month = Column(Integer, nullable=True
		, comment="Month of card expiration.")
    bill_to_street = Column(String, nullable=True
		, comment="Street address associated with the billing address.")
    bill_to_street2 = Column(String, nullable=True
		, comment="Additional street address information.")
    bill_to_first_name = Column(String, nullable=True
		, comment="First name associated with the billing address.")
    bill_to_last_name = Column(String, nullable=True
		, comment="Last name associated with the billing address.")
    payment_method_status = Column(String, nullable=True
		, comment="Status of the payment method.")
    card_number = Column(String, nullable=True
		, comment="Masked version of the card number.")
    cardholder_name = Column(String, nullable=True
		, comment="Name of the cardholder.")
    card_expiration = Column(String, nullable=True
		, comment="Expiration date of the card (stored as MM/YY format).")
    service_code = Column(String, nullable=True
		, comment="Service code associated with the card.")
    cvv = Column(String, nullable=True
		, comment="Masked or hashed version of the CVV (Card Verification Value).")

    def __repr__(self):
       return self.name

 ### 


class Promotion(Model):
    __tablename__ = "promotion"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the promotion.")
    name = Column(String, nullable=True
		, comment="Name or title of the promotion.")
    notes = Column(Text, nullable=True
		, comment="Additional remarks or details about the promotion.")
    start_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Start date of the promotion.")
    end_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="End date of the promotion.")

    def __repr__(self):
       return self.name

 ### 


class RiskProfile(Model):
    __tablename__ = "risk_profile"
    # __table_args__ = ( ) # tuple
    __doc__ = "Risk associated with financial transactions"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True
		, comment="Unique identifier for each risk profile")
    name = Column(String, nullable=True
		, comment="Name of the risk profile")
    description = Column(Text, nullable=True
		, comment="Detailed description of the risk profile")
    risk_score = Column(Integer, nullable=True
		, comment="Quantitative measure of risk, often based on a specific scoring system")
    risk_category = Column(String, nullable=True
		, comment="Categorization of risk (e.g., Low, Moderate, High)")
    max_acceptable_loss = Column(Numeric, nullable=True
		, comment="Maximum financial loss that is acceptable for this risk profile, usually a percentage or monetary value")
    probability_of_loss = Column(Numeric, nullable=True
		, comment="Likelihood of incurring a loss, often expressed as a percentage")
    historical_volatility = Column(Numeric, nullable=True
		, comment="Measure of the variation in the price of the asset over time")
    liquidity_rating = Column(Integer, nullable=True
		, comment="Rating representing the ease of converting the asset to cash without significant loss of value")
    regulatory_compliance = Column(String, nullable=True
		, comment="Indication of any specific regulatory compliance considerations relevant to the risk profile")
    market_sensitivity = Column(Numeric, nullable=True
		, comment="Measure of how sensitive the asset is to market fluctuations")
    credit_rating = Column(String, nullable=True
		, comment="Creditworthiness of a debtor, particularly relevant in the context of credit risk")
    investment_horizon = Column(String, nullable=True
		, comment="Expected duration for holding the investment")
    sector_exposure = Column(String, nullable=True
		, comment="Indicates the sectors to which the investment is exposed")
    geographic_exposure = Column(String, nullable=True
		, comment="Highlights the geographical regions involved in the transaction")

    def __repr__(self):
       return self.name

 ### 


class Techparams(Model):
    __tablename__ = "techparams"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    tp_key = Column(String, nullable=True
		, comment="Tech Param Key")
    tp_value = Column(Text, nullable=True
		, comment="Tech Param Value")
    enabled = Column(Boolean, default=True, nullable=True
		, comment="Is this param used")
    notes = Column(Text, nullable=True
		, comment="Notes on this parameter")

    def __repr__(self):
       return self.id

 ### 


class TokenProvider(Model):
    __tablename__ = "token_provider"
    # __table_args__ = ( ) # tuple
    __doc__ = "Connection parameters for differnt providers"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the token provider.")
    name = Column(String
		, comment="Name of the token provider.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or remarks about the token provider.")
    priv_key = Column(Text, nullable=True
		, comment="Private key used for authentication and encryption.")
    pub_key = Column(Text, nullable=True
		, comment="Public key used for authentication and encryption.")
    endpoint = Column(Text, nullable=True
		, comment="Endpoint URL for communication with the token provider.")
    protocol = Column(Text, nullable=True
		, comment="Communication protocol used with the token provider (e.g., HTTPS).")
    auth = Column(Text, nullable=True
		, comment="Authentication mechanism or credentials required for access.")
    ssl = Column(Text, nullable=True
		, comment="SSL/TLS configuration or settings for secure communication.")
    ip_whitelist = Column(Text, nullable=True
		, comment="List of whitelisted IP addresses for accessing the token provider.")
    password = Column(String, nullable=True
		, comment="Password associated with the token provider.")
    enabled = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the token provider is enabled or disabled.")

    def __repr__(self):
       return self.name

 ### 


class TransRoutingThresholds(Model):
    __tablename__ = "trans_routing_thresholds"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the threshold.")
    name = Column(String, nullable=True
		, comment="Name or description of the threshold.")
    min_amount = Column(Numeric, nullable=True
		, comment="Minimum transaction amount that triggers this threshold.")
    max_amount = Column(Numeric, nullable=True
		, comment="Maximum transaction amount that triggers this threshold.")
    priority = Column(Integer, nullable=True
		, comment="Priority level for this threshold.")

    def __repr__(self):
       return self.name

 ### 


class TransType(Model):
    __tablename__ = "trans_type"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the transaction type.")
    name = Column(String, nullable=True
		, comment="Name or title of the transaction type, e.g., Deposit, Withdrawal, Transfer, Bill Payment, etc.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or descriptions related to the transaction type.")

    def __repr__(self):
       return self.name

 ### 


class UserExt(Model):
    __tablename__ = "user_ext"
    # __table_args__ = ( ) # tuple
    __doc__ = "Additional data for user registration"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the user.")
    manager_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="Manager ID - References the manager of the user, if applicable.")
    middle_name = Column(String, nullable=True
		, comment="Middle name of the user, if available.")
    employee_number = Column(String, nullable=True
		, comment="Employee number assigned to the user, if applicable.")
    job_title = Column(String, nullable=True
		, comment="Job title or position of the user within the organization.")
    phone_number = Column(String, nullable=True
		, comment="Phone number for contacting the user.")
    email = Column(String, nullable=True
		, comment="Email address of the user, used for communication.")
    user_data = Column(Text, nullable=True
		, comment="Additional user data or information, such as user preferences or details.")
    manager = relationship('UserExt', backref='user_exts_manager', primaryjoin='UserExt.manager_id_fk == UserExt.id', remote_side=[id])

    def __repr__(self):
       return self.middle_name

 ### 


class Biller(Model):
    __tablename__ = "biller"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the biller.")
    category_id_fk = Column(Integer, ForeignKey('biller_category.id'), nullable=True
		, comment="Foreign key referencing the biller category to which this biller belongs.")
    code = Column(String
		, comment="Unique code or identifier for the biller.")
    name = Column(String, nullable=True
		, comment="Name or title of the biller.")
    url = Column(String, nullable=True
		, comment="URL or link associated with the biller.")
    note = Column(Text, nullable=True
		, comment="Additional notes or remarks about the biller.")
    category = relationship(BillerCategory, backref='billers_category', primaryjoin='Biller.category_id_fk == BillerCategory.id')

    def __repr__(self):
       return self.name

 ### 


class State(Model):
    __tablename__ = "state"
    # __table_args__ = ( ) # tuple
    __doc__ = "List of States"
    # class_permission_name = "view"
    country_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True)
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="ID of this column")
    code = Column(String, nullable=True
		, comment="State Code")
    name = Column(String, nullable=True
		, comment="Name of the state")
    description = Column(Text, nullable=True
		, comment="Brief description of the state")
    country = relationship(Country, backref='states_country', primaryjoin='State.country_id_fk == Country.id')

    def __repr__(self):
       return self.name

 ### 


class Token(Model):
    __tablename__ = "token"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the token.")
    token_provider_id_fk = Column(Integer, ForeignKey('token_provider.id'), nullable=True
		, comment="Foreign key referencing the associated token provider.")
    token_name = Column(String, nullable=True
		, comment="Name or identifier for the token.")
    token_issue_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the token was issued.")
    token_expiry_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the token expires.")
    token_validity = Column(Integer, nullable=True
		, comment="Duration of token validity in seconds.")
    token_expired = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the token has expired.")
    token_value = Column(String, nullable=True
		, comment="Actual token value or token string.")
    token_username = Column(String, nullable=True
		, comment="Username associated with the token.")
    token_password = Column(String, nullable=True
		, comment="Password associated with the token.")
    token_notes = Column(Text, nullable=True
		, comment="Additional notes or remarks about the token.")
    token_client_secret = Column(Text, nullable=True
		, comment="Client secret associated with the token.")
    enabled = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the token is enabled or disabled.")
    token_provider = relationship(TokenProvider, backref='tokens_token_provider', primaryjoin='Token.token_provider_id_fk == TokenProvider.id')

    def __repr__(self):
       return self.token_name

 ### 


class BillerOffering(Model):
    __tablename__ = "biller_offering"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    biller_id_fk = Column(Integer, ForeignKey('biller.id'), nullable=True
		, comment="Foreign key referencing the biller to which this offering belongs.")
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the biller offering.")
    name = Column(String, nullable=True
		, comment="Name or title of the biller offering.")
    description = Column(Text, nullable=True
		, comment="Description of the biller offering.")
    price = Column(Numeric, nullable=True
		, comment="Price or cost associated with the biller offering.")
    biller = relationship(Biller, backref='biller_offerings_biller', primaryjoin='BillerOffering.biller_id_fk == Biller.id')

    def __repr__(self):
       return self.name

 ### 


class Lga(Model):
    __tablename__ = "lga"
    # __table_args__ = ( ) # tuple
    __doc__ = "Local Government Area"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="ID of this column")
    state_id_fk = Column(Integer, ForeignKey('state.id'), nullable=True
		, comment="Foreign Key of the state")
    code = Column(String, nullable=True
		, comment="Local Government Code")
    lga_name = Column(String, nullable=True
		, comment="LGA Name")
    state = relationship(State, backref='lgas_state', primaryjoin='Lga.state_id_fk == State.id')

    def __repr__(self):
       return self.code

 ### 


class Agent(Model):
    __tablename__ = "agent"
    # __table_args__ = ( ) # tuple
    __doc__ = "Agent Registration"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the agent.")
    aggregator_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="References the aggregator agent if applicable.")
    is_aggregator = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the agent is an aggregator.")
    became_aggregator_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the agent became an aggregator, if applicable.")
    assigned_pos_count = Column(Integer
		, comment="Count of assigned point-of-sale (POS) devices.")
    aggregator_pos_threshold = Column(Integer, nullable=True
		, comment="Threshold for becoming an aggregator based on POS device count.")
    verification_status = Column(Enum(t_verification_status), nullable=False)
    verification_status_notes = Column(Text, nullable=True
		, comment="Additional notes or remarks about the agents verification status.")
    agent_type = Column(Enum(t_org_type), nullable=False)
    agent_role = Column(Enum(t_agent_role), nullable=False)
    agent_tier_id_fk = Column(Integer, ForeignKey('agent_tier.id'), nullable=True
		, comment="References the agents tier.")
    account_manager_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the account manager responsible for this agent.")
    agent_name = Column(String, nullable=True
		, comment="Name of the agent.")
    alias = Column(String, nullable=True
		, comment="Alias or alternate name for reporting purposes, if available.")
    phone_country_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="References the country of the agents phone number.")
    phone = Column(String
		, comment="Primary phone number of the agent.")
    phone_ext = Column(String, nullable=True
		, comment="Extension for the primary phone number.")
    alt_phone_country_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="References the country of the alternate phone number.")
    alt_phone = Column(String, nullable=True
		, comment="Alternate phone number for the agent.")
    alt_phone_ext = Column(String, nullable=True
		, comment="Extension for the alternate phone number.")
    email = Column(String, nullable=True
		, comment="Email address of the agent.")
    alt_email = Column(String, nullable=True
		, comment="Alternate email address for the agent.")
    bvn = Column(String, nullable=True
		, comment="Bank Verification Number (BVN) of the agent.")
    bvn_verified = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the BVN is verified.")
    bvn_verification_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of BVN verification.")
    bvn_verification_code = Column(Text, nullable=True
		, comment="Verification code for BVN.")
    tax_id = Column(String, nullable=True
		, comment="Tax identification number of the agent.")
    bank_id_fk = Column(Integer, ForeignKey('bank.id'), nullable=True
		, comment="References the bank where the agent has an account.")
    bank_acc_no = Column(String, nullable=True
		, comment="Agent bank account number.")
    biz_name = Column(String, nullable=True
		, comment="Name of the agents business, if applicable.")
    biz_state_id_fk = Column(Integer, ForeignKey('state.id'), nullable=True
		, comment="References the state where the business is located.")
    biz_lga_id_fk = Column(Integer, ForeignKey('lga.id'), nullable=True
		, comment="References the LGA where the business is located.")
    biz_city = Column(String, nullable=True
		, comment="City where the business is located.")
    biz_city_area = Column(String, nullable=True
		, comment="Specific area within the city where the business is located.")
    biz_street = Column(String, nullable=True
		, comment="Street address of the business.")
    biz_building = Column(String, nullable=True
		, comment="Building name or number of the business location.")
    biz_address = Column(Text, nullable=True
		, comment="Detailed address information for the business.")
    biz_poa_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    biz_poa_desc = Column(String, nullable=True
		, comment="Description of the Proof of Address document.")
    biz_poa_valid = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the Proof of Address is valid.")
    biz_lat = Column(Float, nullable=True
		, comment="Latitude coordinates of the business location.")
    biz_lon = Column(Float, nullable=True
		, comment="Longitude coordinates of the business location.")
    biz_loc = Column(Text, nullable=True
		, comment="Location description of the business.")
    biz_ggl_code = Column(String, nullable=True
		, comment="Google Maps code for the business location.")
    company_name = Column(String, nullable=True
		, comment="Name of the company associated with the agent.")
    cac_number = Column(String, nullable=True
		, comment="Corporate Affairs Commission (CAC) registration number.")
    cac_reg_date = Column(Date, nullable=True
		, comment="Date of CAC registration.")
    cac_cert_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    cac_cert_no = Column(String, nullable=True
		, comment="Certificate number issued by CAC.")
    ref_code = Column(String, nullable=True
		, comment="Reference code associated with the agent.")
    access_pin = Column(String, nullable=True
		, comment="Access PIN for agent transactions.")
    registered_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the user who registered the agent.")
    registration_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of agent registration.")
    reviewed_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the user who reviewed the agent.")
    review_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of agent review.")
    approved_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the user who approved the agent.")
    approval_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of agent approval.")
    approval_narrative = Column(Text, nullable=True
		, comment="Narrative or notes related to agent approval.")
    kyc_submit_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of KYC document submission.")
    kyc_verification_status = Column(Enum(t_verification_status), nullable=False)
    kyc_approval_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of KYC document approval.")
    kyc_ref_code = Column(String, nullable=True
		, comment="Reference code associated with KYC.")
    kyc_rejection_narrative = Column(Text, nullable=True
		, comment="Narrative or notes related to KYC rejection.")
    kyc_rejection_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the user who rejected KYC.")
    rejection_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of agent rejection.")
    rejection_narrative = Column(Text, nullable=True
		, comment="Narrative or notes related to agent rejection.")
    rejected_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="References the user who rejected the agent.")
    face_matrix = Column(Text, nullable=True
		, comment="Biometric data for face recognition.")
    finger_print_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    agent_public_key = Column(Text, nullable=True
		, comment="Public key for cryptographic operations.")
    agent_pj_expiry = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of public key expiration.")
    agent_history = Column(Text, nullable=True
		, comment="Textual history of agent-related events.")
    account_manager = relationship(UserExt, backref='agents_account_manager', primaryjoin='Agent.account_manager_id_fk == UserExt.id')
    agent_tier = relationship(AgentTier, backref='agents_agent_tier', primaryjoin='Agent.agent_tier_id_fk == AgentTier.id')
    aggregator = relationship('Agent', backref='agents_aggregator', primaryjoin='Agent.aggregator_id_fk == Agent.id', remote_side=[id])
    alt_phone_country = relationship(Country, backref='agents_alt_phone_country', primaryjoin='Agent.alt_phone_country_id_fk == Country.id')
    approved_by = relationship(UserExt, backref='agents_approved_by', primaryjoin='Agent.approved_by_id_fk == UserExt.id')
    bank = relationship(Bank, backref='agents_bank', primaryjoin='Agent.bank_id_fk == Bank.id')
    biz_lga = relationship(Lga, backref='agents_biz_lga', primaryjoin='Agent.biz_lga_id_fk == Lga.id')
    biz_state = relationship(State, backref='agents_biz_state', primaryjoin='Agent.biz_state_id_fk == State.id')
    kyc_rejection_by = relationship(UserExt, backref='agents_kyc_rejection_by', primaryjoin='Agent.kyc_rejection_by_id_fk == UserExt.id')
    phone_country = relationship(Country, backref='agents_phone_country', primaryjoin='Agent.phone_country_id_fk == Country.id')
    registered_by = relationship(UserExt, backref='agents_registered_by', primaryjoin='Agent.registered_by_id_fk == UserExt.id')
    rejected_by = relationship(UserExt, backref='agents_rejected_by', primaryjoin='Agent.rejected_by_id_fk == UserExt.id')
    reviewed_by = relationship(UserExt, backref='agents_reviewed_by', primaryjoin='Agent.reviewed_by_id_fk == UserExt.id')

    def __repr__(self):
       return self.alias

 ### 


class Pos(Model):
    __tablename__ = "pos"
    # __table_args__ = ( ) # tuple
    __doc__ = "Points-of-Sale"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the Point of Sale (PoS).")
    serial_no = Column(String, nullable=True
		, comment="Unique serial number for the PoS.")
    imei = Column(String, nullable=True
		, comment="IMEI number of the PoS, if applicable.")
    mac_addr = Column(String, nullable=True
		, comment="MAC address of the PoS.")
    device_model = Column(String, nullable=True
		, comment="Model of the PoS device.")
    device_make = Column(String, nullable=True
		, comment="Make or manufacturer of the PoS device.")
    device_mfg = Column(String, nullable=True
		, comment="Manufacturer of the PoS device.")
    os_version = Column(String, nullable=True
		, comment="Operating system version of the PoS.")
    device_color = Column(String, nullable=True
		, comment="Color of the PoS device.")
    device_condition = Column(String, nullable=True
		, comment="Condition of the PoS device (e.g., working, irreparable, repaired).")
    status = Column(String, nullable=True
		, comment="Current status of the PoS.")
    owner_type = Column(String, nullable=True
		, comment="Type of owner of the PoS.")
    registration_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the PoS was registered.")
    assigned = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the PoS is assigned.")
    assigned_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the PoS was assigned.")
    assigned_narrative = Column(Text, nullable=True
		, comment="Narrative or description of the assignment.")
    active = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the PoS is active.")
    activation_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the PoS was activated.")
    last_active = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of the last activity.")
    deployed = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the PoS is deployed.")
    deploy_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the PoS was deployed.")
    deploy_narrative = Column(Text, nullable=True
		, comment="Narrative or description of the deployment.")
    returned = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the PoS was returned.")
    return_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the PoS was returned.")
    return_narrative = Column(Text, nullable=True
		, comment="Narrative or description of the return.")
    return_received_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the return was received.")
    return_received_by_id_fk = Column(Integer, ForeignKey('user_ext.id'), nullable=True
		, comment="Reference to the user who received the return.")
    state_id_fk = Column(Integer, ForeignKey('state.id'), nullable=True
		, comment="Reference to the state where the PoS is deployed.")
    lga_id_fk = Column(Integer, ForeignKey('lga.id'), nullable=True
		, comment="Reference to the local government area where the PoS is deployed.")
    street_address = Column(String, nullable=True
		, comment="Street address of the PoS deployment location.")
    building_name = Column(String, nullable=True
		, comment="Name of the building where the PoS is deployed.")
    contact_phone_num = Column(String, nullable=True
		, comment="Contact phone number for the PoS deployment location.")
    pos_user = Column(String, nullable=True
		, comment="User associated with the PoS.")
    crypt_priv_key = Column(Text, nullable=True
		, comment="Private key for cryptographic operations.")
    crypt_pub_key = Column(Text, nullable=True
		, comment="Public key for cryptographic operations.")
    crypt_password = Column(Text, nullable=True
		, comment="Password for cryptographic operations.")
    override_key = Column(Text, nullable=True
		, comment="Override key for cryptographic operations.")
    lga = relationship(Lga, backref='poss_lga', primaryjoin='Pos.lga_id_fk == Lga.id')
    return_received_by = relationship(UserExt, backref='poss_return_received_by', primaryjoin='Pos.return_received_by_id_fk == UserExt.id')
    state = relationship(State, backref='poss_state', primaryjoin='Pos.state_id_fk == State.id')

    def __repr__(self):
       return self.device_model

 ### 


class AgentPosLink(Model):
    __tablename__ = "agent_pos_link"
    # __table_args__ = ( ) # tuple
    __doc__ = "Records the assignment of a Point of Sale (PoS) to an agent."
    # class_permission_name = "view"
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), primary_key=True
		, comment="Foreign key reference to the agent to whom the PoS is assigned.")
    pos_id_fk = Column(Integer, ForeignKey('pos.id'), primary_key=True
		, comment="Foreign key reference to the Point of Sale (PoS) being assigned.")
    assigned_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the PoS is assigned.")
    assigned_by = Column(String, nullable=True
		, comment="User who assigned the PoS to the agent.")
    received_by = Column(String, nullable=True
		, comment="User who received the PoS.")
    received_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the PoS is received by the agent.")
    received_location = Column(String, nullable=True
		, comment="Location where the PoS is received.")
    delivery_note = Column(Text, nullable=True
		, comment="Delivery note associated with the PoS assignment.")
    delivery_note_printed = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the delivery note has been printed.")
    activated = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the PoS has been activated.")
    activation_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the PoS is activated.")
    activation_otp = Column(String, nullable=True
		, comment="One-Time Password (OTP) used for activation.")
    otp_sent = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the OTP has been sent.")
    otp_sent_time = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the OTP is sent.")
    otp_used = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the OTP has been used for activation.")
    history = Column(Text, nullable=True
		, comment="Text field to store the history or additional information about the PoS assignment.")
    agent = relationship(Agent, backref='agent_pos_links_agent', primaryjoin='AgentPosLink.agent_id_fk == Agent.id')
    pos = relationship(Pos, backref='agent_pos_links_pos', primaryjoin='AgentPosLink.pos_id_fk == Pos.id')

    def __repr__(self):
       return self.agent_id_fk

 ### 


class Commission(Model):
    __tablename__ = "commission"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the commission reference.")
    agent_type = Column(Enum(t_org_type), nullable=False)
    agent_tier_level_id_fk = Column(Integer, ForeignKey('agent_tier.id'), nullable=True
		, comment="Foreign key to the agent tier level if applicable.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="Foreign key to the agent associated with this commission reference.")
    state_id_fk = Column(Integer, ForeignKey('state.id'), nullable=True
		, comment="Foreign key to the state if applicable.")
    lga_id_fk = Column(Integer, ForeignKey('lga.id'), nullable=True
		, comment="Foreign key to the local government area if applicable.")
    currency_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="Commission of specfic currencies, defaults to NGN")
    risk_profile_id_fk = Column(Integer, ForeignKey('risk_profile.id'), nullable=True
		, comment="Risk associated with financial transactions")
    biller_id_fk = Column(Integer, ForeignKey('biller.id'), nullable=True
		, comment="Foreign key to the biller associated with this commission reference.")
    biller_offering_id_fk = Column(Integer, ForeignKey('biller_offering.id'), nullable=True
		, comment="Foreign key to the biller offering associated with this commission reference.")
    transaction_type_id_fk = Column(Integer, ForeignKey('trans_type.id'), nullable=True
		, comment="Foreign key to the transaction type if applicable.")
    customer_segment_id_fk = Column(Integer, ForeignKey('customer_segment.id'), nullable=True
		, comment="Foreign key to the customer segment.")
    special_promotion_id_fk = Column(Integer, ForeignKey('promotion.id'), nullable=True
		, comment="Foreign key to the special promotion if applicable.")
    min_trans_amount = Column(Numeric, nullable=True
		, comment="Minimum transaction amount for commission calculation.")
    max_trans_amount = Column(Numeric, nullable=True
		, comment="Maximum transaction amount for commission calculation.")
    min_max_step = Column(Integer, nullable=True
		, comment="Step value for minimum and maximum transaction amounts.")
    min_comm_amount = Column(Numeric, nullable=True
		, comment="Minimum commission amount.")
    max_comm_amount = Column(Numeric, nullable=True
		, comment="Maximum commission amount.")
    commission_rate = Column(Numeric, nullable=True
		, comment="Commission rate in percentage.")
    start_time = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Start time of commission rate validity.")
    end_time = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="End time of commission rate validity.")
    start_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Start date of commission rate validity (if applicable).")
    end_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="End date of commission rate validity (if applicable).")
    agent = relationship(Agent, backref='commissions_agent', primaryjoin='Commission.agent_id_fk == Agent.id')
    agent_tier_level = relationship(AgentTier, backref='commissions_agent_tier_level', primaryjoin='Commission.agent_tier_level_id_fk == AgentTier.id')
    biller = relationship(Biller, backref='commissions_biller', primaryjoin='Commission.biller_id_fk == Biller.id')
    biller_offering = relationship(BillerOffering, backref='commissions_biller_offering', primaryjoin='Commission.biller_offering_id_fk == BillerOffering.id')
    currency = relationship(Currency, backref='commissions_currency', primaryjoin='Commission.currency_id_fk == Currency.id')
    customer_segment = relationship(CustomerSegment, backref='commissions_customer_segment', primaryjoin='Commission.customer_segment_id_fk == CustomerSegment.id')
    lga = relationship(Lga, backref='commissions_lga', primaryjoin='Commission.lga_id_fk == Lga.id')
    risk_profile = relationship(RiskProfile, backref='commissions_risk_profile', primaryjoin='Commission.risk_profile_id_fk == RiskProfile.id')
    special_promotion = relationship(Promotion, backref='commissions_special_promotion', primaryjoin='Commission.special_promotion_id_fk == Promotion.id')
    state = relationship(State, backref='commissions_state', primaryjoin='Commission.state_id_fk == State.id')
    transaction_type = relationship(TransType, backref='commissions_transaction_type', primaryjoin='Commission.transaction_type_id_fk == TransType.id')

    def __repr__(self):
       return self.id

 ### 


class Person(Model):
    __tablename__ = "person"
    # __table_args__ = ( ) # tuple
    __doc__ = "People who work for an Agent, Bank or Others"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the person.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="References the associated agent if applicable.")
    next_of_kin_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="References the next of kin for this person, if applicable.")
    person_role = Column(Enum(t_person_role), nullable=False)
    first_name = Column(String, nullable=True
		, comment="First name of the person.")
    middle_name = Column(String, nullable=True
		, comment="Middle name of the person.")
    surname = Column(String, nullable=True
		, comment="Last name or surname of the person.")
    nick_name = Column(String, nullable=True
		, comment="Nickname or alias of the person.")
    gender = Column(Enum(t_gender), nullable=False)
    photo_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    signature_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    bvn_no = Column(String, nullable=True
		, comment="Bank Verification Number (BVN) of the person.")
    bvn_verified = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the BVN is verified.")
    bvn_verification_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of BVN verification.")
    bvn_verification_code = Column(Text, nullable=True
		, comment="Verification code for BVN.")
    tax_id = Column(String, nullable=True
		, comment="Tax identification number of the person.")
    home_poa_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    home_poa_desc = Column(String, nullable=True
		, comment="Description of the Proof of Address document for the home address.")
    home_poa_valid = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the Proof of Address for the home is valid.")
    home_lat = Column(Float, nullable=True
		, comment="Latitude coordinates of the home address.")
    home_lon = Column(Float, nullable=True
		, comment="Longitude coordinates of the home address.")
    home_loc = Column(Text, nullable=True
		, comment="Location description of the home address.")
    home_ggl_code = Column(String, nullable=True
		, comment="Google Maps code for the home address.")
    agent = relationship(Agent, backref='persons_agent', primaryjoin='Person.agent_id_fk == Agent.id')
    next_of_kin = relationship('Person', backref='persons_next_of_kin', primaryjoin='Person.next_of_kin_id_fk == Person.id', remote_side=[id])

    def __repr__(self):
       return self.first_name

 ### 


class Wallet(Model):
    __tablename__ = "wallet"
    # __table_args__ = ( ) # tuple
    __doc__ = "Each Point of Sale (PoS) has an individual wallet."
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the wallet.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="Foreign key reference to the agent associated with the wallet.")
    pos_id_fk = Column(Integer, ForeignKey('pos.id'), nullable=True
		, comment="Foreign key reference to the Point of Sale (PoS) associated with the wallet.")
    wallet_name = Column(String, nullable=True
		, comment="Name of the wallet.")
    wallet_balance = Column(Numeric, nullable=True
		, comment="The balance or amount of funds in the wallet.")
    wallet_locked = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the wallet is locked.")
    wallet_active = Column(Boolean, default=True, nullable=True
		, comment="Indicates whether the wallet is active.")
    wallet_code = Column(String, nullable=True
		, comment="Code or identifier associated with the wallet for security purposes.")
    wallet_crypt = Column(Text, nullable=True
		, comment="Cryptographic information related to the wallet.")
    wallet_narrative = Column(Text, nullable=True
		, comment="Narrative or additional information about the wallet.")
    agent = relationship(Agent, backref='wallets_agent', primaryjoin='Wallet.agent_id_fk == Agent.id')
    pos = relationship(Pos, backref='wallets_pos', primaryjoin='Wallet.pos_id_fk == Pos.id')

    def __repr__(self):
       return self.wallet_name

 ### 


class AgentPersonLink(Model):
    __tablename__ = "agent_person_link"
    # __table_args__ = ( ) # tuple
    __doc__ = "People associated with an Agent"
    # class_permission_name = "view"
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True
		, comment="Foreign key reference to the person linked to the agent.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), primary_key=True
		, comment="Foreign key reference to the agent linked to the person.")
    agent = relationship(Agent, backref='agent_person_links_agent', primaryjoin='AgentPersonLink.agent_id_fk == Agent.id')
    person = relationship(Person, backref='agent_person_links_person', primaryjoin='AgentPersonLink.person_id_fk == Person.id')

    def __repr__(self):
       return self.person_id_fk

 ### 


class Contact(Model):
    __tablename__ = "contact"
    # __table_args__ = ( ) # tuple
    __doc__ = "Agent or person contacts"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the contact.")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="Reference to the individual associated with this contact.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="Reference to the organization associated with this contact.")
    contact_type_id_fk = Column(Integer, ForeignKey('contact_type.id')
		, comment="Reference to the type of contact.")
    contact = Column(String
		, comment="Actual contact value, e.g., phone number or email address.")
    priority = Column(Integer
		, comment="Ordering priority for displaying or using the contact. Lower value indicates higher priority.")
    best_time_to_contact_start = Column(Time, nullable=True
		, comment="Preferred start time when the individual/organization is available for contact.")
    best_time_to_contact_end = Column(Time, nullable=True
		, comment="Preferred end time for availability.")
    active_from_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Date when this contact became active or relevant.")
    active_to_date = Column(Date, nullable=True
		, comment="Date when this contact ceases to be active or relevant.")
    for_business_use = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the contact is primarily for business purposes.")
    for_personal_use = Column(Boolean, default=True, nullable=True
		, comment="Indicates if the contact is primarily for personal use.")
    do_not_use = Column(Boolean, default=False, nullable=True
		, comment="Indicates if there are any restrictions or requests not to use this contact.")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="Indicates if this contact is currently active and usable.")
    is_blocked = Column(Boolean, default=False, nullable=True
		, comment="Indicates if this contact is blocked, maybe due to spam or other reasons.")
    is_verified = Column(Boolean, default=False, nullable=True
		, comment="Indicates if this contact has been verified, e.g., via OTP or email confirmation.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or context about the contact.")
    agent = relationship(Agent, backref='contacts_agent', primaryjoin='Contact.agent_id_fk == Agent.id')
    contact_type = relationship(ContactType, backref='contacts_contact_type', primaryjoin='Contact.contact_type_id_fk == ContactType.id')
    person = relationship(Person, backref='contacts_person', primaryjoin='Contact.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Doc(Model):
    __tablename__ = "doc"
    # __table_args__ = ( ) # tuple
    __doc__ = "Document Archives"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the document.")
    doc_type_id_fk = Column(Integer, ForeignKey('doc_type.id'), nullable=True
		, comment="References the type of document e.g. passport, license.")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="The person to whom the document belongs.")
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), nullable=True
		, comment="The organization associated with the document.")
    doc_front_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    doc_back_img = Column(ImageColumn(size=(300, 300, True), thumbnail_size=(30, 30, True)))
    doc_name = Column(String, nullable=True
		, comment="Name or title of the document.")
    doc_content_type_id_fk = Column(Integer, ForeignKey('mime_type.id'), nullable=True
		, comment="MIME type of the document content e.g. application/pdf, image/jpeg.")
    doc_url = Column(Text, nullable=True
		, comment="Actual doc in pdf or other format")
    doc_length = Column(Integer, nullable=True
		, comment="Size of the document in bytes or another measure.")
    doc_text = Column(Text, nullable=True
		, comment="Text content extracted from the document. Useful for search and analytics. May be stored in another database for scalability.")
    identification_number = Column(String, nullable=True
		, comment="Unique identification number, e.g., passport number.")
    serial_number = Column(String, nullable=True
		, comment="Serial number of the document if applicable.")
    description = Column(Text, nullable=True
		, comment="Detailed description or remarks about the document.")
    file_name = Column(String, nullable=True
		, comment="Name of the file if stored digitally.")
    page_count = Column(Integer, nullable=True
		, comment="Number of pages in the document, if applicable.")
    issued_on = Column(Date, nullable=True
		, comment="The date when the document was issued.")
    issued_by_authority = Column(String, nullable=True
		, comment="Authority or organization that issued the document.")
    issued_at = Column(String, nullable=True
		, comment="Place or location where the document was issued.")
    expires_on = Column(Date, nullable=True
		, comment="Expiration date of the document.")
    is_expired = Column(Boolean, default=False, nullable=True
		, comment="Flag to indicate if the document has expired.")
    verified = Column(Boolean, default=False, nullable=True)
    verification_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="The date when the document was verified.")
    verification_code = Column(Text, nullable=True)
    uploaded_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document was uploaded into the system.")
    updated_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document record was last updated.")
    agent = relationship(Agent, backref='docs_agent', primaryjoin='Doc.agent_id_fk == Agent.id')
    doc_content_type = relationship(MimeType, backref='docs_doc_content_type', primaryjoin='Doc.doc_content_type_id_fk == MimeType.id')
    doc_type = relationship(DocType, backref='docs_doc_type', primaryjoin='Doc.doc_type_id_fk == DocType.id')
    person = relationship(Person, backref='docs_person', primaryjoin='Doc.person_id_fk == Person.id')

    def __repr__(self):
       return self.doc_name

 ### 


class PersonAdminData(Model):
    __tablename__ = "person_admin_data"
    # __table_args__ = ( ) # tuple
    __doc__ = "Additional information on How to communicate and handle a persons data"
    # class_permission_name = "view"
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True
		, comment="References the associated person.")
    creation_time = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the data was created.")
    failed_login_count = Column(Integer, nullable=True
		, comment="Count of failed login attempts.")
    failed_login_timestamp = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp of the last failed login attempt.")
    password_last_set_time = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="Timestamp when the password was last set.")
    profile_picture = Column(String, nullable=True
		, comment="URL or path to the profile picture.")
    awatar = Column(String, nullable=True
		, comment="URL or path to the avatar.")
    screen_name = Column(String, nullable=True
		, comment="Screen name or username.")
    user_priv_cert = Column(Text, nullable=True
		, comment="Users private certificate.")
    user_pub_cert = Column(Text, nullable=True
		, comment="Users public certificate.")
    alt_security_identities = Column(Text, nullable=True
		, comment="Alternate security identities.")
    generated_UID = Column(UUID, nullable=True
		, comment="Generated unique identifier.")
    do_not_email = Column(Boolean, default=False, nullable=True
		, comment="Indicates if email communication is prohibited.")
    do_not_phone = Column(Boolean, default=False, nullable=True
		, comment="Indicates if phone communication is prohibited.")
    do_not_mail = Column(Boolean, default=False, nullable=True
		, comment="Indicates if physical mail communication is prohibited.")
    do_not_sms = Column(Boolean, default=False, nullable=True
		, comment="Indicates if SMS communication is prohibited.")
    do_not_trade = Column(Boolean, default=False, nullable=True
		, comment="Indicates if trading is prohibited.")
    opted_out = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the user has opted out of certain activities.")
    do_not_track_update_date = Column(Date, nullable=True
		, comment="Date when tracking was disabled.")
    do_not_process_from_update_date = Column(Date, nullable=True
		, comment="Date when processing was disabled.")
    do_not_market_from_update_date = Column(Date, nullable=True
		, comment="Date when marketing was disabled.")
    do_not_track_location_update_date = Column(Date, nullable=True
		, comment="Date when location tracking was disabled.")
    do_not_profile_from_update_date = Column(Date, nullable=True
		, comment="Date when profiling was disabled.")
    do_forget_me_from_update_date = Column(Date, nullable=True
		, comment="Date when -forget me- request was processed.")
    do_not_process_reason = Column(String, nullable=True
		, comment="Reason for not processing data.")
    no_merge_reason = Column(String, nullable=True
		, comment="Reason for not merging data.")
    do_extract_my_data_update_date = Column(Date, nullable=True
		, comment="Date when data extraction request was processed.")
    should_forget = Column(Boolean, nullable=True
		, comment="Indicates if data should be forgotten.")
    consumer_credit_score_provider_name = Column(String, nullable=True
		, comment="Name of the consumer credit score provider.")
    web_site_url = Column(String, nullable=True
		, comment="URL of the website.")
    ordering_name = Column(String, nullable=True
		, comment="Name used for ordering.")
    hospitalizations_last5_years_count = Column(Integer, nullable=True
		, comment="Count of hospitalizations in the last 5 years.")
    surgeries_last5_years_count = Column(Integer, nullable=True
		, comment="Count of surgeries in the last 5 years.")
    dependent_count = Column(Integer, nullable=True
		, comment="Count of dependents.")
    account_locked = Column(Boolean, default=False, nullable=True
		, comment="Indicates if the account is locked.")
    send_individual_data = Column(Boolean, nullable=True
		, comment="Indicates if individual data should be sent.")
    influencer_rating = Column(Integer, nullable=True
		, comment="Influencer rating.")
    person = relationship(Person, backref='person_admin_datas_person', primaryjoin='PersonAdminData.person_id_fk == Person.id')

    def __repr__(self):
       return self.screen_name

 ### 


class Trans(Model):
    __tablename__ = "trans"
    # __table_args__ = ( ) # tuple
    __doc__ = "Table of Transactions"
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="Unique identifier for the transaction.")
    coupon_id_fk = Column(Integer, ForeignKey('coupon.id'), nullable=True
		, comment="Reference to the associated coupon, if applicable.")
    customer_name = Column(String, nullable=True
		, comment="Name of the customer involved in the transaction.")
    trans_purpose = Column(Text, nullable=True
		, comment="Description of the transaction purpose.")
    customer_id = Column(String, nullable=True
		, comment="Identifier for the customer.")
    transaction_type = Column(Enum(t_payment_method), nullable=False)
    card_trans_type = Column(Enum(t_card_trans_type), nullable=False)
    agent_id_fk = Column(Integer, ForeignKey('agent.id')
		, comment="Merchant ID.")
    payment_card_id_fk = Column(Integer, ForeignKey('payment_card.id'), nullable=True
		, comment="Reference to the payment card used.")
    pos_id_fk = Column(Integer, ForeignKey('pos.id'), nullable=True
		, comment="Point of Sale (PoS) ID.")
    wallet_id_fk = Column(Integer, ForeignKey('wallet.id'), nullable=True
		, comment="Reference to the wallet used.")
    biller_id_fk = Column(Integer, ForeignKey('biller.id'), nullable=True
		, comment="Reference to the biller involved.")
    biller_offering_id_fk = Column(Integer, ForeignKey('biller_offering.id'), nullable=True
		, comment="Reference to the biller offering used.")
    trans_time = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of the transaction.")
    currency_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="Reference to the currency used.")
    trans_status = Column(Enum(t_transaction_status), nullable=False)
    trans_route_id_fk = Column(Integer, ForeignKey('trans_routing_thresholds.id'), nullable=True
		, comment="Reference to the routing threshold used.")
    origin_source = Column(Enum(t_payment_method), nullable=False)
    origin_ref_code = Column(String, nullable=True
		, comment="Reference code associated with the origin of the transaction.")
    origin_trans_notes = Column(Text, nullable=True
		, comment="Additional notes about the origin of the transaction.")
    origin_bank_id_fk = Column(Integer, ForeignKey('bank.id'), nullable=True
		, comment="Reference to the originating bank, if applicable.")
    origin_institution_code = Column(String, nullable=True
		, comment="Institution code for the origin.")
    origin_account_num = Column(String, nullable=True
		, comment="Account number associated with the origin.")
    origin_account_name = Column(String, nullable=True
		, comment="Account name associated with the origin.")
    origin_KYC_Level = Column(Integer, nullable=True
		, comment="KYC (Know Your Customer) level of the origin.")
    origin_Bank_Verification_Number = Column(String, nullable=True
		, comment="Bank Verification Number associated with the origin.")
    origin_bvn = Column(String, nullable=True
		, comment="Used for checking balance of the origin.")
    session_ref = Column(String, nullable=True
		, comment="Reference to the session related to the transaction.")
    transaction_ref = Column(String, nullable=True
		, comment="Reference code for the transaction.")
    channelCode = Column(Integer, nullable=True
		, comment="Code identifying the transaction channel.")
    name_enquiry_ref = Column(String, nullable=True
		, comment="Reference code for name inquiry related to the transaction.")
    api_transactionid = Column(String, nullable=True
		, comment="API transaction ID.")
    receipt_no = Column(String, nullable=True
		, comment="Receipt number associated with the transaction.")
    pin_based = Column(Boolean, default=False, nullable=True
		, comment="Whether the transaction is PIN-based.")
    pin_code = Column(String, nullable=True
		, comment="PIN code associated with the transaction.")
    pin_option = Column(String, nullable=True
		, comment="PIN option for the transaction.")
    authorization_code = Column(String, nullable=True
		, comment="Authorization code for the transaction.")
    acquirer_name = Column(String, nullable=True
		, comment="Name of the acquirer.")
    currency = Column(String, nullable=True
		, comment="Currency used for the transaction.")
    transaction_location = Column(String, nullable=True
		, comment="Location where the transaction occurred.")
    payment_reference = Column(String, nullable=True
		, comment="Reference code for the payment.")
    response_code = Column(String, nullable=True
		, comment="Response code related to the transaction.")
    trans_dest = Column(Enum(t_payment_method), nullable=False)
    bene_ref_code = Column(String, nullable=True
		, comment="Reference code associated with the beneficiary.")
    bene_trans_notes = Column(Text, nullable=True
		, comment="Additional notes about the beneficiary.")
    bene_bank_id_fk = Column(Integer, ForeignKey('bank.id'), nullable=True
		, comment="Reference to the beneficiary bank, if applicable.")
    bene_account_num = Column(String, nullable=True
		, comment="Account number associated with the beneficiary.")
    bene_institution_code = Column(String, nullable=True
		, comment="Institution code for the beneficiary.")
    bene_bank_verification_number = Column(String, nullable=True
		, comment="Bank Verification Number associated with the beneficiary.")
    bene_KYC_Level = Column(Integer, nullable=True
		, comment="KYC (Know Your Customer) level of the beneficiary.")
    bene_account_name = Column(String, nullable=True
		, comment="Account name associated with the beneficiary.")
    bene_phone_number = Column(String, nullable=True
		, comment="Phone number associated with the beneficiary.")
    bene_phone_denom = Column(String, nullable=True
		, comment="Denomination of the beneficiary phone.")
    bene_phone_product = Column(String, nullable=True
		, comment="Product associated with the beneficiary phone.")
    transaction_amount = Column(Numeric, nullable=True
		, comment="Amount of the transaction.")
    available_balance = Column(Numeric, nullable=True
		, comment="Available balance for the transaction.")
    svc_fees = Column(Numeric, nullable=True
		, comment="Service fees associated with the transaction.")
    comm_total = Column(Numeric, nullable=True
		, comment="Total commission amount for the transaction.")
    comm_agent = Column(Numeric, nullable=True
		, comment="Commission amount for the agent.")
    comm_aggr = Column(Numeric, nullable=True
		, comment="Commission amount for the aggregator.")
    comm_ours = Column(Numeric, nullable=True
		, comment="Commission amount for us.")
    comm_other = Column(Numeric, nullable=True
		, comment="Payments to others associated with the transaction.")
    comm_net_pct = Column(Float, nullable=True
		, comment="Net commission percentage.")
    tax = Column(Numeric, nullable=True
		, comment="Tax amount associated with the transaction.")
    excise_duty = Column(Numeric, nullable=True
		, comment="Excise duty amount.")
    vat = Column(Numeric, nullable=True
		, comment="Value-added tax (VAT) amount.")
    transmit_amount = Column(Numeric, nullable=True
		, comment="Transmit amount for the transaction.")
    comm_narration = Column(Text, nullable=True
		, comment="Narration describing how the commission was calculated.")
    trans_currency = Column(String, nullable=True
		, comment="Currency code for the transaction.")
    trans_convert_currency = Column(String, nullable=True
		, comment="Currency for currency conversion, if applicable.")
    trans_currency_exchange_rate = Column(Numeric, nullable=True
		, comment="Exchange rate for currency conversion.")
    trans_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp of the transaction date.")
    customer_segment_id_fk = Column(Integer, ForeignKey('customer_segment.id'), nullable=True
		, comment="Reference to the customer segment.")
    agent_tier_level_id_fk = Column(Integer, ForeignKey('agent_tier.id'), nullable=True
		, comment="Reference to the agent tier level.")
    special_promotions_id_fk = Column(Integer, ForeignKey('promotion.id'), nullable=True
		, comment="Reference to special promotions associated with the transaction.")
    risk_profile_id_fk = Column(Integer, ForeignKey('risk_profile.id'), nullable=True
		, comment="Risk associated with financial transactions")
    fraud_marker = Column(Boolean, default=False, nullable=True
		, comment="Indicates whether the transaction is marked as fraudulent.")
    fraud_eval_outcome = Column(String, nullable=True
		, comment="Outcome of fraud evaluation (e.g., Fraud, Not Fraud, Unknown).")
    fraud_risk_score = Column(Float, nullable=True
		, comment="Fraud risk score (values 1-1000).")
    fraud_prediction_explanations = Column(Text, nullable=True
		, comment="List of explanations for how each event variable impacted the fraud prediction score.")
    fraud_rule_evaluations = Column(Text, nullable=True
		, comment="Evaluations of the rules that were included in the detector version.")
    fraud_event_num = Column(String, nullable=True
		, comment="Event number returned by AWS Fraud Detector.")
    trans_narration = Column(Text, nullable=True
		, comment="Narration containing details about the transaction.")
    agent = relationship(Agent, backref='transs_agent', primaryjoin='Trans.agent_id_fk == Agent.id')
    agent_tier_level = relationship(AgentTier, backref='transs_agent_tier_level', primaryjoin='Trans.agent_tier_level_id_fk == AgentTier.id')
    bene_bank = relationship(Bank, backref='transs_bene_bank', primaryjoin='Trans.bene_bank_id_fk == Bank.id')
    biller = relationship(Biller, backref='transs_biller', primaryjoin='Trans.biller_id_fk == Biller.id')
    biller_offering = relationship(BillerOffering, backref='transs_biller_offering', primaryjoin='Trans.biller_offering_id_fk == BillerOffering.id')
    coupon = relationship(Coupon, backref='transs_coupon', primaryjoin='Trans.coupon_id_fk == Coupon.id')
    currency = relationship(Currency, backref='transs_currency', primaryjoin='Trans.currency_id_fk == Currency.id')
    customer_segment = relationship(CustomerSegment, backref='transs_customer_segment', primaryjoin='Trans.customer_segment_id_fk == CustomerSegment.id')
    origin_bank = relationship(Bank, backref='transs_origin_bank', primaryjoin='Trans.origin_bank_id_fk == Bank.id')
    payment_card = relationship(PaymentCard, backref='transs_payment_card', primaryjoin='Trans.payment_card_id_fk == PaymentCard.id')
    pos = relationship(Pos, backref='transs_pos', primaryjoin='Trans.pos_id_fk == Pos.id')
    risk_profile = relationship(RiskProfile, backref='transs_risk_profile', primaryjoin='Trans.risk_profile_id_fk == RiskProfile.id')
    special_promotions = relationship(Promotion, backref='transs_special_promotions', primaryjoin='Trans.special_promotions_id_fk == Promotion.id')
    trans_route = relationship(TransRoutingThresholds, backref='transs_trans_route', primaryjoin='Trans.trans_route_id_fk == TransRoutingThresholds.id')
    wallet = relationship(Wallet, backref='transs_wallet', primaryjoin='Trans.wallet_id_fk == Wallet.id')

    def __repr__(self):
       return self.customer_name

 ### 


class AgentDocLink(Model):
    __tablename__ = "agent_doc_link"
    # __table_args__ = ( ) # tuple
    __doc__ = "An Agents Documents"
    # class_permission_name = "view"
    agent_id_fk = Column(Integer, ForeignKey('agent.id'), primary_key=True
		, comment="Foreign key reference to the agent whose document is linked.")
    doc_id_fk = Column(Integer, ForeignKey('doc.id'), primary_key=True
		, comment="Foreign key reference to the document being linked.")
    verification_status = Column(Enum(t_verification_status), nullable=False)
    submit_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document is submitted, with a default value of the current timestamp.")
    notes = Column(Text, nullable=True
		, comment="Additional notes or comments related to the document link.")
    agent = relationship(Agent, backref='agent_doc_links_agent', primaryjoin='AgentDocLink.agent_id_fk == Agent.id')
    doc = relationship(Doc, backref='agent_doc_links_doc', primaryjoin='AgentDocLink.doc_id_fk == Doc.id')

    def __repr__(self):
       return self.agent_id_fk

 ### 


class PersonDocLink(Model):
    __tablename__ = "person_doc_link"
    # __table_args__ = ( ) # tuple
    __doc__ = "A Persons Documents"
    # class_permission_name = "view"
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True
		, comment="Foreign key reference to the person whose document is linked.")
    doc_id_fk = Column(Integer, ForeignKey('doc.id'), primary_key=True
		, comment="Foreign key reference to the document being linked.")
    verification_status = Column(Enum(t_verification_status), nullable=False)
    submit_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="Timestamp when the document is submitted, with a default value of the current timestamp.")
    doc = relationship(Doc, backref='person_doc_links_doc', primaryjoin='PersonDocLink.doc_id_fk == Doc.id')
    person = relationship(Person, backref='person_doc_links_person', primaryjoin='PersonDocLink.person_id_fk == Person.id')

    def __repr__(self):
       return self.person_id_fk

 ### 

