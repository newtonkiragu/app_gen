
# coding: utf-8
# AUTOGENERATED BY appgen 
# Copyright (C) Nyimbi Odero, 2024 


 
import datetime, enum
from flask_appbuilder import Model
from sqlalchemy import Column, Integer, Boolean, String, Float, Enum, ForeignKey, Date, DateTime, Text
from sqlalchemy.orm import relationship, backref


import os
import sys
import enum
import inspect
import datetime
import shutils
from datetime import timedelta, datetime, date

from sqlalchemy.orm import relationship, query, defer, deferred, column_property, mapper
from sqlalchemy.schema import FetchedValue
from sqlalchemy.ext.hybrid import hybrid_property, hybrid_method
from sqlalchemy import (Column, Integer, String, ForeignKey,
    Sequence, Float, Text, BigInteger, Date, SmallInteger, BigInteger, 
    DateTime, Time, Boolean, Index, CheckConstraint, Interval, # MatchType  
    UniqueConstraint, ForeignKeyConstraint, Numeric, LargeBinary , Table, func, Enum,
    text)

# IMPORT Postgresql Specific Types
from sqlalchemy.dialects.postgresql import *
from sqlalchemy.dialects.postgresql import (
    ARRAY, BIGINT, BIT, BOOLEAN, BYTEA, CHAR, CIDR, DATE,
    DOUBLE_PRECISION, ENUM, FLOAT, HSTORE, INET, INTEGER,
    INTERVAL, JSON, JSONB, MACADDR, NUMERIC, OID, REAL, SMALLINT, TEXT,
    TIME, TIMESTAMP, UUID, VARCHAR, INT4RANGE, INT8RANGE, NUMRANGE,
    DATERANGE, TSRANGE, TSTZRANGE, TSVECTOR, aggregate_order_by )

from flask_appbuilder import Model
from flask_appbuilder.models.mixins import AuditMixin, FileColumn, ImageColumn, UserExtensionMixin
from flask_appbuilder.security.sqla.models import User
from flask_appbuilder.filemanager import ImageManager

from flask_appbuilder.models.decorators import renders
from sqlalchemy_utils import aggregated, force_auto_coercion, observes
from sqlalchemy_utils.types import TSVectorType   #Searchability look at DocMixin
from sqlalchemy.ext.associationproxy import association_proxy

from flask_appbuilder.security.sqla.models import User
from geoalchemy2 import Geometry
from flask_mail import Mail, Message  # Requires Flask-Mail
# To create GraphSQL API
# import graphene
# from graphene_sqlalchemy import SQLAlchemyObjectType

# Versioning Mixin
# from sqlalchemy_continuum import make_versioned
#Add __versioned__ = {}


# from sqlalchemy_searchable import make_searchable
# from flask_graphql import GraphQLView

# ActiveRecord Model Features
# from sqlalchemy_mixins import AllFeaturesMixin, ActiveRecordMixin


# from .model_mixins import *

# Here is how to extend the User model
#class UserExtended(Model, UserExtensionMixin):
#    contact_group_id = Column(Integer, ForeignKey('contact_group.id'), nullable=True)
#    contact_group = relationship('ContactGroup')

# UTILITY CLASSES
# import arrow,


# Initialize sqlalchemy_utils
#force_auto_coercion()
# Keep versions of all data
# make_versioned()
# make_searchable()



# Domains defined in the database

class topoelement(Integer):  # BaseType should be replaced with the actual base type
    not_null = True
    # Constraint: dimensions
    check = 'array_upper(VALUE, 2) IS NULL AND array_upper(VALUE, 1) = 2'
    # Constraint: lower_dimension
    check = 'array_lower(VALUE, 1) = 1'
    # Constraint: type_range
    check = '(VALUE)[2] > 0'

class topoelementarray(Integer):  # BaseType should be replaced with the actual base type
    not_null = True
    # Constraint: type_range
    check = 'array_upper(VALUE, 2) = 2 AND array_upper(VALUE, 3) IS NULL'

 
# Enums defined in the database

class t_account_category(enum.Enum):
   OPERATING = 'Operating'
   INVESTING = 'Investing'
   FINANCING = 'Financing'

class t_account_classification(enum.Enum):
   CURRENT = 'Current'
   NON_CURRENT = 'Non_Current'
   NOT_APPLICABLE = 'Not_Applicable'

class t_account_normal_side(enum.Enum):
   DEBIT = 'Debit'
   CREDIT = 'Credit'

class t_account_transaction_type(enum.Enum):
   DEBIT = 'Debit'
   CREDIT = 'Credit'
   ADJUSTMENT = 'Adjustment'
   TRANSFER = 'Transfer'
   INTEREST_CHARGE = 'Interest_Charge'
   INTEREST_REVERSAL = 'Interest_Reversal'
   FEE = 'Fee'
   PENALTY = 'Penalty'
   REFUND = 'Refund'
   SETTLEMENT = 'Settlement'

class t_account_type(enum.Enum):
   ASSET = 'Asset'
   CURRENT_ASSET = 'Current_Asset'
   CONTRA_ASSET = 'Contra_Asset'
   FIXED_ASSET = 'Fixed_Asset'
   OTHER_ASSET = 'Other_Asset'
   NON_CURRENT_ASSET = 'Non_Current_Asset'
   LIABILITY = 'Liability'
   CURRENT_LIABILITY = 'Current_Liability'
   NON_CURRENT_LIABILITY = 'Non_Current_Liability'
   OTHER_LIABILITY = 'Other_Liability'
   EQUITY = 'Equity'
   INCOME = 'Income'
   EXPENSE = 'Expense'
   OTHER = 'Other'

class t_account_usage(enum.Enum):
   TRANSACTIONAL = 'transactional'
   REPORTING = 'reporting'
   BOTH = 'both'

class t_admin_level(enum.Enum):
   CONTINENT = 'Continent'
   REGION = 'Region'
   SUPRANATIONAL = 'Supranational'
   COUNTRY = 'Country'
   FEDERAL = 'Federal'
   STATE = 'State'
   LGA = 'LGA'
   WARD = 'Ward'
   PROVINCE = 'Province'
   COUNTY = 'County'
   DISTRICT = 'District'
   LOCATION = 'Location'
   SUB_LOCATION = 'Sub_location'
   CANTON = 'Canton'
   MUNICIPALITY = 'Municipality'
   TOWN = 'Town'
   VILLAGE = 'Village'
   NEIGHBORHOOD = 'Neighborhood'
   BOROUGH = 'Borough'
   SUBURB = 'Suburb'
   ZONE = 'Zone'

class t_amortization_method(enum.Enum):
   STRAIGHT_LINE = 'Straight_Line'
   DECLINING_BALANCE = 'Declining_Balance'
   RULE_OF_78S = 'Rule_of_78s'
   ANNUITY = 'Annuity'
   BULLET = 'Bullet'
   BALLOON = 'Balloon'
   VARIABLE_AMORTIZATION = 'Variable_Amortization'
   CUSTOM = 'Custom'
   INTEREST_ONLY = 'Interest_Only'
   FIXED_PRINCIPAL = 'Fixed_Principal'
   SEASONAL = 'Seasonal'
   INCREASING_PAYMENT = 'Increasing_Payment'
   NEGATIVELY_AMORTIZING = 'Negatively_Amortizing'

class t_animal_type(enum.Enum):
   CATTLE = 'Cattle'
   SHEEP = 'Sheep'
   GOAT = 'Goat'
   PIG = 'Pig'
   HORSE = 'Horse'
   DONKEY = 'Donkey'
   MULE = 'Mule'
   BUFFALO = 'Buffalo'
   CAMEL = 'Camel'
   CHICKEN = 'Chicken'
   DUCK = 'Duck'
   GOOSE = 'Goose'
   TURKEY = 'Turkey'
   RABBIT = 'Rabbit'
   FISH = 'Fish'
   OSTRICH = 'Ostrich'
   GUINEA_FOWL = 'Guinea_fowl'
   SNAIL = 'Snail'
   QUAIL = 'Quail'
   BEE = 'Bee'
   ALPACA = 'Alpaca'
   LLAMA = 'Llama'
   OTHER = 'Other'

class t_closure_type(enum.Enum):
   MONTHLY = 'Monthly'
   QUARTERLY = 'Quarterly'
   YEARLY = 'Yearly'

class t_date_macro(enum.Enum):
   ALL = 'All'
   TODAY = 'Today'
   THISWEEK = 'ThisWeek'
   THISWEEKTODATE = 'ThisWeekToDate'
   THISMONTH = 'ThisMonth'
   THISMONTHTODATE = 'ThisMonthToDate'
   THISCALENDARQUARTER = 'ThisCalendarQuarter'
   THISCALENDARQUARTERTODATE = 'ThisCalendarQuarterToDate'
   THISFISCALQUARTER = 'ThisFiscalQuarter'
   THISFISCALQUARTERTODATE = 'ThisFiscalQuarterToDate'
   THISCALENDARYEAR = 'ThisCalendarYear'
   THISCALENDARYEARTODATE = 'ThisCalendarYearToDate'
   THISFISCALYEAR = 'ThisFiscalYear'
   THISFISCALYEARTODATE = 'ThisFiscalYearToDate'
   YESTERDAY = 'Yesterday'
   LASTWEEK = 'LastWeek'
   LASTWEEKTODATE = 'LastWeekToDate'
   LASTMONTH = 'LastMonth'
   LASTMONTHTODATE = 'LastMonthToDate'
   LASTCALENDARQUARTER = 'LastCalendarQuarter'
   LASTCALENDARQUARTERTODATE = 'LastCalendarQuarterToDate'
   LASTFISCALQUARTER = 'LastFiscalQuarter'
   LASTFISCALQUARTERTODATE = 'LastFiscalQuarterToDate'
   LASTCALENDARYEAR = 'LastCalendarYear'
   LASTCALENDARYEARTODATE = 'LastCalendarYearToDate'
   LASTFISCALYEAR = 'LastFiscalYear'
   LASTFISCALYEARTODATE = 'LastFiscalYearToDate'
   NEXTWEEK = 'NextWeek'
   NEXTFOURWEEKS = 'NextFourWeeks'
   NEXTMONTH = 'NextMonth'
   NEXTCALENDARQUARTER = 'NextCalendarQuarter'
   NEXTCALENDARYEAR = 'NextCalendarYear'
   NEXTFISCALQUARTER = 'NextFiscalQuarter'
   NEXTFISCALYEAR = 'NextFiscalYear'

class t_doc_status(enum.Enum):
   NOT_STARTED = 'Not_Started'
   DRAFT = 'Draft'
   IN_PROGRESS = 'In_Progress'
   AWAITING_REVIEW = 'Awaiting_Review'
   UNDER_REVIEW = 'Under_Review'
   REVIEW_COMPLETED = 'Review_Completed'
   REVISIONS_NEEDED = 'Revisions_Needed'
   SUBMITTED = 'Submitted'
   APPROVED = 'Approved'
   PARTIALLY_APPROVED = 'Partially_Approved'
   REJECTED = 'Rejected'
   CANCELLED = 'Cancelled'
   ARCHIVED = 'Archived'
   PUBLISHED = 'Published'
   SUSPENDED = 'Suspended'
   VOIDED = 'Voided'
   COMPLETED = 'Completed'
   EXPIRED = 'Expired'
   RENEWED = 'Renewed'
   LOCKED = 'Locked'
   MERGED = 'Merged'
   ROLLBACK = 'Rollback'
   CONFLICT = 'Conflict'
   QUEUED_FOR_REVIEW = 'Queued_for_Review'
   QUEUED_FOR_PUBLISH = 'Queued_for_Publish'
   DEPRECATED = 'Deprecated'
   UNPUBLISHED = 'Unpublished'
   IN_TRANSLATION = 'In_Translation'
   VALIDATION_FAILED = 'Validation_Failed'
   VALIDATION_PASSED = 'Validation_Passed'
   DIGITIZED = 'Digitized'
   IN_SIGNATURE_PROCESS = 'In_Signature_Process'
   SIGNATURE_COMPLETED = 'Signature_Completed'
   SIGNATURE_FAILED = 'Signature_Failed'
   IN_AUDIT = 'In_Audit'
   AUDIT_COMPLETED = 'Audit_Completed'
   IN_TRANSIT = 'In_Transit'
   RECEIVED = 'Received'
   SENT = 'Sent'

class t_doc_verification_status(enum.Enum):
   PENDING_APPROVAL = 'pending_approval'
   KYC_SUBMITTED = 'kyc_submitted'
   KYC_APPROVED = 'kyc_approved'
   KYC_REJECTED = 'kyc_rejected'
   ESCALATED = 'escalated'
   CONTRACTED = 'contracted'
   ACTIVE = 'active'
   SUSPENDED = 'suspended'
   INACTIVE = 'inactive'
   CONTRACT_TERMINATED = 'contract_terminated'
   DOCS_EXPIRED = 'docs_expired'
   UNDER_REVIEW = 'under_review'
   LOCKED = 'locked'
   AWAITING_RENEWAL = 'awaiting_renewal'
   RENEWAL_REJECTED = 'renewal_rejected'
   VERIFICATION_FAILED = 'verification_failed'

class t_engagement_type(enum.Enum):
   VIEW = 'View'
   LIKE = 'Like'
   STAR = 'Star'
   SHARE = 'Share'
   COMMENT = 'Comment'
   DISLIKE = 'Dislike'
   SAVE = 'Save'
   BOOKMARK = 'Bookmark'
   SUBSCRIBE = 'Subscribe'
   REPORT = 'Report'
   CLICKTHROUGH = 'ClickThrough'
   DOWNLOAD = 'Download'
   HIGHLIGHT = 'Highlight'
   COMPLETE = 'Complete'
   PAUSE = 'Pause'
   REPLAY = 'Replay'
   QUESTION = 'Question'

class t_gender(enum.Enum):
   MALE = 'Male'
   FEMALE = 'Female'
   NON_BINARY = 'Non_Binary'
   PREFER_NOT_TO_SAY = 'Prefer_Not_to_Say'
   OTHER = 'Other'

class t_geofence_trigger(enum.Enum):
   ENTER = 'Enter'
   EXIT = 'Exit'
   APPROACH = 'Approach'
   INSIDE = 'Inside'
   OUTSIDE = 'Outside'

class t_guarantor_type(enum.Enum):
   NONE = 'NONE'
   INDIVIDUAL = 'INDIVIDUAL'
   CORPORATE = 'CORPORATE'
   ASSET_BACKED = 'ASSET_BACKED'
   JOINT_AND_SEVERAL = 'JOINT_AND_SEVERAL'
   SPONSOR = 'SPONSOR'
   GOVERNMENT = 'GOVERNMENT'
   INSURANCE = 'INSURANCE'
   COSIGNER = 'COSIGNER'
   COLLATERAL = 'COLLATERAL'
   UNSECURED = 'UNSECURED'

class t_improvement_type(enum.Enum):
   PLOWING = 'Plowing'
   WEEDING = 'Weeding'
   FENCING = 'Fencing'
   IRRIGATION = 'Irrigation'
   DRAINAGE = 'Drainage'
   TERRACING = 'Terracing'
   EROSION_CONTROL = 'Erosion_Control'
   PAVING = 'Paving'
   SHED_CONSTRUCTION = 'Shed_Construction'
   REFORESTATION = 'Reforestation'
   LAND_LEVELING = 'Land_Leveling'
   POLLUTION_CONTROL = 'Pollution_Control'
   SOLAR_INSTALLATION = 'Solar_Installation'
   WIND_TURBINES = 'Wind_Turbines'
   WATER_STORAGE = 'Water_Storage'
   COMPOSTING_SYSTEMS = 'Composting_Systems'
   ANIMAL_HOUSING = 'Animal_Housing'
   PEST_CONTROL = 'Pest_Control'
   WILDLIFE_CONSERVATION = 'Wildlife_Conservation'
   EQUIPMENT_STORAGE = 'Equipment_Storage'
   GREENHOUSE = 'Greenhouse'

class t_interest_method(enum.Enum):
   SIMPLE_INTEREST = 'Simple_Interest'
   COMPOUND_INTEREST = 'Compound_Interest'
   FLAT_RATE = 'Flat_Rate'
   FIXED_INTEREST_OVER_TERM = 'Fixed_Interest_Over_Term'
   DECLINING_BALANCE = 'Declining_Balance'
   ANNUITY = 'Annuity'
   RULE_OF_78S = 'Rule_of_78s'
   CUSTOM = 'Custom'

class t_interval(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'

class t_land_transfer_type(enum.Enum):
   SALE = 'Sale'
   INHERITANCE = 'Inheritance'
   GIFT = 'Gift'
   LEASE = 'Lease'
   DONATION = 'Donation'
   SWAP = 'Swap'
   EMINENTDOMAIN = 'EminentDomain'
   PARTITION = 'Partition'
   MERGER = 'Merger'
   FORECLOSURE = 'Foreclosure'
   JUDICIAL_ORDER = 'Judicial_Order'
   LAND_CONTRACT = 'Land_Contract'
   TRUST_TRANSFER = 'Trust_Transfer'
   JOINT_OWNERSHIP = 'Joint_Ownership'

class t_land_use(enum.Enum):
   CROPPING = 'Cropping'
   GRAZING = 'Grazing'
   FALLOW = 'Fallow'
   FORESTED = 'Forested'
   WETLAND = 'Wetland'
   RESIDENTIAL = 'Residential'
   COMMERCIAL = 'Commercial'
   INDUSTRIAL = 'Industrial'
   RECREATIONAL = 'Recreational'
   CONSERVATION = 'Conservation'
   MINING = 'Mining'
   ORCHARD = 'Orchard'
   VINEYARD = 'Vineyard'
   FISHERY = 'Fishery'
   POULTRY = 'Poultry'
   DAIRY = 'Dairy'
   ORGANIC = 'Organic'
   RENEWABLE_ENERGY = 'Renewable_Energy'
   LANDFILL = 'Landfill'
   MARSHLAND = 'Marshland'
   RESEARCH = 'Research'
   MILITARY = 'Military'
   EDUCATIONAL = 'Educational'
   RELIGIOUS = 'Religious'
   TRANSPORTATION = 'Transportation'
   UTILITY = 'Utility'
   MIXED_USE = 'Mixed_Use'
   AQUACULTURE = 'Aquaculture'
   ARBORETUM = 'Arboretum'
   BROWNFIELD = 'Brownfield'
   TUNDRA = 'Tundra'
   SAVANNAH = 'Savannah'
   GRASSLAND = 'Grassland'

class t_language_proficiency_level(enum.Enum):
   BASIC = 'BASIC'
   INTERMEDIATE = 'INTERMEDIATE'
   ADVANCED = 'ADVANCED'
   FLUENT = 'FLUENT'
   A1 = 'A1'
   A2 = 'A2'
   B1 = 'B1'
   B2 = 'B2'
   C1 = 'C1'
   C2 = 'C2'

class t_lesson_difficulty_feedback(enum.Enum):
   EASY = 'Easy'
   JUST_RIGHT = 'Just_Right'
   DIFFICULT = 'Difficult'
   EXTREMELY_DIFFICULT = 'Extremely_Difficult'

class t_lesson_level(enum.Enum):
   BASIC = 'Basic'
   INTERMEDIATE = 'Intermediate'
   ADVANCED = 'Advanced'
   EXPERT = 'Expert'

class t_loan_sub_status(enum.Enum):
   ACTIVE_IN_GOOD_STANDING = 'Active_In_Good_Standing'
   ACTIVE_IN_ARREARS = 'Active_In_Arrears'
   PENDING_FIRST_DISBURSEMENT = 'Pending_First_Disbursement'
   PARTIALLY_DISBURSED = 'Partially_Disbursed'
   FORECLOSED = 'Foreclosed'
   RESTRUCTURED = 'Restructured'
   WRITTEN_OFF = 'Written_Off'
   SETTLED = 'Settled'
   CLOSED = 'Closed'
   DEFAULTED = 'Defaulted'
   ACTIVE_WITH_OVERDUE_CHARGES = 'Active_With_Overdue_Charges'
   SUSPENDED = 'Suspended'
   PREPAYMENT = 'Prepayment'
   UNDER_REVIEW = 'Under_Review'

class t_org_type(enum.Enum):
   INDIVIDUAL = 'Individual'
   BUSINESS_NAME = 'Business_Name'
   SOLE_PROPRIETORSHIP = 'Sole_Proprietorship'
   PARTNERSHIP = 'Partnership'
   PRIVATE_LIMITED_COMPANY = 'Private_Limited_Company'
   PUBLIC_LIMITED_COMPANY = 'Public_Limited_Company'
   PUBLIC_COMPANY_LIMITED_BY_GUARANTEE = 'Public_Company_Limited_by_Guarantee'
   PRIVATE_UNLIMITED_COMPANY = 'Private_Unlimited_Company'
   PUBLIC_UNLIMITED_COMPANY = 'Public_Unlimited_Company'
   COOPERATIVE = 'Cooperative'
   NONPROFIT = 'Nonprofit'
   TRUST = 'Trust'
   GOVERNMENT = 'Government'
   FRANCHISE = 'Franchise'
   SUBSIDIARY = 'Subsidiary'
   HOLDING_COMPANY = 'Holding_Company'
   JOINT_VENTURE = 'Joint_Venture'
   FREELANCER = 'Freelancer'
   AGENCY = 'Agency'
   WOMENS_GROUP = 'Womens_Group'
   MEITI_ALLAH = 'Meiti_Allah'
   INFORMAL_GROUP = 'Informal_Group'
   CHAMA = 'Chama'
   OTHER_GROUPINGS = 'Other_Groupings'
   FAMILY = 'Family'
   CLAN = 'Clan'
   TRIBE = 'Tribe'
   ASSOCIATION = 'Association'
   CLUB = 'Club'
   CONSORTIUM = 'Consortium'
   SYNDICATE = 'Syndicate'
   COLLECTIVE = 'Collective'
   NETWORK = 'Network'
   FOUNDATION = 'Foundation'
   FEDERATION = 'Federation'
   CHAMBER_OF_COMMERCE = 'Chamber_of_Commerce'
   GUILD = 'Guild'
   UNION = 'Union'
   RELIGIOUS_ORGANIZATION = 'Religious_Organization'
   POLITICAL_ORGANIZATION = 'Political_Organization'
   ALUMNI_ASSOCIATION = 'Alumni_Association'
   AFFILIATE = 'Affiliate'
   DIVISION = 'Division'
   COUNCIL = 'Council'
   TASK_FORCE = 'Task_Force'
   SOCIAL_CLUB = 'Social_Club'
   CHARITY = 'Charity'
   THINK_TANK = 'Think_Tank'

class t_payment_method(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'Withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'

class t_payment_terms(enum.Enum):
   NET_30 = 'net_30'
   PCT2_10_NET_30 = 'pct2_10_net_30'
   NET_45 = 'net_45'
   NET_60 = 'net_60'
   NET_90 = 'net_90'
   COD = 'COD'
   CIA = 'CIA'
   EOM = 'EOM'
   EOM_30 = 'EOM_30'
   DUE_ON_RECEIPT = 'Due_on_Receipt'

class t_person_role(enum.Enum):
   VET = 'Vet'
   AGRONOMIST = 'Agronomist'
   HERDER = 'Herder'
   OWNER = 'Owner'
   STORE_KEEPER = 'Store_keeper'
   FARMER = 'Farmer'
   SPECIALIST = 'Specialist'
   VENDOR = 'Vendor'
   BUYER = 'Buyer'
   TRADER = 'Trader'
   STAFF = 'Staff'
   LAB = 'Lab'
   LEARNER = 'Learner'
   MEMBER = 'Member'

class t_pipeline_stages(enum.Enum):
   LEAD_GENERATION = 'Lead_Generation'
   QUALIFICATION = 'Qualification'
   NEEDS_ANALYSIS = 'Needs_Analysis'
   PROPOSAL = 'Proposal'
   NEGOTIATION = 'Negotiation'
   CLOSURE = 'Closure'
   EXECUTING = 'Executing'
   POST_SALE = 'Post_Sale'
   UPSELLING = 'Upselling'
   RENEWAL = 'Renewal'
   REFERRAL = 'Referral'
   LOST_DEAL_ANALYSIS = 'Lost_Deal_Analysis'
   RE_ENGAGEMENT = 'Re_Engagement'

class t_product_return_action(enum.Enum):
   REFUNDED = 'refunded'
   CREDIT_ISSUED = 'Credit_Issued'
   REPLACEMENT_SENT = 'Replacement_sent'

class t_product_return_reason(enum.Enum):
   DEAD_ON_ARRIVAL = 'Dead_on_arrival'
   RECEIVED_WRONG_ITEM = 'Received_wrong_item'
   ORDER_ERROR = 'Order_error'
   FAULTY_ITEM = 'Faulty_item'
   OTHER = 'Other'

class t_recommendation_category(enum.Enum):
   SOIL_HEALTH_MANAGEMENT = 'Soil_Health_Management'
   CROP_SELECTION_AND_ROTATION = 'Crop_Selection_and_Rotation'
   INTEGRATED_PEST_MANAGEMENT = 'Integrated_Pest_Management'
   WATER_MANAGEMENT = 'Water_Management'
   PLANTING_STRATEGIES = 'Planting_Strategies'
   WEED_MANAGEMENT = 'Weed_Management'
   HARVEST_AND_POST_HARVEST_MANAGEMENT = 'Harvest_and_Post_Harvest_Management'
   CLIMATE_AND_WEATHER = 'Climate_and_Weather'
   SUSTAINABLE_FARMING_PRACTICES = 'Sustainable_Farming_Practices'
   FARM_TECHNOLOGY_AND_MECHANIZATION = 'Farm_Technology_and_Mechanization'
   MARKETING_AND_AGRIBUSINESS = 'Marketing_and_Agribusiness'
   RESEARCH_AND_DEVELOPMENT = 'Research_and_Development'

class t_relationship_type(enum.Enum):
   HUSBAND = 'Husband'
   WIFE = 'Wife'
   SISTER = 'Sister'
   BROTHER = 'Brother'
   SIBLING = 'Sibling'
   SON = 'Son'
   DAUGHTER = 'Daughter'
   COUSIN = 'Cousin'
   IN_LAW = 'In_law'
   RELATIVE = 'Relative'
   FRIEND = 'Friend'
   HOUSEHOLD_MEMBER = 'Household_member'
   PARTNER = 'Partner'
   COWORKER = 'Coworker'
   SUPERIOR = 'Superior'
   SUBORDINATE = 'Subordinate'
   INFLUENCER = 'Influencer'
   OTHER = 'Other'

class t_remind_by_enum(enum.Enum):
   EMAIL = 'EMAIL'
   SMS = 'SMS'
   NOTIFICATION = 'NOTIFICATION'
   PHONE_CALL = 'PHONE_CALL'
   PUSH_NOTIFICATION = 'PUSH_NOTIFICATION'
   SLACK_MESSAGE = 'SLACK_MESSAGE'
   TELEGRAM_MESSAGE = 'TELEGRAM_MESSAGE'
   WHATSAPP_MESSAGE = 'WHATSAPP_MESSAGE'
   CALENDAR_EVENT = 'CALENDAR_EVENT'
   DESKTOP_ALERT = 'DESKTOP_ALERT'
   SNAIL_MAIL = 'SNAIL_MAIL'
   SOCIAL_MEDIA_DM = 'SOCIAL_MEDIA_DM'
   RSS_FEED = 'RSS_FEED'
   DISCORD_MESSAGE = 'DISCORD_MESSAGE'

class t_severity_level(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'

class t_share_platform(enum.Enum):
   EMAIL = 'Email'
   FACEBOOK = 'Facebook'
   TWITTER = 'Twitter'
   WHATSAPP = 'WhatsApp'
   LINKEDIN = 'LinkedIn'
   INSTAGRAM = 'Instagram'
   PINTEREST = 'Pinterest'
   TELEGRAM = 'Telegram'
   SNAPCHAT = 'Snapchat'
   TIKTOK = 'TikTok'
   REDDIT = 'Reddit'
   MESSENGER = 'Messenger'
   SMS = 'SMS'
   QRCODE = 'QRCode'
   WECHAT = 'WeChat'
   VIBER = 'Viber'
   SIGNAL = 'Signal'
   SLACK = 'Slack'
   COPYLINK = 'CopyLink'

class t_soil_texture(enum.Enum):
   SANDY = 'Sandy'
   LOAMY = 'Loamy'
   CLAYEY = 'Clayey'
   SILTY = 'Silty'
   PEATY = 'Peaty'
   CHALKY = 'Chalky'
   ROCKY = 'Rocky'
   SALINE = 'Saline'
   ALLUVIAL = 'Alluvial'
   CALCAREOUS = 'Calcareous'

class t_transaction_source(enum.Enum):
   MANUAL_ENTRY = 'Manual_Entry'
   API = 'API'
   IMPORTED = 'Imported'
   AUTOMATED_PROCESS = 'Automated_Process'

class t_transaction_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'

class t_water_source(enum.Enum):
   WELL = 'Well'
   RIVER = 'River'
   LAKE = 'Lake'
   RAINWATER = 'Rainwater'
   SPRING = 'Spring'
   RESERVOIR = 'Reservoir'
   CANAL = 'Canal'
   OCEAN = 'Ocean'
   POND = 'Pond'
   GLACIER = 'Glacier'
   DESALINATION = 'Desalination'
   RECYCLED = 'Recycled'
   MUNICIPAL = 'Municipal'
   GROUNDWATER = 'Groundwater'
   ARTESIAN = 'Artesian'
   IMPORTED = 'Imported'
   BOREHOLE = 'Borehole'
   TAP = 'Tap'
   CREEK = 'Creek'
   STREAM = 'Stream'
   DAM = 'Dam'

class t_waypoint_audit_action(enum.Enum):
   CREATED = 'CREATED'
   UPDATED = 'UPDATED'
   DELETED = 'DELETED'
   MOVED = 'MOVED'



class Optimal_soil_texture(enum.Enum):
   SANDY = 'Sandy'
   LOAMY = 'Loamy'
   CLAYEY = 'Clayey'
   SILTY = 'Silty'
   PEATY = 'Peaty'
   CHALKY = 'Chalky'
   ROCKY = 'Rocky'
   SALINE = 'Saline'
   ALLUVIAL = 'Alluvial'
   CALCAREOUS = 'Calcareous'



class Drought_tolerance(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'



class Payment_method(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'Withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'



class Module_level(enum.Enum):
   BASIC = 'Basic'
   INTERMEDIATE = 'Intermediate'
   ADVANCED = 'Advanced'
   EXPERT = 'Expert'



class Person_role(enum.Enum):
   VET = 'Vet'
   AGRONOMIST = 'Agronomist'
   HERDER = 'Herder'
   OWNER = 'Owner'
   STORE_KEEPER = 'Store_keeper'
   FARMER = 'Farmer'
   SPECIALIST = 'Specialist'
   VENDOR = 'Vendor'
   BUYER = 'Buyer'
   TRADER = 'Trader'
   STAFF = 'Staff'
   LAB = 'Lab'
   LEARNER = 'Learner'
   MEMBER = 'Member'



class Join_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Severity(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'









class Salinity_tolerance(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'



class Herbicide_tolerance(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'



class Dominant_species(enum.Enum):
   CATTLE = 'Cattle'
   SHEEP = 'Sheep'
   GOAT = 'Goat'
   PIG = 'Pig'
   HORSE = 'Horse'
   DONKEY = 'Donkey'
   MULE = 'Mule'
   BUFFALO = 'Buffalo'
   CAMEL = 'Camel'
   CHICKEN = 'Chicken'
   DUCK = 'Duck'
   GOOSE = 'Goose'
   TURKEY = 'Turkey'
   RABBIT = 'Rabbit'
   FISH = 'Fish'
   OSTRICH = 'Ostrich'
   GUINEA_FOWL = 'Guinea_fowl'
   SNAIL = 'Snail'
   QUAIL = 'Quail'
   BEE = 'Bee'
   ALPACA = 'Alpaca'
   LLAMA = 'Llama'
   OTHER = 'Other'



class Lesson_level(enum.Enum):
   BASIC = 'Basic'
   INTERMEDIATE = 'Intermediate'
   ADVANCED = 'Advanced'
   EXPERT = 'Expert'



class Rule_type(enum.Enum):
   STRAIGHT_LINE = 'Straight_Line'
   DECLINING_BALANCE = 'Declining_Balance'
   RULE_OF_78S = 'Rule_of_78s'
   ANNUITY = 'Annuity'
   BULLET = 'Bullet'
   BALLOON = 'Balloon'
   VARIABLE_AMORTIZATION = 'Variable_Amortization'
   CUSTOM = 'Custom'
   INTEREST_ONLY = 'Interest_Only'
   FIXED_PRINCIPAL = 'Fixed_Principal'
   SEASONAL = 'Seasonal'
   INCREASING_PAYMENT = 'Increasing_Payment'
   NEGATIVELY_AMORTIZING = 'Negatively_Amortizing'



class Listening_proficiency_level(enum.Enum):
   BASIC = 'BASIC'
   INTERMEDIATE = 'INTERMEDIATE'
   ADVANCED = 'ADVANCED'
   FLUENT = 'FLUENT'
   A1 = 'A1'
   A2 = 'A2'
   B1 = 'B1'
   B2 = 'B2'
   C1 = 'C1'
   C2 = 'C2'



class Spoken_proficiency_level(enum.Enum):
   BASIC = 'BASIC'
   INTERMEDIATE = 'INTERMEDIATE'
   ADVANCED = 'ADVANCED'
   FLUENT = 'FLUENT'
   A1 = 'A1'
   A2 = 'A2'
   B1 = 'B1'
   B2 = 'B2'
   C1 = 'C1'
   C2 = 'C2'



class Written_proficiency_level(enum.Enum):
   BASIC = 'BASIC'
   INTERMEDIATE = 'INTERMEDIATE'
   ADVANCED = 'ADVANCED'
   FLUENT = 'FLUENT'
   A1 = 'A1'
   A2 = 'A2'
   B1 = 'B1'
   B2 = 'B2'
   C1 = 'C1'
   C2 = 'C2'



class Relationship_type(enum.Enum):
   HUSBAND = 'Husband'
   WIFE = 'Wife'
   SISTER = 'Sister'
   BROTHER = 'Brother'
   SIBLING = 'Sibling'
   SON = 'Son'
   DAUGHTER = 'Daughter'
   COUSIN = 'Cousin'
   IN_LAW = 'In_law'
   RELATIVE = 'Relative'
   FRIEND = 'Friend'
   HOUSEHOLD_MEMBER = 'Household_member'
   PARTNER = 'Partner'
   COWORKER = 'Coworker'
   SUPERIOR = 'Superior'
   SUBORDINATE = 'Subordinate'
   INFLUENCER = 'Influencer'
   OTHER = 'Other'



class Priority_level(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'



class Status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Geofence_trigger(enum.Enum):
   ENTER = 'Enter'
   EXIT = 'Exit'
   APPROACH = 'Approach'
   INSIDE = 'Inside'
   OUTSIDE = 'Outside'



class Engagement_type(enum.Enum):
   VIEW = 'View'
   LIKE = 'Like'
   STAR = 'Star'
   SHARE = 'Share'
   COMMENT = 'Comment'
   DISLIKE = 'Dislike'
   SAVE = 'Save'
   BOOKMARK = 'Bookmark'
   SUBSCRIBE = 'Subscribe'
   REPORT = 'Report'
   CLICKTHROUGH = 'ClickThrough'
   DOWNLOAD = 'Download'
   HIGHLIGHT = 'Highlight'
   COMPLETE = 'Complete'
   PAUSE = 'Pause'
   REPLAY = 'Replay'
   QUESTION = 'Question'



class Shared_to_platform(enum.Enum):
   EMAIL = 'Email'
   FACEBOOK = 'Facebook'
   TWITTER = 'Twitter'
   WHATSAPP = 'WhatsApp'
   LINKEDIN = 'LinkedIn'
   INSTAGRAM = 'Instagram'
   PINTEREST = 'Pinterest'
   TELEGRAM = 'Telegram'
   SNAPCHAT = 'Snapchat'
   TIKTOK = 'TikTok'
   REDDIT = 'Reddit'
   MESSENGER = 'Messenger'
   SMS = 'SMS'
   QRCODE = 'QRCode'
   WECHAT = 'WeChat'
   VIBER = 'Viber'
   SIGNAL = 'Signal'
   SLACK = 'Slack'
   COPYLINK = 'CopyLink'



class Difficulty_feedback(enum.Enum):
   EASY = 'Easy'
   JUST_RIGHT = 'Just_Right'
   DIFFICULT = 'Difficult'
   EXTREMELY_DIFFICULT = 'Extremely_Difficult'



class Gender(enum.Enum):
   MALE = 'Male'
   FEMALE = 'Female'
   NON_BINARY = 'Non_Binary'
   PREFER_NOT_TO_SAY = 'Prefer_Not_to_Say'
   OTHER = 'Other'



class Animal_type(enum.Enum):
   CATTLE = 'Cattle'
   SHEEP = 'Sheep'
   GOAT = 'Goat'
   PIG = 'Pig'
   HORSE = 'Horse'
   DONKEY = 'Donkey'
   MULE = 'Mule'
   BUFFALO = 'Buffalo'
   CAMEL = 'Camel'
   CHICKEN = 'Chicken'
   DUCK = 'Duck'
   GOOSE = 'Goose'
   TURKEY = 'Turkey'
   RABBIT = 'Rabbit'
   FISH = 'Fish'
   OSTRICH = 'Ostrich'
   GUINEA_FOWL = 'Guinea_fowl'
   SNAIL = 'Snail'
   QUAIL = 'Quail'
   BEE = 'Bee'
   ALPACA = 'Alpaca'
   LLAMA = 'Llama'
   OTHER = 'Other'



class Org_type(enum.Enum):
   INDIVIDUAL = 'Individual'
   BUSINESS_NAME = 'Business_Name'
   SOLE_PROPRIETORSHIP = 'Sole_Proprietorship'
   PARTNERSHIP = 'Partnership'
   PRIVATE_LIMITED_COMPANY = 'Private_Limited_Company'
   PUBLIC_LIMITED_COMPANY = 'Public_Limited_Company'
   PUBLIC_COMPANY_LIMITED_BY_GUARANTEE = 'Public_Company_Limited_by_Guarantee'
   PRIVATE_UNLIMITED_COMPANY = 'Private_Unlimited_Company'
   PUBLIC_UNLIMITED_COMPANY = 'Public_Unlimited_Company'
   COOPERATIVE = 'Cooperative'
   NONPROFIT = 'Nonprofit'
   TRUST = 'Trust'
   GOVERNMENT = 'Government'
   FRANCHISE = 'Franchise'
   SUBSIDIARY = 'Subsidiary'
   HOLDING_COMPANY = 'Holding_Company'
   JOINT_VENTURE = 'Joint_Venture'
   FREELANCER = 'Freelancer'
   AGENCY = 'Agency'
   WOMENS_GROUP = 'Womens_Group'
   MEITI_ALLAH = 'Meiti_Allah'
   INFORMAL_GROUP = 'Informal_Group'
   CHAMA = 'Chama'
   OTHER_GROUPINGS = 'Other_Groupings'
   FAMILY = 'Family'
   CLAN = 'Clan'
   TRIBE = 'Tribe'
   ASSOCIATION = 'Association'
   CLUB = 'Club'
   CONSORTIUM = 'Consortium'
   SYNDICATE = 'Syndicate'
   COLLECTIVE = 'Collective'
   NETWORK = 'Network'
   FOUNDATION = 'Foundation'
   FEDERATION = 'Federation'
   CHAMBER_OF_COMMERCE = 'Chamber_of_Commerce'
   GUILD = 'Guild'
   UNION = 'Union'
   RELIGIOUS_ORGANIZATION = 'Religious_Organization'
   POLITICAL_ORGANIZATION = 'Political_Organization'
   ALUMNI_ASSOCIATION = 'Alumni_Association'
   AFFILIATE = 'Affiliate'
   DIVISION = 'Division'
   COUNCIL = 'Council'
   TASK_FORCE = 'Task_Force'
   SOCIAL_CLUB = 'Social_Club'
   CHARITY = 'Charity'
   THINK_TANK = 'Think_Tank'



class Org_reg_status(enum.Enum):
   PENDING_APPROVAL = 'pending_approval'
   KYC_SUBMITTED = 'kyc_submitted'
   KYC_APPROVED = 'kyc_approved'
   KYC_REJECTED = 'kyc_rejected'
   ESCALATED = 'escalated'
   CONTRACTED = 'contracted'
   ACTIVE = 'active'
   SUSPENDED = 'suspended'
   INACTIVE = 'inactive'
   CONTRACT_TERMINATED = 'contract_terminated'
   DOCS_EXPIRED = 'docs_expired'
   UNDER_REVIEW = 'under_review'
   LOCKED = 'locked'
   AWAITING_RENEWAL = 'awaiting_renewal'
   RENEWAL_REJECTED = 'renewal_rejected'
   VERIFICATION_FAILED = 'verification_failed'



class Op_level(enum.Enum):
   CONTINENT = 'Continent'
   REGION = 'Region'
   SUPRANATIONAL = 'Supranational'
   COUNTRY = 'Country'
   FEDERAL = 'Federal'
   STATE = 'State'
   LGA = 'LGA'
   WARD = 'Ward'
   PROVINCE = 'Province'
   COUNTY = 'County'
   DISTRICT = 'District'
   LOCATION = 'Location'
   SUB_LOCATION = 'Sub_location'
   CANTON = 'Canton'
   MUNICIPALITY = 'Municipality'
   TOWN = 'Town'
   VILLAGE = 'Village'
   NEIGHBORHOOD = 'Neighborhood'
   BOROUGH = 'Borough'
   SUBURB = 'Suburb'
   ZONE = 'Zone'









class Classification(enum.Enum):
   CURRENT = 'Current'
   NON_CURRENT = 'Non_Current'
   NOT_APPLICABLE = 'Not_Applicable'



class Normal_side(enum.Enum):
   DEBIT = 'Debit'
   CREDIT = 'Credit'



class Account_usage(enum.Enum):
   TRANSACTIONAL = 'transactional'
   REPORTING = 'reporting'
   BOTH = 'both'



class Account_type(enum.Enum):
   ASSET = 'Asset'
   CURRENT_ASSET = 'Current_Asset'
   CONTRA_ASSET = 'Contra_Asset'
   FIXED_ASSET = 'Fixed_Asset'
   OTHER_ASSET = 'Other_Asset'
   NON_CURRENT_ASSET = 'Non_Current_Asset'
   LIABILITY = 'Liability'
   CURRENT_LIABILITY = 'Current_Liability'
   NON_CURRENT_LIABILITY = 'Non_Current_Liability'
   OTHER_LIABILITY = 'Other_Liability'
   EQUITY = 'Equity'
   INCOME = 'Income'
   EXPENSE = 'Expense'
   OTHER = 'Other'



class Account_category(enum.Enum):
   OPERATING = 'Operating'
   INVESTING = 'Investing'
   FINANCING = 'Financing'



class Closure_type(enum.Enum):
   MONTHLY = 'Monthly'
   QUARTERLY = 'Quarterly'
   YEARLY = 'Yearly'



class Duration_unit(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Quote_status(enum.Enum):
   NOT_STARTED = 'Not_Started'
   DRAFT = 'Draft'
   IN_PROGRESS = 'In_Progress'
   AWAITING_REVIEW = 'Awaiting_Review'
   UNDER_REVIEW = 'Under_Review'
   REVIEW_COMPLETED = 'Review_Completed'
   REVISIONS_NEEDED = 'Revisions_Needed'
   SUBMITTED = 'Submitted'
   APPROVED = 'Approved'
   PARTIALLY_APPROVED = 'Partially_Approved'
   REJECTED = 'Rejected'
   CANCELLED = 'Cancelled'
   ARCHIVED = 'Archived'
   PUBLISHED = 'Published'
   SUSPENDED = 'Suspended'
   VOIDED = 'Voided'
   COMPLETED = 'Completed'
   EXPIRED = 'Expired'
   RENEWED = 'Renewed'
   LOCKED = 'Locked'
   MERGED = 'Merged'
   ROLLBACK = 'Rollback'
   CONFLICT = 'Conflict'
   QUEUED_FOR_REVIEW = 'Queued_for_Review'
   QUEUED_FOR_PUBLISH = 'Queued_for_Publish'
   DEPRECATED = 'Deprecated'
   UNPUBLISHED = 'Unpublished'
   IN_TRANSLATION = 'In_Translation'
   VALIDATION_FAILED = 'Validation_Failed'
   VALIDATION_PASSED = 'Validation_Passed'
   DIGITIZED = 'Digitized'
   IN_SIGNATURE_PROCESS = 'In_Signature_Process'
   SIGNATURE_COMPLETED = 'Signature_Completed'
   SIGNATURE_FAILED = 'Signature_Failed'
   IN_AUDIT = 'In_Audit'
   AUDIT_COMPLETED = 'Audit_Completed'
   IN_TRANSIT = 'In_Transit'
   RECEIVED = 'Received'
   SENT = 'Sent'












class Trans_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Payment_mode(enum.Enum):
   CASH = 'cash'
   CREDIT_CARD = 'credit_card'
   DEBIT_CARD = 'debit_card'
   PREPAID_CARD = 'prepaid_card'
   COMMERCIAL_CARD = 'commercial_card'
   DEBT = 'debt'
   BANK = 'bank'
   MOBILE = 'mobile'
   COUPON = 'coupon'
   ORDER = 'order'
   WITHDRAWAL = 'Withdrawal'
   FUND_WALLET = 'fund_wallet'
   CHEQUE = 'cheque'
   BANK_TRANSFER = 'bank_transfer'
   CRYPTO = 'crypto'
   BARTER = 'barter'
   WIRE_TRANSFER = 'wire_transfer'
   CONTACTLESS = 'contactless'
   GIFT_CARD = 'gift_card'
   LOYALTY_POINTS = 'loyalty_points'
   MONEY_ORDER = 'money_order'
   ESCROW = 'escrow'
   INSTALLMENT = 'installment'
   INVOICE = 'invoice'
   PREPAID = 'prepaid'
   QR_CODE = 'qr_code'
   DIGITAL_WALLET = 'digital_wallet'
   AUTOMATIC_DEBIT = 'automatic_debit'
   CASH_ON_DELIVERY = 'cash_on_delivery'
   POSTPAID = 'postpaid'
   THIRD_PARTY = 'third_party'
   TRADE_CREDIT = 'trade_credit'



class Transaction_type(enum.Enum):
   DEBIT = 'Debit'
   CREDIT = 'Credit'
   ADJUSTMENT = 'Adjustment'
   TRANSFER = 'Transfer'
   INTEREST_CHARGE = 'Interest_Charge'
   INTEREST_REVERSAL = 'Interest_Reversal'
   FEE = 'Fee'
   PENALTY = 'Penalty'
   REFUND = 'Refund'
   SETTLEMENT = 'Settlement'



class Transaction_source(enum.Enum):
   MANUAL_ENTRY = 'Manual_Entry'
   API = 'API'
   IMPORTED = 'Imported'
   AUTOMATED_PROCESS = 'Automated_Process'



class Financial_account_type(enum.Enum):
   ASSET = 'Asset'
   CURRENT_ASSET = 'Current_Asset'
   CONTRA_ASSET = 'Contra_Asset'
   FIXED_ASSET = 'Fixed_Asset'
   OTHER_ASSET = 'Other_Asset'
   NON_CURRENT_ASSET = 'Non_Current_Asset'
   LIABILITY = 'Liability'
   CURRENT_LIABILITY = 'Current_Liability'
   NON_CURRENT_LIABILITY = 'Non_Current_Liability'
   OTHER_LIABILITY = 'Other_Liability'
   EQUITY = 'Equity'
   INCOME = 'Income'
   EXPENSE = 'Expense'
   OTHER = 'Other'



class Duration(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Priority(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'









class Invoice_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Soil_type(enum.Enum):
   SANDY = 'Sandy'
   LOAMY = 'Loamy'
   CLAYEY = 'Clayey'
   SILTY = 'Silty'
   PEATY = 'Peaty'
   CHALKY = 'Chalky'
   ROCKY = 'Rocky'
   SALINE = 'Saline'
   ALLUVIAL = 'Alluvial'
   CALCAREOUS = 'Calcareous'



class Land_use(enum.Enum):
   CROPPING = 'Cropping'
   GRAZING = 'Grazing'
   FALLOW = 'Fallow'
   FORESTED = 'Forested'
   WETLAND = 'Wetland'
   RESIDENTIAL = 'Residential'
   COMMERCIAL = 'Commercial'
   INDUSTRIAL = 'Industrial'
   RECREATIONAL = 'Recreational'
   CONSERVATION = 'Conservation'
   MINING = 'Mining'
   ORCHARD = 'Orchard'
   VINEYARD = 'Vineyard'
   FISHERY = 'Fishery'
   POULTRY = 'Poultry'
   DAIRY = 'Dairy'
   ORGANIC = 'Organic'
   RENEWABLE_ENERGY = 'Renewable_Energy'
   LANDFILL = 'Landfill'
   MARSHLAND = 'Marshland'
   RESEARCH = 'Research'
   MILITARY = 'Military'
   EDUCATIONAL = 'Educational'
   RELIGIOUS = 'Religious'
   TRANSPORTATION = 'Transportation'
   UTILITY = 'Utility'
   MIXED_USE = 'Mixed_Use'
   AQUACULTURE = 'Aquaculture'
   ARBORETUM = 'Arboretum'
   BROWNFIELD = 'Brownfield'
   TUNDRA = 'Tundra'
   SAVANNAH = 'Savannah'
   GRASSLAND = 'Grassland'



class Water_source(enum.Enum):
   WELL = 'Well'
   RIVER = 'River'
   LAKE = 'Lake'
   RAINWATER = 'Rainwater'
   SPRING = 'Spring'
   RESERVOIR = 'Reservoir'
   CANAL = 'Canal'
   OCEAN = 'Ocean'
   POND = 'Pond'
   GLACIER = 'Glacier'
   DESALINATION = 'Desalination'
   RECYCLED = 'Recycled'
   MUNICIPAL = 'Municipal'
   GROUNDWATER = 'Groundwater'
   ARTESIAN = 'Artesian'
   IMPORTED = 'Imported'
   BOREHOLE = 'Borehole'
   TAP = 'Tap'
   CREEK = 'Creek'
   STREAM = 'Stream'
   DAM = 'Dam'



class Amortization_method_enum(enum.Enum):
   STRAIGHT_LINE = 'Straight_Line'
   DECLINING_BALANCE = 'Declining_Balance'
   RULE_OF_78S = 'Rule_of_78s'
   ANNUITY = 'Annuity'
   BULLET = 'Bullet'
   BALLOON = 'Balloon'
   VARIABLE_AMORTIZATION = 'Variable_Amortization'
   CUSTOM = 'Custom'
   INTEREST_ONLY = 'Interest_Only'
   FIXED_PRINCIPAL = 'Fixed_Principal'
   SEASONAL = 'Seasonal'
   INCREASING_PAYMENT = 'Increasing_Payment'
   NEGATIVELY_AMORTIZING = 'Negatively_Amortizing'



class Pipeline_stage(enum.Enum):
   LEAD_GENERATION = 'Lead_Generation'
   QUALIFICATION = 'Qualification'
   NEEDS_ANALYSIS = 'Needs_Analysis'
   PROPOSAL = 'Proposal'
   NEGOTIATION = 'Negotiation'
   CLOSURE = 'Closure'
   EXECUTING = 'Executing'
   POST_SALE = 'Post_Sale'
   UPSELLING = 'Upselling'
   RENEWAL = 'Renewal'
   REFERRAL = 'Referral'
   LOST_DEAL_ANALYSIS = 'Lost_Deal_Analysis'
   RE_ENGAGEMENT = 'Re_Engagement'



class Return_action(enum.Enum):
   REFUNDED = 'refunded'
   CREDIT_ISSUED = 'Credit_Issued'
   REPLACEMENT_SENT = 'Replacement_sent'



class Return_reason(enum.Enum):
   DEAD_ON_ARRIVAL = 'Dead_on_arrival'
   RECEIVED_WRONG_ITEM = 'Received_wrong_item'
   ORDER_ERROR = 'Order_error'
   FAULTY_ITEM = 'Faulty_item'
   OTHER = 'Other'



class Reminder_interval_type(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Remind_by(enum.Enum):
   EMAIL = 'EMAIL'
   SMS = 'SMS'
   NOTIFICATION = 'NOTIFICATION'
   PHONE_CALL = 'PHONE_CALL'
   PUSH_NOTIFICATION = 'PUSH_NOTIFICATION'
   SLACK_MESSAGE = 'SLACK_MESSAGE'
   TELEGRAM_MESSAGE = 'TELEGRAM_MESSAGE'
   WHATSAPP_MESSAGE = 'WHATSAPP_MESSAGE'
   CALENDAR_EVENT = 'CALENDAR_EVENT'
   DESKTOP_ALERT = 'DESKTOP_ALERT'
   SNAIL_MAIL = 'SNAIL_MAIL'
   SOCIAL_MEDIA_DM = 'SOCIAL_MEDIA_DM'
   RSS_FEED = 'RSS_FEED'
   DISCORD_MESSAGE = 'DISCORD_MESSAGE'



class Trigger_type(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'












class Improvement_type(enum.Enum):
   PLOWING = 'Plowing'
   WEEDING = 'Weeding'
   FENCING = 'Fencing'
   IRRIGATION = 'Irrigation'
   DRAINAGE = 'Drainage'
   TERRACING = 'Terracing'
   EROSION_CONTROL = 'Erosion_Control'
   PAVING = 'Paving'
   SHED_CONSTRUCTION = 'Shed_Construction'
   REFORESTATION = 'Reforestation'
   LAND_LEVELING = 'Land_Leveling'
   POLLUTION_CONTROL = 'Pollution_Control'
   SOLAR_INSTALLATION = 'Solar_Installation'
   WIND_TURBINES = 'Wind_Turbines'
   WATER_STORAGE = 'Water_Storage'
   COMPOSTING_SYSTEMS = 'Composting_Systems'
   ANIMAL_HOUSING = 'Animal_Housing'
   PEST_CONTROL = 'Pest_Control'
   WILDLIFE_CONSERVATION = 'Wildlife_Conservation'
   EQUIPMENT_STORAGE = 'Equipment_Storage'
   GREENHOUSE = 'Greenhouse'



class Used_for(enum.Enum):
   CROPPING = 'Cropping'
   GRAZING = 'Grazing'
   FALLOW = 'Fallow'
   FORESTED = 'Forested'
   WETLAND = 'Wetland'
   RESIDENTIAL = 'Residential'
   COMMERCIAL = 'Commercial'
   INDUSTRIAL = 'Industrial'
   RECREATIONAL = 'Recreational'
   CONSERVATION = 'Conservation'
   MINING = 'Mining'
   ORCHARD = 'Orchard'
   VINEYARD = 'Vineyard'
   FISHERY = 'Fishery'
   POULTRY = 'Poultry'
   DAIRY = 'Dairy'
   ORGANIC = 'Organic'
   RENEWABLE_ENERGY = 'Renewable_Energy'
   LANDFILL = 'Landfill'
   MARSHLAND = 'Marshland'
   RESEARCH = 'Research'
   MILITARY = 'Military'
   EDUCATIONAL = 'Educational'
   RELIGIOUS = 'Religious'
   TRANSPORTATION = 'Transportation'
   UTILITY = 'Utility'
   MIXED_USE = 'Mixed_Use'
   AQUACULTURE = 'Aquaculture'
   ARBORETUM = 'Arboretum'
   BROWNFIELD = 'Brownfield'
   TUNDRA = 'Tundra'
   SAVANNAH = 'Savannah'
   GRASSLAND = 'Grassland'



class Category(enum.Enum):
   SOIL_HEALTH_MANAGEMENT = 'Soil_Health_Management'
   CROP_SELECTION_AND_ROTATION = 'Crop_Selection_and_Rotation'
   INTEGRATED_PEST_MANAGEMENT = 'Integrated_Pest_Management'
   WATER_MANAGEMENT = 'Water_Management'
   PLANTING_STRATEGIES = 'Planting_Strategies'
   WEED_MANAGEMENT = 'Weed_Management'
   HARVEST_AND_POST_HARVEST_MANAGEMENT = 'Harvest_and_Post_Harvest_Management'
   CLIMATE_AND_WEATHER = 'Climate_and_Weather'
   SUSTAINABLE_FARMING_PRACTICES = 'Sustainable_Farming_Practices'
   FARM_TECHNOLOGY_AND_MECHANIZATION = 'Farm_Technology_and_Mechanization'
   MARKETING_AND_AGRIBUSINESS = 'Marketing_and_Agribusiness'
   RESEARCH_AND_DEVELOPMENT = 'Research_and_Development'



class Loan_status(enum.Enum):
   PENDING = 'pending'
   AUTHORIZED = 'authorized'
   COMPLETED = 'completed'
   FAILED = 'failed'
   CANCELLED = 'cancelled'
   REFUNDED = 'refunded'
   REVERSED = 'reversed'
   HOLD = 'hold'
   SUSPENDED = 'suspended'
   DISPUTED = 'disputed'
   DELIVERED = 'delivered'
   SETTLEMENT_PENDING = 'settlement_pending'
   SETTLED = 'settled'
   REJECTED = 'rejected'
   EXPIRED = 'expired'
   PENDING_VERIFICATION = 'pending_verification'
   HOLD_FOR_REVIEW = 'hold_for_review'
   PARTIALLY_COMPLETED = 'partially_completed'
   PARTIALLY_REFUNDED = 'partially_refunded'
   PARTIALLY_REVERSED = 'partially_reversed'
   COMPLETED_WITH_ERRORS = 'completed_with_errors'
   BATCH_PROCESSING = 'batch_processing'
   DEFERRED = 'deferred'
   WAITING_FOR_AUTHORIZATION = 'waiting_for_authorization'
   PROCESSING = 'processing'
   PENDING_FUNDS_AVAILABILITY = 'pending_funds_availability'
   PENDING_REVIEW = 'pending_review'
   PENDING_CONFIRMATION = 'pending_confirmation'
   WAITING_FOR_SETTLEMENT = 'waiting_for_settlement'
   PENDING_RECONCILIATION = 'pending_reconciliation'
   PENDING_DISBURSEMENT = 'pending_disbursement'
   CHARGEBACK_INITIATED = 'chargeback_initiated'
   CHARGEBACK_RESOLVED = 'chargeback_resolved'
   PENDING_CAPTURE = 'pending_capture'
   CAPTURED = 'captured'
   VOIDED = 'voided'
   IN_QUEUE = 'in_queue'
   MANUAL_INTERVENTION_REQUIRED = 'manual_intervention_required'
   GATEWAY_TIMEOUT = 'gateway_timeout'
   FRAUD_ALERT = 'fraud_alert'
   UNDER_AUDIT = 'under_audit'
   AUDIT_COMPLETED = 'audit_completed'
   CURRENCY_CONVERSION = 'currency_conversion'
   CURRENCY_CONVERSION_COMPLETED = 'currency_conversion_completed'
   ESCALATED = 'escalated'
   DE_ESCALATED = 'de_escalated'
   PENDING_APPROVAL = 'pending_approval'
   APPROVED = 'approved'
   DECLINED = 'declined'
   RE_ATTEMPTED = 're_attempted'
   RE_SCHEDULED = 're_scheduled'
   INSUFFICIENT_FUNDS = 'insufficient_funds'
   VERIFICATION_FAILED = 'verification_failed'
   VERIFICATION_SUCCESSFUL = 'verification_successful'
   PENDING_CLEARANCE = 'pending_clearance'
   CLEARED = 'cleared'
   RE_INITIATED = 're_initiated'
   SPLIT_TRANSACTION = 'split_transaction'
   CONSOLIDATED = 'consolidated'



class Loan_sub_status(enum.Enum):
   ACTIVE_IN_GOOD_STANDING = 'Active_In_Good_Standing'
   ACTIVE_IN_ARREARS = 'Active_In_Arrears'
   PENDING_FIRST_DISBURSEMENT = 'Pending_First_Disbursement'
   PARTIALLY_DISBURSED = 'Partially_Disbursed'
   FORECLOSED = 'Foreclosed'
   RESTRUCTURED = 'Restructured'
   WRITTEN_OFF = 'Written_Off'
   SETTLED = 'Settled'
   CLOSED = 'Closed'
   DEFAULTED = 'Defaulted'
   ACTIVE_WITH_OVERDUE_CHARGES = 'Active_With_Overdue_Charges'
   SUSPENDED = 'Suspended'
   PREPAYMENT = 'Prepayment'
   UNDER_REVIEW = 'Under_Review'



class Interest_period_frequency(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Interest_method(enum.Enum):
   SIMPLE_INTEREST = 'Simple_Interest'
   COMPOUND_INTEREST = 'Compound_Interest'
   FLAT_RATE = 'Flat_Rate'
   FIXED_INTEREST_OVER_TERM = 'Fixed_Interest_Over_Term'
   DECLINING_BALANCE = 'Declining_Balance'
   ANNUITY = 'Annuity'
   RULE_OF_78S = 'Rule_of_78s'
   CUSTOM = 'Custom'



class Interest_calculated_in_period(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Term_frequency(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Repay_every(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Amortization_method(enum.Enum):
   STRAIGHT_LINE = 'Straight_Line'
   DECLINING_BALANCE = 'Declining_Balance'
   RULE_OF_78S = 'Rule_of_78s'
   ANNUITY = 'Annuity'
   BULLET = 'Bullet'
   BALLOON = 'Balloon'
   VARIABLE_AMORTIZATION = 'Variable_Amortization'
   CUSTOM = 'Custom'
   INTEREST_ONLY = 'Interest_Only'
   FIXED_PRINCIPAL = 'Fixed_Principal'
   SEASONAL = 'Seasonal'
   INCREASING_PAYMENT = 'Increasing_Payment'
   NEGATIVELY_AMORTIZING = 'Negatively_Amortizing'









class Texture(enum.Enum):
   SANDY = 'Sandy'
   LOAMY = 'Loamy'
   CLAYEY = 'Clayey'
   SILTY = 'Silty'
   PEATY = 'Peaty'
   CHALKY = 'Chalky'
   ROCKY = 'Rocky'
   SALINE = 'Saline'
   ALLUVIAL = 'Alluvial'
   CALCAREOUS = 'Calcareous'



class Notification_status(enum.Enum):
   NOT_STARTED = 'Not_Started'
   DRAFT = 'Draft'
   IN_PROGRESS = 'In_Progress'
   AWAITING_REVIEW = 'Awaiting_Review'
   UNDER_REVIEW = 'Under_Review'
   REVIEW_COMPLETED = 'Review_Completed'
   REVISIONS_NEEDED = 'Revisions_Needed'
   SUBMITTED = 'Submitted'
   APPROVED = 'Approved'
   PARTIALLY_APPROVED = 'Partially_Approved'
   REJECTED = 'Rejected'
   CANCELLED = 'Cancelled'
   ARCHIVED = 'Archived'
   PUBLISHED = 'Published'
   SUSPENDED = 'Suspended'
   VOIDED = 'Voided'
   COMPLETED = 'Completed'
   EXPIRED = 'Expired'
   RENEWED = 'Renewed'
   LOCKED = 'Locked'
   MERGED = 'Merged'
   ROLLBACK = 'Rollback'
   CONFLICT = 'Conflict'
   QUEUED_FOR_REVIEW = 'Queued_for_Review'
   QUEUED_FOR_PUBLISH = 'Queued_for_Publish'
   DEPRECATED = 'Deprecated'
   UNPUBLISHED = 'Unpublished'
   IN_TRANSLATION = 'In_Translation'
   VALIDATION_FAILED = 'Validation_Failed'
   VALIDATION_PASSED = 'Validation_Passed'
   DIGITIZED = 'Digitized'
   IN_SIGNATURE_PROCESS = 'In_Signature_Process'
   SIGNATURE_COMPLETED = 'Signature_Completed'
   SIGNATURE_FAILED = 'Signature_Failed'
   IN_AUDIT = 'In_Audit'
   AUDIT_COMPLETED = 'Audit_Completed'
   IN_TRANSIT = 'In_Transit'
   RECEIVED = 'Received'
   SENT = 'Sent'



class Charge_time(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Charge_calculation(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Guarantor_type(enum.Enum):
   NONE = 'NONE'
   INDIVIDUAL = 'INDIVIDUAL'
   CORPORATE = 'CORPORATE'
   ASSET_BACKED = 'ASSET_BACKED'
   JOINT_AND_SEVERAL = 'JOINT_AND_SEVERAL'
   SPONSOR = 'SPONSOR'
   GOVERNMENT = 'GOVERNMENT'
   INSURANCE = 'INSURANCE'
   COSIGNER = 'COSIGNER'
   COLLATERAL = 'COLLATERAL'
   UNSECURED = 'UNSECURED'



class Repayment_interval(enum.Enum):
   NONE = 'None'
   PER_SECOND = 'Per_Second'
   PER_MINUTE = 'Per_Minute'
   HOURLY = 'Hourly'
   DAILY = 'Daily'
   WEEKLY = 'Weekly'
   BIWEEKLY = 'Biweekly'
   MONTHLY = 'Monthly'
   BIMONTHLY = 'Bimonthly'
   QUARTERLY = 'Quarterly'
   SEMI_ANNUALLY = 'Semi_Annually'
   ANNUALLY = 'Annually'
   CUSTOM = 'Custom'
   WORKDAYS = 'Workdays'
   WEEKENDS = 'Weekends'
   MONDAY = 'MONDAY'
   TUESDAY = 'TUESDAY'
   WEDNESDAY = 'WEDNESDAY'
   THURSDAY = 'THURSDAY'
   FRIDAY = 'FRIDAY'
   SATURDAY = 'SATURDAY'
   SUNDAY = 'SUNDAY'
   FIRST_DAY_MONTH = 'FIRST_DAY_MONTH'
   LAST_DAY_MONTH = 'LAST_DAY_MONTH'
   FIRST_WEEKDAY = 'FIRST_WEEKDAY'
   LAST_WEEKDAY = 'LAST_WEEKDAY'
   EVERY_X_DAYS = 'EVERY_X_DAYS'
   EVERY_X_WEEKS = 'EVERY_X_WEEKS'
   EVERY_X_MONTHS = 'EVERY_X_MONTHS'
   EVERY_X_YEARS = 'EVERY_X_YEARS'



class Action(enum.Enum):
   CREATED = 'CREATED'
   UPDATED = 'UPDATED'
   DELETED = 'DELETED'
   MOVED = 'MOVED'



class Alert_level(enum.Enum):
   INSIGNIFICANT = 'Insignificant'
   TRIVIAL = 'Trivial'
   LOW = 'Low'
   MODERATE = 'Moderate'
   SIGNIFICANT = 'Significant'
   HIGH = 'High'
   URGENT = 'Urgent'
   SEVERE = 'Severe'
   EXTREME = 'Extreme'
   CRITICAL = 'Critical'



class TechParameters(Model):
    __tablename__ = "Tech_Parameters"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    key = Column(String, primary_key=True)
    value = Column(Text, nullable=True)
    enabled = Column(Boolean, default=True, nullable=True)
    notes = Column(Text, nullable=True)

    def __repr__(self):
       return self.key

 ### 


class Badge(Model):
    __tablename__ = "badge"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String)
    description = Column(Text, nullable=True)
    icon_url = Column(String, nullable=True
		, comment="""Link to badge icon/image""")

    def __repr__(self):
       return self.name

 ### 


class ContactType(Model):
    __tablename__ = "contact_type"
    # __table_args__ = ( ) # tuple
    __doc__ = """ phone, mobile, email, messaging, whatsapp, viber, instagram, website, etc"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the address type.""")
    name = Column(String
		, comment="""Name or type of contact method, e.g., Mobile, Email, WhatsApp.""")
    description = Column(Text, nullable=True
		, comment="""Brief description about the address type, providing context or usage scenarios.""")
    is_digital = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if the contact method is digital or physical.""")
    requires_verification = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the address type typically requires a verification process, e.g., email confirmation.""")
    max_length = Column(Integer, nullable=True
		, comment="""If applicable, the maximum character length of a value of this address type. Useful for validation.""")
    icon_url = Column(String, nullable=True
		, comment="""URL or link to an icon or image representing this address type. Useful for UI/UX purposes.""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the address type was added to the system.""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the address type was last updated.""")

    def __repr__(self):
       return self.name

 ### 


class Crop(Model):
    __tablename__ = "crop"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    crop_name = Column(Text, nullable=True
		, comment="""Common name of the crop""")
    scientific_name = Column(Text, nullable=True
		, comment="""Scientific name of the crop""")
    family_name = Column(Text, nullable=True
		, comment="""Taxonomic family the crop belongs to""")
    genus = Column(Text, nullable=True
		, comment="""Genus of the crop""")
    variety = Column(Text, nullable=True
		, comment="""Specific variety or cultivar""")
    lifecycle_enum = Column(Text, nullable=True
		, comment="""Annual, Biennial, or Perennial""")
    growth_habit = Column(Text, nullable=True
		, comment="""Growth habit (e.g., bushy, vine, etc.)""")
    optimal_soil_texture = Column(Enum(t_soil_texture), nullable=False)
    optimal_season = Column(Text, nullable=True
		, comment="""Optimal season for planting""")
    germination_days = Column(Integer, nullable=True
		, comment="""Days required for seed germination""")
    maturity_days = Column(Integer, nullable=True
		, comment="""Days to reach maturity""")
    optimal_soil_ph_min = Column(Float, nullable=True
		, comment="""Minimum optimal soil pH""")
    optimal_soil_ph_max = Column(Float, nullable=True
		, comment="""Maximum optimal soil pH""")
    optimal_nitrogen_level = Column(Float, nullable=True
		, comment="""Optimal Nitrogen level in soil""")
    optimal_phosphorus_level = Column(Float, nullable=True
		, comment="""Optimal Phosphorus level in soil""")
    optimal_potassium_level = Column(Float, nullable=True
		, comment="""Optimal Potassium level in soil""")
    optimal_temp_min = Column(Float, nullable=True
		, comment="""Minimum optimal temperature (°C)""")
    optimal_temp_max = Column(Float, nullable=True
		, comment="""Maximum optimal temperature (°C)""")
    frost_tolerance = Column(Text, nullable=True
		, comment="""Frost tolerance level""")
    drought_tolerance = Column(Enum(t_severity_level), nullable=False)
    drought_tolerance_notes = Column(Text, nullable=True)
    water_requirement_mm = Column(Integer, nullable=True
		, comment="""Water requirement in mm per season""")
    sun_exposure = Column(Text, nullable=True
		, comment="""Amount of sun exposure needed""")
    spacing_cm = Column(Integer, nullable=True
		, comment="""Recommended plant spacing in cm""")
    planting_depth_mm = Column(Integer, nullable=True
		, comment="""Recommended planting depth in mm""")
    harvest_indicator = Column(Text, nullable=True
		, comment="""Signs that the crop is ready for harvest""")
    typical_yield_per_sq_m = Column(Float, nullable=True
		, comment="""Typical yield per square meter""")
    pests = Column(Text, nullable=True
		, comment="""Common pests affecting the crop""")
    diseases = Column(Text, nullable=True
		, comment="""Common diseases affecting the crop""")
    nutritional_content = Column(Text, nullable=True
		, comment="""Nutritional content description""")
    market_value = Column(Numeric, nullable=True
		, comment="""Average market value per unit mass or volume""")

    def __repr__(self):
       return self.crop_name

 ### 


class Currency(Model):
    __tablename__ = "currency"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=True)
    symbol = Column(String, nullable=True)
    numeric_code = Column(String, nullable=True)
    full_name = Column(String, nullable=True)

    def __repr__(self):
       return self.name

 ### 


class Disease(Model):
    __tablename__ = "disease"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each disease""")
    disease_name = Column(Text, nullable=True
		, comment="""Common name of the disease""")
    scientific_name = Column(Text, nullable=True
		, comment="""Scientific name, if applicable""")
    causal_agent = Column(Text, nullable=True
		, comment="""Causal agent responsible for the disease (e.g., fungus, bacteria, virus)""")
    disease_signature = Column(Text, nullable=True
		, comment="""AI-driven identifier for the disease""")
    symptoms = Column(Text, nullable=True
		, comment="""Symptoms exhibited by plants/animals infected with the disease""")
    transmission_mode = Column(Text, nullable=True
		, comment="""How the disease spreads (e.g., air, water, vectors)""")
    lifecycle = Column(Text, nullable=True
		, comment="""Lifecycle or stages of the disease, if applicable""")
    control_prevention_methods = Column(Text, nullable=True
		, comment="""Methods to control or prevent the spread of the disease""")
    affected_species = Column(Text, nullable=True
		, comment="""Species (plant or animal) commonly affected by the disease""")
    economic_impact = Column(Text, nullable=True
		, comment="""Economic implications due to damages caused by the disease""")
    known_resistances = Column(Text, nullable=True
		, comment="""Any known resistances or immunity among species""")
    favorable_conditions = Column(Text, nullable=True
		, comment="""Environmental conditions that favor the disease’s spread""")
    region_prevalence = Column(Text, nullable=True
		, comment="""Regions where the disease is commonly found""")
    images_url = Column(String, nullable=True
		, comment="""URLs of the disease images for visual identification""")
    treatment_options = Column(Text, nullable=True
		, comment="""Treatment options available, if applicable""")

    def __repr__(self):
       return self.disease_name

 ### 


class DocType(Model):
    __tablename__ = "doc_type"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the document type.""")
    name = Column(String, nullable=True
		, comment="""Name or title of the document type e.g. Passport, Drivers License.""")
    notes = Column(Text, nullable=True
		, comment="""Any additional remarks or details about the document type.""")
    required_information = Column(Text, nullable=True
		, comment="""List or description of required fields/information for this document type.""")
    category = Column(String, nullable=True
		, comment="""Category or classification of the document, e.g., Identification, Certification, Financial.""")
    validity_period = Column(Integer, nullable=True
		, comment="""Standard validity duration of this type of document in days.""")
    renewal_frequency = Column(Integer, nullable=True
		, comment="""Frequency at which this document typically needs renewal, in days. Useful for setting reminders.""")
    is_government_issued = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this document is typically issued by a government authority.""")
    is_digital = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the document is typically in digital format.""")
    template_url = Column(String, nullable=True
		, comment="""URL or link to a template or sample of this document type, if available.""")
    example_image_url = Column(String, nullable=True
		, comment="""URL or link to an example image of this document type.""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the document type was added to the system.""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the document type was last updated.""")

    def __repr__(self):
       return self.name

 ### 


class Featurecodes(Model):
    __tablename__ = "featurecodes"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    code = Column(String, primary_key=True
		, comment="""Primary identifier for the feature code, typically a combination of class and fcode""")
    fclass = Column(String, nullable=True
		, comment="""Class identifier that categorizes the type of geographical feature e.g., P for populated place, T for mountain""")
    fcode = Column(String, primary_key=True
		, comment="""Specific code within a class that describes the feature in more detail. E.g., within class P, an fcode might specify city, village, etc.""")
    label = Column(String, nullable=True
		, comment="""Short label or name for the feature code""")
    description = Column(String, nullable=True
		, comment="""Detailed description of what the feature code represents""")

    def __repr__(self):
       return self.label

 ### 


class Geoname(Model):
    __tablename__ = "geoname"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each geoname""")
    name = Column(String, nullable=True
		, comment="""Local name of the place or location""")
    asciiname = Column(String, nullable=True
		, comment="""ASCII version of the name, suitable for URL or systems that dont support unicode""")
    alternatenames = Column(Text, nullable=True
		, comment="""Alternative names or variations of the location name, possibly in different languages or scripts""")
    latitude = Column(Float, nullable=True
		, comment="""Latitude coordinate of the location""")
    longitude = Column(Float, nullable=True
		, comment="""Longitude coordinate of the location""")
    fclass = Column(String, nullable=True
		, comment="""Feature class, represents general type/category of the location e.g. P for populated place, A for administrative division""")
    fcode = Column(String, nullable=True
		, comment="""Feature code, more specific than feature class, indicating the exact type of feature""")
    country = Column(String, nullable=True
		, comment="""ISO-3166 2-letter country code""")
    cc2 = Column(String, nullable=True
		, comment="""Alternative country codes if the location is near a border""")
    admin1 = Column(String, nullable=True
		, comment="""Primary administrative division, e.g., state in the USA, oblast in Russia""")
    admin2 = Column(String, nullable=True
		, comment="""Secondary administrative division, e.g., county in the USA""")
    admin3 = Column(String, nullable=True
		, comment="""Tertiary administrative division, specific to each country""")
    admin4 = Column(String, nullable=True
		, comment="""Quaternary administrative division, specific to each country""")
    population = Column(BigInteger, nullable=True
		, comment="""Population of the location if applicable""")
    elevation = Column(Integer, nullable=True
		, comment="""Elevation above sea level in meters""")
    gtopo30 = Column(Integer, nullable=True
		, comment="""Digital elevation model, indicates the average elevation of 30x30 area in meters""")
    timezone = Column(String, nullable=True
		, comment="""The timezone in which the location lies, based on the IANA Time Zone Database""")
    moddate = Column(Date, nullable=True
		, comment="""The last date when the record was modified or updated""")

    def __repr__(self):
       return self.name

 ### 


class IsicSection(Model):
    __tablename__ = "isic_section"
    # __table_args__ = ( ) # tuple
    __doc__ = """ISIC Sections represent the topmost level in the ISIC classification hierarchy."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True
		, comment="""Unique identifier for each ISIC section.""")
    section_name = Column(String, nullable=True
		, comment="""Name or description of the ISIC section.""")

    def __repr__(self):
       return self.section_name

 ### 


class Languagecodes(Model):
    __tablename__ = "languagecodes"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    iso_639_3 = Column(String, nullable=True
		, comment="""ISO 639-3 code is a three-letter code that represents a specific language uniquely. It offers a comprehensive set of languages.""")
    iso_639_2 = Column(String, nullable=True
		, comment="""ISO 639-2 code is a three-letter code, which could be either bibliographic or terminological, representing a set of similar languages.""")
    iso_639_1 = Column(String, nullable=True
		, comment="""ISO 639-1 code is a two-letter code. It represents major languages but is not as exhaustive as ISO 639-3.""")
    name = Column(String, nullable=True
		, comment="""The descriptive name of the language in English.""")

    def __repr__(self):
       return self.name

 ### 


class LoanTransaction(Model):
    __tablename__ = "loan_transaction"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id = Column(BigInteger)
    is_reversed = Column(Boolean, nullable=True)
    payment_method = Column(Enum(t_payment_method), nullable=False)
    transaction_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    amount = Column(Numeric)
    principal_portion_derived = Column(Numeric, nullable=True)
    interest_portion_derived = Column(Numeric, nullable=True)
    fee_charges_portion_derived = Column(Numeric, nullable=True)
    penalty_charges_portion_derived = Column(Numeric, nullable=True)

    def __repr__(self):
       return self.id

 ### 


class LoanTransactionStrategy(Model):
    __tablename__ = "loan_transaction_strategy"
    # __table_args__ = ( ) # tuple
    __doc__ = """Main table to define loan transaction strategies"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key, auto-incremented""")
    name = Column(String
		, comment="""Human-readable name of the strategy""")
    description = Column(Text, nullable=True
		, comment="""Detailed explanation of what the strategy entails""")
    is_active = Column(Boolean, default=True
		, comment="""Flag indicating if this strategy is active or not""")
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this record was created""")
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this record was last updated""")
    note = Column(Text, nullable=True)

    def __repr__(self):
       return self.name

 ### 


class MimeType(Model):
    __tablename__ = "mime_type"
    # __table_args__ = ( ) # tuple
    __doc__ = """Standard MIME types recognized by the content management system."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    label = Column(String, nullable=True)
    mime_type = Column(String, nullable=True)
    file_extension = Column(String, nullable=True)

    def __repr__(self):
       return self.label

 ### 


class MimeTypeMap(Model):
    __tablename__ = "mime_type_map"
    # __table_args__ = ( ) # tuple
    __doc__ = """Maps extesions to mime types"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    extension = Column(String, nullable=True)
    mime_type = Column(String, nullable=True)

    def __repr__(self):
       return self.id

 ### 


class Module(Model):
    __tablename__ = "module"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String)
    description = Column(Text, nullable=True)
    module_level = Column(Enum(t_lesson_level), nullable=False)
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True)

    def __repr__(self):
       return self.title

 ### 


class Person(Model):
    __tablename__ = "person"
    # __table_args__ = ( ) # tuple
    __doc__ = """extends the User table for Role based access control etc [ref; - User.id]"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    first_name = Column(String, nullable=True)
    middle_name = Column(String, nullable=True)
    family_name = Column(String, nullable=True)
    nick_name = Column(String, nullable=True)
    display_name = Column(String, nullable=True)
    person_role = Column(Enum(t_person_role), nullable=False)
    photo_url = Column(String, nullable=True)
    linkedin_Url = Column(String, nullable=True)
    avatar_Url = Column(String, nullable=True)
    mob_phone_no = Column(String, nullable=True)
    address_line_1 = Column(String, nullable=True)
    address_line_2 = Column(String, nullable=True)
    city = Column(String, nullable=True)
    state = Column(String, nullable=True)
    join_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    join_status = Column(Enum(t_transaction_status), nullable=False)

    def __repr__(self):
       return self.display_name

 ### 


class Pest(Model):
    __tablename__ = "pest"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each pest""")
    pest_name = Column(Text, nullable=True
		, comment="""Common name of the pest""")
    scientific_name = Column(Text, nullable=True
		, comment="""Binomial nomenclature of the pest""")
    family_name = Column(Text, nullable=True
		, comment="""Taxonomic family the pest belongs to""")
    genus = Column(Text, nullable=True
		, comment="""Genus of the pest""")
    species = Column(Text, nullable=True
		, comment="""Specific species of the pest within the genus""")
    pest_signature = Column(Text, nullable=True
		, comment="""AI-driven identifier for the pest""")
    lifecycle = Column(Text, nullable=True
		, comment="""Description of the pest’s lifecycle stages""")
    habitat = Column(Text, nullable=True
		, comment="""Preferred habitats of the pest""")
    common_regions = Column(Text, nullable=True
		, comment="""Regions where the pest is commonly found""")
    primary_diet = Column(Text, nullable=True
		, comment="""Primary food sources of the pest""")
    natural_predators = Column(Text, nullable=True
		, comment="""Natural predators of the pest""")
    economic_impact = Column(Text, nullable=True
		, comment="""Economic impact due to damages caused by the pest""")
    control_methods = Column(Text, nullable=True
		, comment="""Commonly used methods to control the pest""")
    known_resistances = Column(Text, nullable=True
		, comment="""Any known resistances, e.g., to certain pesticides""")
    impact_on_crops = Column(Text, nullable=True
		, comment="""Impact of the pest on agricultural crops""")
    reproduction_rate = Column(Integer, nullable=True
		, comment="""Average reproduction rate of the pest""")
    image_url = Column(String, nullable=True
		, comment="""URL of the pest image for visual identification""")

    def __repr__(self):
       return self.pest_name

 ### 


class ProductClass(Model):
    __tablename__ = "product_class"
    # __table_args__ = ( ) # tuple
    __doc__ = """
      UNSPSC (United Nations Standard Products and Services Code)
      UNSPSC uses a hierarchical classification where:
      Segment > Family > Class > Commodity
  """
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each record in the product_class table.""")
    segment_code = Column(Numeric, nullable=True
		, comment="""The highest level of the UNSPSC classification. It represents a general industry sector.""")
    segment_name = Column(String, nullable=True
		, comment="""The descriptive name for the segment code.""")
    family_code = Column(Numeric, nullable=True
		, comment="""Subdivision of a segment. Represents a more specific product or service category within the segment.""")
    family_name = Column(String, nullable=True
		, comment="""The descriptive name for the family code.""")
    class_code = Column(Numeric, nullable=True
		, comment="""Subdivision of a family. Represents even more specific categories within the family.""")
    class_name = Column(String, nullable=True
		, comment="""The descriptive name for the class code.""")
    commodity_code = Column(Numeric, nullable=True
		, comment="""The lowest level of UNSPSC classification. Represents the most detailed specification of products or services.""")
    commodity_name = Column(String, nullable=True
		, comment="""The descriptive name for the commodity code.""")

    def __repr__(self):
       return self.segment_name

 ### 


class SpatialRefSys(Model):
    __tablename__ = "spatial_ref_sys"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    srid = Column(Integer, primary_key=True)
    auth_name = Column(String, nullable=True)
    auth_srid = Column(Integer, nullable=True)
    srtext = Column(String, nullable=True)
    proj4text = Column(String, nullable=True)
    CheckConstraint('srid > 0 AND srid <= 998999', name='spatial_ref_sys_srid_check')

    def __repr__(self):
       return self.auth_name

 ### 


class Topology(Model):
    __tablename__ = "topology"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String)
    srid = Column(Integer)
    precision = Column(Float)
    hasz = Column(Boolean, default=False)

    def __repr__(self):
       return self.name

 ### 


class UsGaz(Model):
    __tablename__ = "us_gaz"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    seq = Column(Integer, nullable=True)
    word = Column(Text, nullable=True)
    stdword = Column(Text, nullable=True)
    token = Column(Integer, nullable=True)
    is_custom = Column(Boolean, default=True)

    def __repr__(self):
       return self.id

 ### 


class UsLex(Model):
    __tablename__ = "us_lex"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    seq = Column(Integer, nullable=True)
    word = Column(Text, nullable=True)
    stdword = Column(Text, nullable=True)
    token = Column(Integer, nullable=True)
    is_custom = Column(Boolean, default=True)

    def __repr__(self):
       return self.id

 ### 


class UsRules(Model):
    __tablename__ = "us_rules"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    rule = Column(Text, nullable=True)
    is_custom = Column(Boolean, default=True)

    def __repr__(self):
       return self.id

 ### 


class PersonLearner(Model):
    __tablename__ = "Person_Learner"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    learning_style = Column(String, nullable=True)
    strengths = Column(Text, nullable=True)
    weaknesses = Column(Text, nullable=True)
    person = relationship(Person, backref='Person_Learners_person', primaryjoin='PersonLearner.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Alternatename(Model):
    __tablename__ = "alternatename"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True
		, comment="""Unique identifier for each alternate name entry""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Reference to the geoname table; denotes which location this alternate name pertains to""")
    isolanguage = Column(String, nullable=True
		, comment="""ISO language code denoting the language of this alternate name, e.g., en for English""")
    alternatename = Column(String, nullable=True
		, comment="""The alternate name itself in the specified language""")
    ispreferredname = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this is the preferred name in the associated language""")
    isshortname = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this name is a short version or abbreviation""")
    iscolloquial = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this name is colloquial or informal""")
    ishistoric = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this name is historic and no longer widely in use""")
    name_from = Column(String, nullable=True
		, comment="""Used for transliterations; the script or system from which the name was derived""")
    name_to = Column(String, nullable=True
		, comment="""Used for transliterations; the script or system to which the name was translated""")
    geo = relationship(Geoname, backref='alternatenames_geo', primaryjoin='Alternatename.geo_id_fk == Geoname.id')

    def __repr__(self):
       return self.alternatename

 ### 


class Country(Model):
    __tablename__ = "country"
    # __table_args__ = ( ) # tuple
    __doc__ = """Country Data needs expansion"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    iso_alpha2 = Column(String
		, comment="""2-letter ISO 3166-1 alpha code e.g., US for the United States""")
    iso_alpha3 = Column(String
		, comment="""3-letter ISO 3166-1 alpha code e.g., USA for the United States""")
    iso_numeric = Column(Integer, nullable=True
		, comment="""ISO 3166-1 numeric code e.g., 840 for the United States""")
    fips_code = Column(String, nullable=True
		, comment="""Federal Information Processing Standard code, used by the US government""")
    name = Column(String, nullable=True
		, comment="""Full name of the country""")
    capital = Column(String, nullable=True
		, comment="""Capital city of the country""")
    areainsqkm = Column(Float, nullable=True
		, comment="""Total area of the country in square kilometers""")
    population = Column(Integer, nullable=True
		, comment="""Estimated population of the country""")
    continent = Column(String, nullable=True
		, comment="""Abbreviation of the continent the country is located in""")
    tld = Column(String, nullable=True
		, comment="""Top Level Domain for the country e.g., .us for the United States""")
    currencycode = Column(String, nullable=True
		, comment="""ISO code of the country’s currency e.g., USD for US Dollar""")
    currencyname = Column(String, nullable=True
		, comment="""Full name of the country’s currency e.g., Dollar for US Dollar""")
    phone = Column(String, nullable=True
		, comment="""Country dialing code e.g., +1 for the United States""")
    postalcode = Column(String, nullable=True
		, comment="""Template or format of postal codes in the country""")
    postalcoderegex = Column(String, nullable=True
		, comment="""Regular expression pattern to validate postal codes""")
    languages = Column(String, nullable=True
		, comment="""Commonly spoken languages in the country, represented as ISO codes""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Reference to geoname table; linking country data with geographical name data""")
    neighbors = Column(String, nullable=True
		, comment="""Neighboring countries, usually represented as ISO codes""")
    equivfipscode = Column(String, nullable=True
		, comment="""Equivalent FIPS code in cases where it might differ from the primary FIPS code""")
    flag = Column(Text, nullable=True
		, comment="""Field to store a link or representation of the country’s flag""")
    geo = relationship(Geoname, backref='countrys_geo', primaryjoin='Country.geo_id_fk == Geoname.id')

    def __repr__(self):
       return self.name

 ### 


class CropDiseaseLink(Model):
    __tablename__ = "crop_disease_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each crop-disease association""")
    crop_id_fk = Column(Integer, ForeignKey('crop.id')
		, comment="""Reference to the affected crop""")
    disease_id_fk = Column(Integer, ForeignKey('disease.id')
		, comment="""Reference to the disease affecting the crop""")
    presentation = Column(Text, nullable=True
		, comment="""Initial visible signs and symptoms of the disease on the crop""")
    diagnosis = Column(Text, nullable=True
		, comment="""How to diagnose or confirm the presence of the disease in the crop""")
    test = Column(Text, nullable=True
		, comment="""Specific tests or methods to detect the presence of the disease""")
    remediation = Column(Text, nullable=True
		, comment="""Methods or treatments to remove or control the disease""")
    remedial_efficacy = Column(Text, nullable=True
		, comment="""Effectiveness of the recommended remedial actions""")
    severity = Column(Enum(t_severity_level), nullable=False)
    model_name = Column(String, nullable=True
		, comment="""Name of the AI/ML model used for diagnosis""")
    model_version = Column(String, nullable=True
		, comment="""Version of the AI/ML model used""")
    dataset_reference = Column(String, nullable=True
		, comment="""Reference to the dataset used to train/test the model""")
    detection_threshold = Column(Float, nullable=True
		, comment="""Threshold value above which disease presence is confirmed""")
    image_sample_url = Column(String, nullable=True
		, comment="""URL for sample images which can be used for detection reference""")
    model_accuracy = Column(Float, nullable=True
		, comment="""Accuracy of the model on a validation/test dataset""")
    last_model_training_date = Column(Date, nullable=True
		, comment="""Date when the model was last trained""")
    model_description = Column(Text, nullable=True
		, comment="""Description or notes about the model, its architecture, training data, etc.""")
    crop = relationship(Crop, backref='crop_disease_links_crop', primaryjoin='CropDiseaseLink.crop_id_fk == Crop.id')
    disease = relationship(Disease, backref='crop_disease_links_disease', primaryjoin='CropDiseaseLink.disease_id_fk == Disease.id')

    def __repr__(self):
       return self.model_name

 ### 


class CropPestLink(Model):
    __tablename__ = "crop_pest_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each crop-pest association""")
    crop_id_fk = Column(Integer, ForeignKey('crop.id')
		, comment="""Reference to the affected crop""")
    pest_id_fk = Column(Integer, ForeignKey('pest.id')
		, comment="""Reference to the pest causing harm""")
    presentation = Column(Text, nullable=True
		, comment="""Initial visible signs and symptoms of pest damage on the crop""")
    diagnosis = Column(Text, nullable=True
		, comment="""How to diagnose or confirm the presence of the pest in the crop""")
    test = Column(Text, nullable=True
		, comment="""Specific tests or methods to detect the presence of the pest""")
    remediation = Column(Text, nullable=True
		, comment="""Methods or treatments to remove or control the pest""")
    remedial_efficacy = Column(Text, nullable=True
		, comment="""Effectiveness of the recommended remedial actions""")
    severity = Column(Enum(t_severity_level), nullable=False)
    model_name = Column(String, nullable=True
		, comment="""Name of the AI/ML model used for diagnosis""")
    model_version = Column(String, nullable=True
		, comment="""Version of the AI/ML model used""")
    dataset_reference = Column(String, nullable=True
		, comment="""Reference to the dataset used to train/test the model""")
    detection_threshold = Column(Float, nullable=True
		, comment="""Threshold value above which pest presence is confirmed""")
    image_sample_url = Column(String, nullable=True
		, comment="""URL for sample images which can be used for detection reference""")
    model_accuracy = Column(Float, nullable=True
		, comment="""Accuracy of the model on a validation/test dataset""")
    last_model_training_date = Column(Date, nullable=True
		, comment="""Date when the model was last trained""")
    model_description = Column(Text, nullable=True
		, comment="""Description or notes about the model, its architecture, training data, etc.""")
    crop = relationship(Crop, backref='crop_pest_links_crop', primaryjoin='CropPestLink.crop_id_fk == Crop.id')
    pest = relationship(Pest, backref='crop_pest_links_pest', primaryjoin='CropPestLink.pest_id_fk == Pest.id')

    def __repr__(self):
       return self.model_name

 ### 


class CropVariety(Model):
    __tablename__ = "crop_variety"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    crop_id_fk = Column(Integer, ForeignKey('crop.id')
		, comment="""Reference to the generic crop type""")
    variety_name = Column(Text, nullable=True
		, comment="""Specific name of the crop variety""")
    optimal_soil_ph = Column(Float, nullable=True
		, comment="""Optimal soil pH for this variety""")
    optimal_nitrogen_level = Column(Float, nullable=True
		, comment="""Optimal nitrogen level in the soil""")
    optimal_phosphorus_level = Column(Float, nullable=True
		, comment="""Optimal phosphorus level in the soil""")
    optimal_potassium_level = Column(Float, nullable=True
		, comment="""Optimal potassium level in the soil""")
    optimal_temperature_range = Column(Text, nullable=True
		, comment="""Optimal temperature range for growth""")
    is_gmo = Column(Boolean, nullable=True
		, comment="""Indicates whether the variety is Genetically Modified""")
    seed_price = Column(Numeric, nullable=True
		, comment="""Price of the seed per unit weight/volume""")
    drought_tolerance = Column(Enum(t_severity_level), nullable=False)
    drought_tolerance_notes = Column(Text, nullable=True)
    salinity_tolerance = Column(Enum(t_severity_level), nullable=False)
    herbicide_tolerance = Column(Enum(t_severity_level), nullable=False)
    yield_shape = Column(Text, nullable=True
		, comment="""Shape characteristics of the yield (e.g., round, oblong)""")
    yield_size = Column(Text, nullable=True
		, comment="""Size characteristics of the yield (e.g., small, medium, large)""")
    yield_color = Column(Text, nullable=True
		, comment="""Color of the mature yield""")
    yield_taste = Column(Text, nullable=True
		, comment="""Taste characteristics of the yield (e.g., sweet, bitter)""")
    yield_texture = Column(Text, nullable=True
		, comment="""Texture of the yield (e.g., crunchy, soft)""")
    average_yield_per_plant = Column(Float, nullable=True
		, comment="""Average yield per plant in kg""")
    storage_life = Column(Integer, nullable=True
		, comment="""Storage life of the yield in days""")
    growth_duration = Column(Integer, nullable=True
		, comment="""Average growth duration in days""")
    climate_adaptation = Column(Text, nullable=True
		, comment="""Climatic zones where the variety is best suited""")
    altitude_range = Column(Text, nullable=True
		, comment="""Altitude range where the variety can grow optimally""")
    water_requirement = Column(Float, nullable=True
		, comment="""Average water requirement in mm per season""")
    improvement_history = Column(Text, nullable=True
		, comment="""Description of improvements made to this variety over time""")
    commercial_availability = Column(Boolean, nullable=True
		, comment="""Indicates whether the variety is commercially available""")
    frost_tolerance = Column(Boolean, nullable=True
		, comment="""Indicates if the variety is frost-tolerant""")
    salt_tolerance = Column(Boolean, nullable=True
		, comment="""Indicates if the variety is salt-tolerant""")
    high_nutritional_value = Column(Boolean, nullable=True
		, comment="""Indicates if the variety has a high nutritional value""")
    long_shelf_life = Column(Boolean, nullable=True
		, comment="""Indicates if the variety has a long shelf life""")
    low_thorniness = Column(Boolean, nullable=True
		, comment="""Indicates if the variety has low thorniness for easy handling""")
    color = Column(Text, nullable=True
		, comment="""Color of the mature crop or its edible part""")
    taste_profile = Column(Text, nullable=True
		, comment="""Taste profile like sweet, sour, etc.""")
    seedless = Column(Boolean, nullable=True
		, comment="""Indicates if the variety is seedless""")
    pollination_method = Column(Text, nullable=True
		, comment="""Method of pollination, e.g., self, wind, insect""")
    crop = relationship(Crop, backref='crop_varietys_crop', primaryjoin='CropVariety.crop_id_fk == Crop.id')

    def __repr__(self):
       return self.variety_name

 ### 


class Herd(Model):
    __tablename__ = "herd"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each herd""")
    name = Column(String, nullable=True
		, comment="""Name or designation for the herd. Useful for management purposes.""")
    herder_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Reference to the primary herder or caretaker of the herd.""")
    herd_notes = Column(Text, nullable=True
		, comment="""Any additional information or details about the herd, its history, or management practices.""")
    herd_size = Column(Integer, nullable=True
		, comment="""Total number of livestock in the herd. Useful for quick reference.""")
    dominant_species = Column(Enum(t_animal_type), nullable=False)
    last_location_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Last known location or grazing area of the herd. Useful for tracking movements.""")
    movement_frequency = Column(String, nullable=True
		, comment="""How often the herd typically moves, e.g.,  daily , weekly, seasonally.""")
    last_health_check = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date of the last general health check for the herd.""")
    common_feed = Column(Text, nullable=True
		, comment="""What the herd primarily feeds on, e.g., grass, hay, supplements.""")
    water_source = Column(String, nullable=True
		, comment="""Primary water source for the herd, e.g., river, well, tank.""")
    breeding_status = Column(String, nullable=True
		, comment="""Whether the herd is being used for breeding purposes.""")
    tags = Column(Text, nullable=True
		, comment="""Tags to categorize or label the herd, e.g., dairy, beef, organic.""")
    herder = relationship(Person, backref='herds_herder', primaryjoin='Herd.herder_id_fk == Person.id')
    last_location = relationship(Geoname, backref='herds_last_location', primaryjoin='Herd.last_location_id_fk == Geoname.id')

    def __repr__(self):
       return self.name

 ### 


class IsicDivision(Model):
    __tablename__ = "isic_division"
    # __table_args__ = ( ) # tuple
    __doc__ = """ISIC Divisions are nested within ISIC Sections and represent the second level in the hierarchy."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    division_id = Column(String, nullable=True
		, comment="""Unique identifier for each ISIC division.""")
    section_id_fk = Column(Integer, ForeignKey('isic_section.id'), nullable=True
		, comment="""Reference to the parent ISIC section.""")
    division_name = Column(String, nullable=True
		, comment="""Name or description of the ISIC division.""")
    section = relationship(IsicSection, backref='isic_divisions_section', primaryjoin='IsicDivision.section_id_fk == IsicSection.id')

    def __repr__(self):
       return self.division_name

 ### 


class Layer(Model):
    __tablename__ = "layer"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    topology_id = Column(Integer, ForeignKey('topology.id'), primary_key=True)
    layer_id = Column(Integer, primary_key=True)
    schema_name = Column(String)
    table_name = Column(String)
    feature_column = Column(String)
    feature_type = Column(Integer)
    level = Column(Integer)
    child_id = Column(Integer, nullable=True)
    topology = relationship(Topology, backref='layers_topology', primaryjoin='Layer.topology_id == Topology.id')

    def __repr__(self):
       return self.schema_name

 ### 


class Leaderboard(Model):
    __tablename__ = "leaderboard"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    total_points = Column(Integer, nullable=True)
    last_updated = Column(DateTime, server_default=text('NOW()'), nullable=True)
    rank = Column(Integer, nullable=True)
    person = relationship(Person, backref='leaderboards_person', primaryjoin='Leaderboard.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class LearningPath(Model):
    __tablename__ = "learning_path"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    name = Column(String)
    person = relationship(Person, backref='learning_paths_person', primaryjoin='LearningPath.person_id_fk == Person.id')

    def __repr__(self):
       return self.name

 ### 


class Lesson(Model):
    __tablename__ = "lesson"
    # __table_args__ = ( ) # tuple
    __doc__ = """A lessons may have multiple pieces of content e.g text + image"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    module_id_fk = Column(Integer, ForeignKey('module.id'))
    language_id_fk = Column(Integer, ForeignKey('languagecodes.id'), nullable=True)
    title = Column(String)
    description = Column(Text, nullable=True)
    layout = Column(Text, nullable=True
		, comment="""possibly  html to organize the pieces of content""")
    order_in_module = Column(Integer
		, comment="""Order of this lesson within the module""")
    lesson_level = Column(Enum(t_lesson_level), nullable=False)
    language = relationship(Languagecodes, backref='lessons_language', primaryjoin='Lesson.language_id_fk == Languagecodes.id')
    module = relationship(Module, backref='lessons_module', primaryjoin='Lesson.module_id_fk == Module.id')

    def __repr__(self):
       return self.title

 ### 


class LoanTransactionRule(Model):
    __tablename__ = "loan_transaction_rule"
    # __table_args__ = ( ) # tuple
    __doc__ = """Table for individual rules that make up a loan transaction strategy"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key, auto-incremented""")
    strategy_id_fk = Column(BigInteger, ForeignKey('loan_transaction_strategy.id')
		, comment="""Foreign Key linking to the loan_transaction_strategy table""")
    rule_order = Column(Integer
		, comment="""Order in which this rule is to be applied within the strategy""")
    rule_type = Column(Enum(t_amortization_method), nullable=False)
    amount_percentage = Column(Float, nullable=True
		, comment="""Percentage of payment amount to apply for this rule""")
    min_amount = Column(Numeric, nullable=True
		, comment="""Minimum amount to apply in specific currency, if applicable""")
    max_amount = Column(Numeric, nullable=True
		, comment="""Maximum amount to apply in specific currency, if applicable""")
    note = Column(Text, nullable=True)
    strategy = relationship(LoanTransactionStrategy, backref='loan_transaction_rules_strategy', primaryjoin='LoanTransactionRule.strategy_id_fk == LoanTransactionStrategy.id')

    def __repr__(self):
       return self.id

 ### 


class PersonAdminData(Model):
    __tablename__ = "person_admin_data"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'))
    creation_time = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    failed_login_count = Column(Integer, nullable=True)
    failed_login_timestamp = Column(DateTime, server_default=text('NOW()'), nullable=True)
    password_last_set_time = Column(DateTime, server_default=text('NOW()'), nullable=True)
    profile_picture = Column(String, nullable=True)
    awatar = Column(String, nullable=True)
    screen_name = Column(String, nullable=True)
    user_priv_cert = Column(Text, nullable=True)
    user_pub_cert = Column(Text, nullable=True)
    alt_security_identities = Column(Text, nullable=True)
    generated_UID = Column(UUID, nullable=True)
    do_not_email = Column(Boolean, default=False, nullable=True)
    do_not_phone = Column(Boolean, default=False, nullable=True)
    do_not_mail = Column(Boolean, default=False, nullable=True)
    do_not_sms = Column(Boolean, default=False, nullable=True)
    do_not_trade = Column(Boolean, default=False, nullable=True)
    opted_out = Column(Boolean, default=False, nullable=True)
    do_not_track_update_date = Column(Date, nullable=True)
    do_not_process_from_update_date = Column(Date, nullable=True)
    do_not_market_from_update_date = Column(Date, nullable=True)
    do_not_track_location_update_date = Column(Date, nullable=True)
    do_not_profile_from_update_date = Column(Date, nullable=True)
    do_forget_me_from_update_date = Column(Date, nullable=True)
    do_not_process_reason = Column(String, nullable=True)
    no_merge_reason = Column(String, nullable=True)
    do_extract_my_data_update_date = Column(Date, nullable=True)
    should_forget = Column(Boolean, nullable=True)
    consumer_credit_score_provider_name = Column(String, nullable=True)
    web_site_url = Column(String, nullable=True)
    ordering_name = Column(String, nullable=True)
    hospitalizations_last5_years_count = Column(Integer, nullable=True)
    surgeries_last5_years_count = Column(Integer, nullable=True)
    dependent_count = Column(Integer, nullable=True)
    account_locked = Column(Boolean, default=False, nullable=True)
    send_individual_data = Column(Boolean, nullable=True)
    influencer_rating = Column(Integer, nullable=True)
    person = relationship(Person, backref='person_admin_datas_person', primaryjoin='PersonAdminData.person_id_fk == Person.id')

    def __repr__(self):
       return self.screen_name

 ### 


class PersonBadges(Model):
    __tablename__ = "person_badges"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    badge_id_fk = Column(Integer, ForeignKey('badge.id'), nullable=True)
    date_earned = Column(DateTime, server_default=text('NOW()'), nullable=True)
    badge = relationship(Badge, backref='person_badgess_badge', primaryjoin='PersonBadges.badge_id_fk == Badge.id')
    person = relationship(Person, backref='person_badgess_person', primaryjoin='PersonBadges.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonEducation(Model):
    __tablename__ = "person_education"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the education record""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Foreign key referencing the person associated with this education record""")
    ed_level = Column(String, nullable=True
		, comment="""Educational level e.g., Primary, Secondary, Bachelor’s, Master’s, etc.""")
    field_of_study = Column(String, nullable=True
		, comment="""Field or major of study, relevant for higher education""")
    attainment = Column(String, nullable=True
		, comment="""Specific degree, certification, or grade attained""")
    started_on = Column(Date, nullable=True
		, comment="""Date when the person started this educational program""")
    graduated_on = Column(Date, nullable=True
		, comment="""Date when the person graduated or completed this program""")
    institution_name = Column(String, nullable=True
		, comment="""Name of the educational institution""")
    institution_type = Column(String, nullable=True
		, comment="""Type of the institution e.g., School, University, College, etc.""")
    institution_accreditation = Column(String, nullable=True
		, comment="""Accreditation body or standard, if applicable""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Foreign key referencing the location of the educational institution""")
    institution_website = Column(String, nullable=True
		, comment="""Website or link to the institution’s portal""")
    gpa = Column(Float, nullable=True
		, comment="""Grade Point Average or its equivalent, if applicable""")
    standardized_test_scores = Column(String, nullable=True
		, comment="""Standardized test scores, e.g., SAT, GCSE results""")
    house_section = Column(String, nullable=True
		, comment="""House or section in the school, common in many primary and secondary institutions""")
    class_rank = Column(Integer, nullable=True
		, comment="""Position or rank in class, if available""")
    honors = Column(String, nullable=True
		, comment="""Honors received upon graduation""")
    extracurricular_activities = Column(Text, nullable=True
		, comment="""Extracurricular activities or clubs the person was involved in""")
    sports_activities = Column(Text, nullable=True
		, comment="""Sports or athletic activities participated in""")
    scholarship_awarded = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the person received any scholarship""")
    scholarship_detail = Column(Text, nullable=True
		, comment="""Details about the scholarship if it was awarded""")
    school_projects = Column(Text, nullable=True
		, comment="""Details about significant school projects or assignments""")
    notable_achievements = Column(Text, nullable=True
		, comment="""Any notable achievements or awards received during this educational period""")
    thesis_title = Column(String, nullable=True
		, comment="""Title of the thesis or dissertation, if applicable""")
    thesis_abstract = Column(Text, nullable=True
		, comment="""Brief summary or abstract of the thesis or dissertation, if applicable""")
    mentors_advisors = Column(String, nullable=True
		, comment="""Names of mentors, advisors, or favorite teachers during this education""")
    is_current = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this is the person’s current educational program""")
    documents = Column(Text, nullable=True
		, comment="""Attachments or documents like report cards, certificates, etc.""")
    geo = relationship(Geoname, backref='person_educations_geo', primaryjoin='PersonEducation.geo_id_fk == Geoname.id')
    person = relationship(Person, backref='person_educations_person', primaryjoin='PersonEducation.person_id_fk == Person.id')

    def __repr__(self):
       return self.institution_name

 ### 


class PersonHousehold(Model):
    __tablename__ = "person_household"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    marital_status = Column(String, nullable=True)
    wedding_anniversary_date = Column(Date, nullable=True)
    children_count = Column(Integer, nullable=True)
    household_member_count = Column(Integer, nullable=True)
    household_formed_date = Column(Date, nullable=True)
    household_dissolved_date = Column(Date, nullable=True)
    party_type = Column(String)
    global_party = Column(String, nullable=True)
    no_merge_reason = Column(String, nullable=True)
    person = relationship(Person, backref='person_households_person', primaryjoin='PersonHousehold.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonLanguage(Model):
    __tablename__ = "person_language"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the language-proficiency record of a person.""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Reference to the individual associated with this language proficiency.""")
    language_id_fk = Column(Integer, ForeignKey('languagecodes.id'), nullable=True
		, comment="""ISO 639-3 code representing the language.""")
    listening_proficiency_level = Column(Enum(t_language_proficiency_level), nullable=False)
    spoken_proficiency_level = Column(Enum(t_language_proficiency_level), nullable=False)
    written_proficiency_level = Column(Enum(t_language_proficiency_level), nullable=False)
    language = relationship(Languagecodes, backref='person_languages_language', primaryjoin='PersonLanguage.language_id_fk == Languagecodes.id')
    person = relationship(Person, backref='person_languages_person', primaryjoin='PersonLanguage.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonLevel(Model):
    __tablename__ = "person_level"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    level = Column(Integer, nullable=True)
    points_required_for_next_level = Column(Integer, nullable=True
		, comment="""Points needed to level up""")
    person = relationship(Person, backref='person_levels_person', primaryjoin='PersonLevel.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonLifeEvent(Model):
    __tablename__ = "person_life_event"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the life event record""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Foreign key referencing the person associated with this life event""")
    event_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Date and time when the event occurred""")
    event_type = Column(String
		, comment="""Type or category of the life event e.g., Birth, Marriage, Graduation, etc.""")
    event_description = Column(Text, nullable=True
		, comment="""Detailed description of the event""")
    location = Column(String, nullable=True
		, comment="""Location where the event took place""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Foreign key referencing the geographical location of the event""")
    involved_parties = Column(Text, nullable=True
		, comment="""Names or list of other individuals involved or present during the event""")
    witnesses = Column(Text, nullable=True
		, comment="""Names or list of witnesses, if any, especially relevant for legal or ceremonial events""")
    event_photos_url = Column(Text, nullable=True
		, comment="""Photos or images associated with the event""")
    event_documents_url = Column(Text, nullable=True
		, comment="""Relevant documents or certificates associated with the event""")
    event_details = Column(Text, nullable=True
		, comment="""Details of any celebration or function associated with the event""")
    gifts_received = Column(Text, nullable=True
		, comment="""Details of gifts or presents received during the event, if applicable""")
    emotions_felt = Column(Text, nullable=True
		, comment="""Emotions or feelings associated with the event, as described by the person""")
    life_impact = Column(String, nullable=True
		, comment="""Significance or impact of the event on the person’s life, if any""")
    immediate_aftermath = Column(Text, nullable=True
		, comment="""Events or actions that immediately followed the life event""")
    is_public = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if the event details can be shared or are private""")
    added_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Person or user who added this event record, if different from the primary person""")
    added_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Date and time when the record was added to the system""")
    added_by = relationship(Person, backref='person_life_events_added_by', primaryjoin='PersonLifeEvent.added_by_id_fk == Person.id')
    geo = relationship(Geoname, backref='person_life_events_geo', primaryjoin='PersonLifeEvent.geo_id_fk == Geoname.id')
    person = relationship(Person, backref='person_life_events_person', primaryjoin='PersonLifeEvent.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonLocationLog(Model):
    __tablename__ = "person_location_log"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each location log entry""")
    person_id_fk = Column(Integer, ForeignKey('person.id')
		, comment="""Foreign key referencing the associated person""")
    logged_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Date and time when this location data was added or logged into the system""")
    location_source = Column(String, nullable=True
		, comment="""Source of the geolocation data e.g., GPS, WiFi, Manual""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Foreign key referencing the location from the geonames table, if applicable""")
    latitude = Column(Float, nullable=True
		, comment="""Latitude coordinate of the person’s location""")
    longitude = Column(Float, nullable=True
		, comment="""Longitude coordinate of the person’s location""")
    altitude = Column(Float, nullable=True
		, comment="""Altitude of the location, if available from the geolocation source""")
    direction = Column(Float, nullable=True
		, comment="""Direction of movement in degrees""")
    speed = Column(Float, nullable=True
		, comment="""Speed of the person at the time of logging, relevant if they were in a vehicle or moving fast""")
    rate_of_climb = Column(Float, nullable=True
		, comment="""Rate at which altitude is changing""")
    geo_accuracy = Column(Integer, nullable=True
		, comment="""Accuracy of the geolocation data""")
    notes = Column(Text, nullable=True
		, comment="""Any additional information or context about the location log""")
    alerted = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the person triggered an alert or SOS from this location""")
    device_id = Column(String, nullable=True
		, comment="""Unique ID or identifier of the device used for logging the location""")
    device_brand = Column(String, nullable=True
		, comment="""Brand of the device, e.g., Apple, Samsung, etc.""")
    device_model = Column(String, nullable=True
		, comment="""Specific model of the device, e.g., iPhone 12, Galaxy S21, etc.""")
    os_name = Column(String, nullable=True
		, comment="""Operating system name, e.g., iOS, Android, etc.""")
    os_version = Column(String, nullable=True
		, comment="""Version of the devices operating system""")
    app_version = Column(String, nullable=True
		, comment="""Version of the app used to log the location, if applicable""")
    battery_level = Column(Float, nullable=True
		, comment="""Battery level of the device at the time of logging, usually a value between 0 and 1 representing the percentage""")
    network_type = Column(String, nullable=True
		, comment="""Type of network used during logging, e.g., WiFi, 4G, 5G, etc.""")
    signal_strength = Column(Integer, nullable=True
		, comment="""Signal strength of the network, can be in dBm or ASU""")
    device_orientation = Column(String, nullable=True
		, comment="""Orientation of the device when the log was captured, e.g., Portrait, Landscape, etc.""")
    gps_provider = Column(String, nullable=True
		, comment="""GPS provider if there are multiple providers, e.g., internal, external, network-based""")
    satellite_count = Column(Integer, nullable=True
		, comment="""Number of satellites the device was connected to, if applicable""")
    geo = relationship(Geoname, backref='person_location_logs_geo', primaryjoin='PersonLocationLog.geo_id_fk == Geoname.id')
    person = relationship(Person, backref='person_location_logs_person', primaryjoin='PersonLocationLog.person_id_fk == Person.id')

    def __repr__(self):
       return self.device_model

 ### 


class PersonRelationshipsLink(Model):
    __tablename__ = "person_relationships_link"
    # __table_args__ = ( ) # tuple
    __doc__ = """CHECK (person_id != relative_id)"""
    # class_permission_name = "view"
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True)
    relative_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True)
    relationship_type = Column(Enum(t_relationship_type), nullable=False)
    related_from_date = Column(Date, nullable=True)
    related_to_date = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    is_bidirectional = Column(Boolean, default=False, nullable=True)
    near_relation = Column(Boolean, nullable=True)
    far_relation = Column(Boolean, nullable=True)
    person = relationship(Person, backref='person_relationships_links_person', primaryjoin='PersonRelationshipsLink.person_id_fk == Person.id')
    relative = relationship(Person, backref='person_relationships_links_relative', primaryjoin='PersonRelationshipsLink.relative_id_fk == Person.id')

    def __repr__(self):
       return self.person_id_fk

 ### 


class PersonTodo(Model):
    __tablename__ = "person_todo"
    # __table_args__ = ( ) # tuple
    __doc__ = """ We can hierarchies of todos to allow decomposition a la https://goblin.tools/"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id')
		, comment="""Link to the person the task is associated with""")
    parent_todo_id_fk = Column(Integer, ForeignKey('person_todo.id'), nullable=True)
    title = Column(String
		, comment="""Title or brief description of the task""")
    description = Column(Text, nullable=True
		, comment="""Detailed description of the task""")
    due_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Due date for the task""")
    priority_level = Column(Enum(t_severity_level), nullable=False)
    status = Column(Enum(t_transaction_status), nullable=False)
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Time the task was created""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Time the task was last updated""")
    completed_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Time the task was completed""")
    assigned_to_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Person responsible for the task. Can be the same as the associated person or another individual.""")
    geofence_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Link to the geofenced area""")
    geofence_trigger = Column(Enum(t_geofence_trigger), nullable=False)
    assigned_to = relationship(Person, backref='person_todos_assigned_to', primaryjoin='PersonTodo.assigned_to_id_fk == Person.id')
    geofence = relationship(Geoname, backref='person_todos_geofence', primaryjoin='PersonTodo.geofence_id_fk == Geoname.id')
    parent_todo = relationship('PersonTodo', backref='person_todos_parent_todo', primaryjoin='PersonTodo.parent_todo_id_fk == PersonTodo.id', remote_side=[id])
    person = relationship(Person, backref='person_todos_person', primaryjoin='PersonTodo.person_id_fk == Person.id')

    def __repr__(self):
       return self.title

 ### 


class SourceDocument(Model):
    __tablename__ = "source_document"
    # __table_args__ = ( ) # tuple
    __doc__ = """We can use source documents to automatically generate content which will be used in lessons"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each source document""")
    mime_type_id_fk = Column(Integer, ForeignKey('mime_type.id'), nullable=True
		, comment="""MIME type ID referencing the type of the document""")
    language_id_fk = Column(Integer, ForeignKey('languagecodes.id'), nullable=True
		, comment="""ISO 639-3 code representing the language of the document""")
    doc_url = Column(Text, nullable=True
		, comment="""Document thumbnail or preview image""")
    doc_text = Column(Text, nullable=True
		, comment="""Extracted text content from the document""")
    doc_binary_url = Column(Text, nullable=True
		, comment="""Raw binary content of the document""")
    doc_title = Column(String, nullable=True
		, comment="""Title or headline of the document""")
    source_url = Column(String
		, comment="""Direct URL to access or download the original document""")
    subject = Column(String, nullable=True
		, comment="""The primary topic or focus of the document""")
    author = Column(String, nullable=True
		, comment="""Author or creator of the document""")
    keywords = Column(String, nullable=True
		, comment="""List of keywords associated with the document""")
    comments = Column(Text, nullable=True
		, comment="""Additional comments or description about the document""")
    char_count = Column(Integer, nullable=True
		, comment="""Total character count in the document""")
    word_count = Column(Integer, nullable=True
		, comment="""Total word count in the document""")
    lines = Column(Integer, nullable=True
		, comment="""Total line count in the document""")
    paragraphs = Column(Integer, nullable=True
		, comment="""Total paragraph count in the document""")
    gpt_token_count = Column(Integer, nullable=True
		, comment="""Token count as per GPT model parsing""")
    grammar_checked = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document has been checked for grammar""")
    is_summary = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document is a summary""")
    is_spell_checked = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document has been checked for spelling errors""")
    is_rendered = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document has been rendered (e.g., for view or print)""")
    is_image = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document is primarily an image""")
    length = Column(Integer, nullable=True
		, comment="""Length dimension of the document (for images, videos, or pages)""")
    width = Column(Integer, nullable=True
		, comment="""Width dimension of the document (for images, videos, or pages)""")
    doc_prompt = Column(Text, nullable=True
		, comment="""A prompt or description that led to the creation of this document""")
    doc_gpt_ver = Column(String, nullable=True
		, comment="""Version of the GPT model used, if applicable""")
    doc_maj_version = Column(Integer, nullable=True
		, comment="""Major version number of the document""")
    doc_min_version = Column(Integer, nullable=True
		, comment="""Minor version number of the document""")
    doc_downloadable = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document can be downloaded""")
    doc_template = Column(Text, nullable=True
		, comment="""The template used for the document, if any""")
    doc_render_url = Column(Text, nullable=True
		, comment="""Rendered or finalized version of the document for display or print""")
    file_size_bytes = Column(Integer, nullable=True
		, comment="""Size of the document file in bytes""")
    producer_prog = Column(String, nullable=True
		, comment="""Software or tool used to produce the document""")
    is_immutable = Column(Boolean, default=False, nullable=True
		, comment="""Flag indicating if the document should not be modified""")
    page_size = Column(String, nullable=True
		, comment="""Physical size of the pages (e.g., A4, Letter)""")
    page_count = Column(Integer, nullable=True
		, comment="""Total number of pages in the document""")
    hashx = Column(String, nullable=True
		, comment="""A hash value for ensuring the document’s integrity""")
    is_audio = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document contains audio content""")
    is_video = Column(Boolean, nullable=True
		, comment="""Flag indicating if the document contains video content""")
    duration = Column(Integer, nullable=True
		, comment="""Total playback duration for audio or video content in seconds""")
    audio_frame_rate = Column(Integer, nullable=True
		, comment="""Frame rate for audio content, if applicable""")
    audio_channels = Column(Integer, nullable=True
		, comment="""Number of audio channels (e.g., mono, stereo)""")
    uploaded_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Identifier for the person who uploaded the document""")
    accession_on = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp indicating when the document was added to the system""")
    language = relationship(Languagecodes, backref='source_documents_language', primaryjoin='SourceDocument.language_id_fk == Languagecodes.id')
    mime_type = relationship(MimeType, backref='source_documents_mime_type', primaryjoin='SourceDocument.mime_type_id_fk == MimeType.id')
    uploaded_by = relationship(Person, backref='source_documents_uploaded_by', primaryjoin='SourceDocument.uploaded_by_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class UserPoints(Model):
    __tablename__ = "user_points"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    points_earned = Column(Integer, nullable=True)
    reason = Column(String, nullable=True
		, comment="""Reason for earning these points, e.g., Completed Lesson 5""")
    date_earned = Column(DateTime, server_default=text('NOW()'), nullable=True)
    person = relationship(Person, backref='user_pointss_person', primaryjoin='UserPoints.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Admin1codes(Model):
    __tablename__ = "admin1codes"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    code = Column(String, nullable=True
		, comment="""Primary identifier, typically a combination of country code and admin1 code e.g., US.AL for Alabama, United States""")
    countrycode_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="""3-letter ISO 3166-1 alpha code of the country e.g., USA for the United States""")
    admin1_code = Column(String, nullable=True
		, comment="""Unique identifier within a country for this first-level administrative division. E.g., AL for Alabama""")
    name = Column(String, nullable=True
		, comment="""Local name of the administrative division in the official language""")
    alt_name_english = Column(String, nullable=True
		, comment="""Alternative name or translation of the division in English""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Reference to geoname table; linking administrative division data with geographical name data""")
    countrycode = relationship(Country, backref='admin1codess_countrycode', primaryjoin='Admin1codes.countrycode_id_fk == Country.id')
    geo = relationship(Geoname, backref='admin1codess_geo', primaryjoin='Admin1codes.geo_id_fk == Geoname.id')

    def __repr__(self):
       return self.name

 ### 


class Admin2codes(Model):
    __tablename__ = "admin2codes"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    code = Column(String, nullable=True
		, comment="""Primary identifier, typically a combination of country code, admin1 code, and an additional code representing the second-level administrative division e.g., US.AL.001""")
    countrycode_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="""3-letter ISO 3166-1 alpha code of the country this division belongs to e.g., USA for the United States""")
    admin1_code = Column(String, nullable=True
		, comment="""ref: > admin1codes.admin1_code,Reference to the first-level administrative division. E.g., US.AL for Alabama in the United States""")
    name = Column(String, nullable=True
		, comment="""Local name of the second-level administrative division in the official language""")
    alt_name_english = Column(String, nullable=True
		, comment="""Alternative name or translation of the division in English""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Reference to geoname table; linking second-level administrative division data with geographical name data""")
    countrycode = relationship(Country, backref='admin2codess_countrycode', primaryjoin='Admin2codes.countrycode_id_fk == Country.id')
    geo = relationship(Geoname, backref='admin2codess_geo', primaryjoin='Admin2codes.geo_id_fk == Geoname.id')

    def __repr__(self):
       return self.name

 ### 


class AnimalBreed(Model):
    __tablename__ = "animal_breed"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each animal breed""")
    name = Column(String
		, comment="""Name of the animal breed""")
    species = Column(String
		, comment="""Species to which the breed belongs, e.g., cattle, sheep, goat, etc.""")
    origin_country_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="""Country or region of origin for the breed""")
    average_weight = Column(Float, nullable=True
		, comment="""Average mature weight for the breed, usually in kilograms""")
    color_pattern = Column(String, nullable=True
		, comment="""Dominant color or pattern of the breed""")
    temperament = Column(String, nullable=True
		, comment="""General temperament of the breed, e.g., docile, aggressive, etc.""")
    lifespan = Column(Integer, nullable=True
		, comment="""Average lifespan of the breed in years""")
    purpose = Column(String, nullable=True
		, comment="""Primary purpose for which the breed is raised, e.g., meat, milk, wool, work, etc.""")
    distinctive_features = Column(Text, nullable=True
		, comment="""Any unique or distinctive features of the breed""")
    breeding_cycle_days = Column(Integer, nullable=True
		, comment="""Duration of the breeding cycle in days, if applicable""")
    gestation_period_days = Column(Integer, nullable=True
		, comment="""Duration of the gestation period in days""")
    lactation_period_days = Column(Integer, nullable=True
		, comment="""Average duration of lactation period in days, if applicable""")
    average_milk_yield = Column(Float, nullable=True
		, comment="""Average daily milk yield in liters, if applicable""")
    average_offspring_count = Column(Integer, nullable=True
		, comment="""Average number of offspring produced per breeding cycle""")
    weaning_age_days = Column(Integer, nullable=True
		, comment="""Age in days at which offspring are typically weaned""")
    resistance_traits = Column(Text, nullable=True
		, comment="""Any known disease resistance or hardiness traits specific to the breed""")
    climate_adaptability = Column(String, nullable=True
		, comment="""Types of climates the breed is best suited for, e.g., tropical, temperate, etc.""")
    feed_efficiency = Column(Float, nullable=True
		, comment="""Average feed conversion ratio or efficiency""")
    common_ailments = Column(Text, nullable=True
		, comment="""Common diseases or ailments that affect the breed""")
    population_status = Column(String, nullable=True
		, comment="""Status of the breed population, e.g., endangered, stable, etc.""")
    history = Column(Text, nullable=True
		, comment="""Brief history or background of the breed""")
    external_references = Column(Text, nullable=True
		, comment="""Links or references to external sources or further readings about the breed""")
    photo_url = Column(String, nullable=True
		, comment="""Link to a representative photo or image of the breed""")
    origin_country = relationship(Country, backref='animal_breeds_origin_country', primaryjoin='AnimalBreed.origin_country_id_fk == Country.id')

    def __repr__(self):
       return self.name

 ### 


class Content(Model):
    __tablename__ = "content"
    # __table_args__ = ( ) # tuple
    __doc__ = """These are bits of lessons or mdules, generated from source documents"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String)
    mime_type_id_fk = Column(Integer, ForeignKey('mime_type.id'), nullable=True)
    language_id_fk = Column(Integer, ForeignKey('languagecodes.id'), nullable=True)
    source_doc_id_fk = Column(Integer, ForeignKey('source_document.id'), nullable=True)
    doc_text = Column(Text, nullable=True)
    url = Column(String
		, comment="""Link to the actual content (could be a URL, S3 or file path)""")
    description = Column(Text, nullable=True
		, comment="""Brief about the content""")
    difficulty_level = Column(String, nullable=True)
    pre_requisite_content_id_fk = Column(Integer, ForeignKey('content.id'), nullable=True)
    tags = Column(String, nullable=True)
    duration = Column(Integer, nullable=True
		, comment="""Duration in seconds for video/audio content""")
    length = Column(Integer, nullable=True
		, comment="""Byte length of nthe media""")
    uploaded_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who uploaded the content""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    language = relationship(Languagecodes, backref='contents_language', primaryjoin='Content.language_id_fk == Languagecodes.id')
    mime_type = relationship(MimeType, backref='contents_mime_type', primaryjoin='Content.mime_type_id_fk == MimeType.id')
    pre_requisite_content = relationship('Content', backref='contents_pre_requisite_content', primaryjoin='Content.pre_requisite_content_id_fk == Content.id', remote_side=[id])
    source_doc = relationship(SourceDocument, backref='contents_source_doc', primaryjoin='Content.source_doc_id_fk == SourceDocument.id')
    uploaded_by = relationship(Person, backref='contents_uploaded_by', primaryjoin='Content.uploaded_by_id_fk == Person.id')

    def __repr__(self):
       return self.title

 ### 


class IsicGroup(Model):
    __tablename__ = "isic_group"
    # __table_args__ = ( ) # tuple
    __doc__ = """ISIC Groups are nested within ISIC Divisions, representing the third level in the hierarchy."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    group_id = Column(String, nullable=True
		, comment="""Unique identifier for each ISIC group.""")
    division_id_fk = Column(Integer, ForeignKey('isic_division.id'), nullable=True
		, comment="""Reference to the parent ISIC division.""")
    group_name = Column(String, nullable=True
		, comment="""Name or description of the ISIC group.""")
    division = relationship(IsicDivision, backref='isic_groups_division', primaryjoin='IsicGroup.division_id_fk == IsicDivision.id')

    def __repr__(self):
       return self.group_name

 ### 


class LearningPathContent(Model):
    __tablename__ = "learning_path_content"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    learning_path_id_fk = Column(Integer, ForeignKey('learning_path.id'), nullable=True)
    module_id_fk = Column(Integer, ForeignKey('module.id'), nullable=True)
    order_in_path = Column(Integer)
    recommended_completion_date = Column(Date, nullable=True
		, comment="""Date by which the module is recommended to be completed""")
    is_dynamic = Column(Boolean, nullable=True)
    content_recommendations = Column(Text, nullable=True)
    reason_for_recommendation = Column(Text, nullable=True)
    learning_path = relationship(LearningPath, backref='learning_path_contents_learning_path', primaryjoin='LearningPathContent.learning_path_id_fk == LearningPath.id')
    module = relationship(Module, backref='learning_path_contents_module', primaryjoin='LearningPathContent.module_id_fk == Module.id')

    def __repr__(self):
       return self.id

 ### 


class LessonEngagement(Model):
    __tablename__ = "lesson_engagement"
    # __table_args__ = ( ) # tuple
    __doc__ = """How users engaged with specific lessons"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each comment""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Identifier of the user making the comment""")
    lesson_id_fk = Column(Integer, ForeignKey('lesson.id'), nullable=True
		, comment="""Identifier of the content being commented on""")
    engagement_type = Column(Enum(t_engagement_type), nullable=False)
    engagement_value = Column(Integer, nullable=True
		, comment="""Numerical value representing the engagement level. Useful for scoring mechanisms.""")
    engagement_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the engagement occurred""")
    delivered_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the user started viewing the content""")
    start_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the user started viewing the content""")
    end_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the user stopped viewing the content""")
    time_on_lesson = Column(Integer, nullable=True
		, comment="""Duration in seconds calculated as the difference between start_at and end_at""")
    open_delay = Column(Integer, nullable=True
		, comment="""How long between delivering the message and opening the message""")
    completed = Column(Boolean, nullable=True)
    hints_used = Column(Integer, nullable=True)
    comment_text = Column(Text, nullable=True
		, comment="""Text of the comment""")
    comment_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the comment was made""")
    shared_to_platform = Column(Enum(t_share_platform), nullable=False)
    difficulty_feedback = Column(Enum(t_lesson_difficulty_feedback), nullable=False)
    lesson = relationship(Lesson, backref='lesson_engagements_lesson', primaryjoin='LessonEngagement.lesson_id_fk == Lesson.id')
    person = relationship(Person, backref='lesson_engagements_person', primaryjoin='LessonEngagement.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class PersonAdditionalData(Model):
    __tablename__ = "person_additional_data"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True)
    Gender = Column(Enum(t_gender), nullable=False)
    religion = Column(String, nullable=True)
    ethnicity = Column(String, nullable=True)
    consumer_credit_score = Column(Integer, nullable=True)
    is_home_owner = Column(Boolean, nullable=True)
    person_height = Column(Integer, nullable=True)
    person_weight = Column(Integer, nullable=True)
    person_height_unit_of_measure = Column(String, nullable=True)
    person_weight_unit_of_measure = Column(String, nullable=True)
    highest_education_level = Column(String, nullable=True)
    person_life_stage = Column(String, nullable=True)
    mothers_maiden_name = Column(String, nullable=True)
    Marital_Status_cd = Column(Integer, nullable=True)
    Citizenship_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True)
    Poverty_Status = Column(Integer, nullable=True)
    From_whom = Column(String, nullable=True)
    Amount = Column(Numeric, nullable=True)
    Interest_rate_pa = Column(Numeric, nullable=True)
    Number_of_people_depending_on_overal_income = Column(Integer, nullable=True)
    YesNo_cd_Bank_account = Column(Integer, nullable=True)
    YesNo_cd_Business_plan_provided = Column(Integer, nullable=True)
    YesNo_cd_Access_to_internet = Column(Integer, nullable=True)
    Introduced_by = Column(String, nullable=True)
    Known_to_introducer_since = Column(String, nullable=True)
    Last_visited_by = Column(String, nullable=True)
    Last_visited_on = Column(Date)
    Citizenship = relationship(Country, backref='person_additional_datas_Citizenship', primaryjoin='PersonAdditionalData.Citizenship_id_fk == Country.id')
    person = relationship(Person, backref='person_additional_datas_person', primaryjoin='PersonAdditionalData.person_id_fk == Person.id')

    def __repr__(self):
       return self.mothers_maiden_name

 ### 


class Quiz(Model):
    __tablename__ = "quiz"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    lesson_id_fk = Column(Integer, ForeignKey('lesson.id'), nullable=True)
    title = Column(String)
    description = Column(Text, nullable=True)
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    lesson = relationship(Lesson, backref='quizs_lesson', primaryjoin='Quiz.lesson_id_fk == Lesson.id')

    def __repr__(self):
       return self.title

 ### 


class Timezone(Model):
    __tablename__ = "timezone"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    country_code_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True)
    timezonename = Column(String, nullable=True)
    comments = Column(Text, nullable=True)
    country_code = relationship(Country, backref='timezones_country_code', primaryjoin='Timezone.country_code_id_fk == Country.id')

    def __repr__(self):
       return self.timezonename

 ### 


class Animal(Model):
    __tablename__ = "animal"
    # __table_args__ = ( ) # tuple
    __doc__ = """sire_id != dam_id, id != sire_id, id != dam_id"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each animal""")
    owner_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Owner of the animal""")
    name = Column(String, nullable=True
		, comment="""Name or nickname of the animal""")
    animal_type = Column(Enum(t_animal_type), nullable=False)
    breed_id_fk = Column(Integer, ForeignKey('animal_breed.id'), nullable=True
		, comment="""Breed of the animal""")
    dob = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Date of birth of the animal""")
    approx_age_months = Column(Integer, nullable=True
		, comment="""Approximate age of the animal in months, especially if exact dob is unknown""")
    sex = Column(String, nullable=True
		, comment="""Sex of the animal, typically M or F""")
    sire_id_fk = Column(Integer, ForeignKey('animal.id'), nullable=True
		, comment="""Father of the animal, if known""")
    dam_id_fk = Column(Integer, ForeignKey('animal.id'), nullable=True
		, comment="""Mother of the animal, if known""")
    location_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Current or last known location of the animal""")
    has_horns = Column(Boolean, nullable=True
		, comment="""Indicates if the animal has horns""")
    horn_orientation = Column(Text, nullable=True
		, comment="""Describes the orientation of horns e.g., inward, outward, upward, etc.""")
    color = Column(String, nullable=True
		, comment="""Primary color or color pattern of the animal""")
    distinguishing_marks = Column(Text, nullable=True
		, comment="""Any unique marks or patterns that can help in identification""")
    weight_kg = Column(Float, nullable=True
		, comment="""Weight of the animal in kilograms, if available""")
    height_cm = Column(Float, nullable=True
		, comment="""Height of the animal in centimeters, if available""")
    body_length_cm = Column(Float, nullable=True
		, comment="""Length of the animal from nose to tail, in centimeters, if available""")
    ear_tag_number = Column(String, nullable=True
		, comment="""Ear tag number, if available""")
    rfid_tag = Column(String, nullable=True
		, comment="""RFID tag number, if available""")
    health_status = Column(Text, nullable=True
		, comment="""Current or recent health status or remarks""")
    horn_pic = Column(Text, nullable=True
		, comment="""URL to a picture focused on the horns for identification""")
    frontal_pic = Column(Text, nullable=True
		, comment="""URL to a frontal picture of the animal""")
    left_pic = Column(Text, nullable=True
		, comment="""URL to a left-side picture of the animal""")
    right_pic = Column(Text, nullable=True
		, comment="""URL to a right-side picture of the animal""")
    top_pic = Column(Text, nullable=True
		, comment="""URL to a top-view picture of the animal""")
    rear_pic = Column(Text, nullable=True
		, comment="""URL to a rear-view picture of the animal""")
    registration_number = Column(String, nullable=True
		, comment="""Official registration number, if available""")
    insurance_details = Column(Text, nullable=True
		, comment="""Details about animal insurance, if any""")
    breed = relationship(AnimalBreed, backref='animals_breed', primaryjoin='Animal.breed_id_fk == AnimalBreed.id')
    dam = relationship('Animal', backref='animals_dam', primaryjoin='Animal.dam_id_fk == Animal.id', remote_side=[id])
    location = relationship(Geoname, backref='animals_location', primaryjoin='Animal.location_id_fk == Geoname.id')
    owner = relationship(Person, backref='animals_owner', primaryjoin='Animal.owner_id_fk == Person.id')
    sire = relationship('Animal', backref='animals_sire', primaryjoin='Animal.sire_id_fk == Animal.id', remote_side=[id])

    def __repr__(self):
       return self.name

 ### 


class ContentRecommendations(Model):
    __tablename__ = "content_recommendations"
    # __table_args__ = ( ) # tuple
    __doc__ = """ we will use a recommendation engine to fill this out"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    content_id_fk = Column(Integer, ForeignKey('content.id'), nullable=True)
    recommendation_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    reason = Column(Text, nullable=True)
    content = relationship(Content, backref='content_recommendationss_content', primaryjoin='ContentRecommendations.content_id_fk == Content.id')
    person = relationship(Person, backref='content_recommendationss_person', primaryjoin='ContentRecommendations.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class IsicClass(Model):
    __tablename__ = "isic_class"
    # __table_args__ = ( ) # tuple
    __doc__ = """ISIC Classes are the most detailed level, nested within ISIC Groups."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    isic_class = Column(String, nullable=True
		, comment="""Unique identifier for each ISIC class.""")
    group_id_fk = Column(Integer, ForeignKey('isic_group.id'), nullable=True
		, comment="""Reference to the parent ISIC group.""")
    class_name = Column(String, nullable=True
		, comment="""Name or description of the ISIC class.""")
    group = relationship(IsicGroup, backref='isic_classs_group', primaryjoin='IsicClass.group_id_fk == IsicGroup.id')

    def __repr__(self):
       return self.class_name

 ### 


class LessonContentLink(Model):
    __tablename__ = "lesson_content_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    lesson_id_fk = Column(Integer, ForeignKey('lesson.id'), nullable=True)
    content_id_fk = Column(Integer, ForeignKey('content.id'), nullable=True)
    content = relationship(Content, backref='lesson_content_links_content', primaryjoin='LessonContentLink.content_id_fk == Content.id')
    lesson = relationship(Lesson, backref='lesson_content_links_lesson', primaryjoin='LessonContentLink.lesson_id_fk == Lesson.id')

    def __repr__(self):
       return self.id

 ### 


class Org(Model):
    __tablename__ = "org"
    # __table_args__ = ( ) # tuple
    __doc__ = """CHECK (id != org_parent_id)"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    parent_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    org_type = Column(Enum(t_org_type), nullable=False)
    principal_name = Column(String, nullable=True)
    trading_name = Column(String, nullable=True)
    formal_name = Column(String, nullable=True)
    org_reg_status = Column(Enum(t_doc_verification_status), nullable=False)
    op_level = Column(Enum(t_admin_level), nullable=False)
    description = Column(Text, nullable=True)
    field_of_activity = Column(String, nullable=True)
    country = Column(String, ForeignKey('country.iso_alpha2'), nullable=True)
    admin1code_id_fk = Column(Integer, ForeignKey('admin1codes.id'), nullable=True
		, comment="""Equivalent of State/County/Province, Largest National subunit""")
    admin2code_id_fk = Column(Integer, ForeignKey('admin2codes.id'), nullable=True
		, comment="""Equivalent of LGA/District/Subcounty, 2nd Largest National subunit""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True)
    address_line1 = Column(String, nullable=True
		, comment="""Employer address details""")
    address_line2 = Column(String, nullable=True)
    address_line3 = Column(String, nullable=True)
    address_line4 = Column(String, nullable=True)
    city_name = Column(String, nullable=True)
    postal_code = Column(String, nullable=True)
    number_of_employees = Column(Integer, nullable=True
		, comment="""Number of employees if self-employed""")
    annual_income = Column(Integer, nullable=True
		, comment="""Yearly income of the org""")
    monthly_income = Column(Integer, nullable=True
		, comment="""Monthly income of the org""")
    domain_name = Column(String, nullable=True)
    linkedin_Url = Column(String, nullable=True)
    org_notes = Column(Text, nullable=True)
    admin1code = relationship(Admin1codes, backref='orgs_admin1code', primaryjoin='Org.admin1code_id_fk == Admin1codes.id')
    admin2code = relationship(Admin2codes, backref='orgs_admin2code', primaryjoin='Org.admin2code_id_fk == Admin2codes.id')
    country = relationship(Country, backref='orgs_country', primaryjoin='Org.country == Country.iso_alpha2')
    geo = relationship(Geoname, backref='orgs_geo', primaryjoin='Org.geo_id_fk == Geoname.id')
    parent = relationship('Org', backref='orgs_parent', primaryjoin='Org.parent_id_fk == Org.id', remote_side=[id])

    def __repr__(self):
       return self.principal_name

 ### 


class QuizQuestion(Model):
    __tablename__ = "quiz_question"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    quiz_id_fk = Column(Integer, ForeignKey('quiz.id'), nullable=True)
    question_text = Column(Text)
    has_options = Column(Boolean, default=True, nullable=True)
    option_a = Column(Text, nullable=True)
    option_b = Column(Text, nullable=True)
    option_c = Column(Text, nullable=True)
    option_d = Column(Text, nullable=True)
    correct_option = Column(String)
    correct_text = Column(Text, nullable=True
		, comment="""If the answer is narrative""")
    quiz = relationship(Quiz, backref='quiz_questions_quiz', primaryjoin='QuizQuestion.quiz_id_fk == Quiz.id')

    def __repr__(self):
       return self.id

 ### 


class PurchaseOrder(Model):
    __tablename__ = "Purchase_Order"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    supplier_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    order_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    expected_delivery_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(Enum(t_transaction_status), nullable=False)
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    notes = Column(Text, nullable=True)
    org = relationship(Org, backref='Purchase_Orders_org', primaryjoin='PurchaseOrder.org_id_fk == Org.id')
    supplier = relationship(Org, backref='Purchase_Orders_supplier', primaryjoin='PurchaseOrder.supplier_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class SalesOrder(Model):
    __tablename__ = "Sales_Order"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    customer_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    order_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    expected_ship_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(Enum(t_transaction_status), nullable=False)
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    notes = Column(Text, nullable=True)
    customer = relationship(Org, backref='Sales_Orders_customer', primaryjoin='SalesOrder.customer_id_fk == Org.id')
    org = relationship(Org, backref='Sales_Orders_org', primaryjoin='SalesOrder.org_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class AccGlAccount(Model):
    __tablename__ = "acc_gl_account"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the GL account""")
    name = Column(String
		, comment="""Name or title of the GL account""")
    description = Column(Text, nullable=True
		, comment="""Describes how this acount should be used and for what""")
    parent_id_fk = Column(Integer, ForeignKey('acc_gl_account.id'), nullable=True
		, comment="""Links to parent GL account for hierarchical structures""")
    gl_code = Column(String
		, comment="""Unique code representing the GL account""")
    disabled = Column(Boolean, default=False, nullable=True
		, comment="""Flag to indicate if the account is disabled or not""")
    manual_journal_entries_allowed = Column(Boolean, default=True, nullable=True
		, comment="""Flag to indicate if manual journal entries can be made to this account""")
    currency_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="""Currency associated with the account""")
    classification = Column(Enum(t_account_classification), nullable=False)
    normal_side = Column(Enum(t_account_normal_side), nullable=False)
    account_usage = Column(Enum(t_account_usage), nullable=False)
    account_type = Column(Enum(t_account_type), nullable=False)
    account_category = Column(Enum(t_account_category), nullable=False)
    acc_path = Column(Text, nullable=True)
    company_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    division_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    is_bank_account = Column(Boolean, nullable=True)
    is_default_account = Column(Boolean, nullable=True)
    allow_reconciliation = Column(Boolean, nullable=True)
    default_tax_code = Column(String, nullable=True)
    default_tax_rate = Column(Numeric, nullable=True)
    custom_fields = Column(String, nullable=True)
    account_restrictions = Column(String, nullable=True)
    integration_id = Column(String, nullable=True)
    is_deleted = Column(Boolean, default=False, nullable=True
		, comment="""Flag to mark the account as deleted""")
    is_favourite = Column(Boolean, nullable=True)
    deleted_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    deleted_on = Column(DateTime, server_default=text('NOW()'), nullable=True)
    deleted_reason = Column(Text, nullable=True)
    is_external = Column(Boolean, nullable=True)
    comments = Column(Text, nullable=True
		, comment="""Any additional notes or comments about the account""")
    balance = Column(Numeric, nullable=True
		, comment="""Current balance of the account. Can be computed or periodically updated""")
    created_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who created this account""")
    updated_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who last updated this account""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the account was created""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the account was last updated""")
    company = relationship(Org, backref='acc_gl_accounts_company', primaryjoin='AccGlAccount.company_id_fk == Org.id')
    created_by = relationship(Person, backref='acc_gl_accounts_created_by', primaryjoin='AccGlAccount.created_by_id_fk == Person.id')
    currency = relationship(Currency, backref='acc_gl_accounts_currency', primaryjoin='AccGlAccount.currency_id_fk == Currency.id')
    deleted_by = relationship(Person, backref='acc_gl_accounts_deleted_by', primaryjoin='AccGlAccount.deleted_by_id_fk == Person.id')
    division = relationship(Org, backref='acc_gl_accounts_division', primaryjoin='AccGlAccount.division_id_fk == Org.id')
    parent = relationship('AccGlAccount', backref='acc_gl_accounts_parent', primaryjoin='AccGlAccount.parent_id_fk == AccGlAccount.id', remote_side=[id])
    updated_by = relationship(Person, backref='acc_gl_accounts_updated_by', primaryjoin='AccGlAccount.updated_by_id_fk == Person.id')

    def __repr__(self):
       return self.name

 ### 


class AccGlClosure(Model):
    __tablename__ = "acc_gl_closure"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the GL closure""")
    org_id_fk = Column(Integer, ForeignKey('org.id')
		, comment="""Foreign key reference to the organization for which books are closed""")
    closure_type = Column(Enum(t_closure_type), nullable=False)
    closing_date = Column(Date
		, comment="""Date when the books are officially closed""")
    opened_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who opened this closure (typically an accountant or financial manager)""")
    closed_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who closed the books""")
    is_deleted = Column(Boolean, default=False
		, comment="""Flag to mark the closure as deleted or inactive""")
    comments = Column(Text, nullable=True
		, comment="""Any additional notes or comments about the closure""")
    opening_balance = Column(Numeric, nullable=True
		, comment="""Balance at the beginning of the period being closed""")
    closing_balance = Column(Numeric, nullable=True
		, comment="""Balance at the end of the period""")
    total_debits = Column(Numeric, nullable=True
		, comment="""Total debits during the closure period""")
    total_credits = Column(Numeric, nullable=True
		, comment="""Total credits during the closure period""")
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp of when the closure was created""")
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp of the last update made to the closure""")
    closed_by = relationship(Person, backref='acc_gl_closures_closed_by', primaryjoin='AccGlClosure.closed_by_id_fk == Person.id')
    opened_by = relationship(Person, backref='acc_gl_closures_opened_by', primaryjoin='AccGlClosure.opened_by_id_fk == Person.id')
    org = relationship(Org, backref='acc_gl_closures_org', primaryjoin='AccGlClosure.org_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class AnimalHealth(Model):
    __tablename__ = "animal_health"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary Key""")
    animal_id_fk = Column(Integer, ForeignKey('animal.id')
		, comment="""Foreign Key referencing animal""")
    weight_kgs = Column(Float
		, comment="""Weight of the animal in kilograms""")
    weigh_date = Column(DateTime, server_default=text('NOW()')
		, comment="""Date and time when the weight was measured""")
    weighed_by_id_fk = Column(Integer, ForeignKey('person.id')
		, comment="""ID of the person who weighed the animal""")
    health_status = Column(Text
		, comment="""Current health status""")
    health_checked_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""ID of the person who checked the health""")
    health_check_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when the health check was performed""")
    behavioral_observations = Column(Text, nullable=True
		, comment="""Notes on the behavior of the animal""")
    nutrition_evaluation = Column(Text, nullable=True
		, comment="""Assessment of the nutrition level""")
    body_condition_score = Column(Float, nullable=True
		, comment="""Score indicating body condition""")
    temperature = Column(Float, nullable=True
		, comment="""Body temperature""")
    pulse_rate = Column(Integer, nullable=True
		, comment="""Heart pulse rate""")
    respiration_rate = Column(Integer, nullable=True
		, comment="""Rate of respiration""")
    skin_coat_condition = Column(Text, nullable=True
		, comment="""Status of skin and coat""")
    eye_ear_condition = Column(Text, nullable=True
		, comment="""Condition of eyes and ears""")
    oral_health_status = Column(Text, nullable=True
		, comment="""Condition of mouth and teeth""")
    hoof_claw_condition = Column(Text, nullable=True
		, comment="""Status of hoofs or claws""")
    mammary_gland_condition = Column(Text, nullable=True
		, comment="""Condition of mammary glands, if applicable""")
    reproductive_system_condition = Column(Text, nullable=True
		, comment="""Condition of reproductive system""")
    locomotion_status = Column(Text, nullable=True
		, comment="""Observation on mobility""")
    tail_anus_condition = Column(Text, nullable=True
		, comment="""Condition of tail and anus""")
    blood_test_results = Column(Text, nullable=True
		, comment="""Results of blood tests""")
    fecal_test_results = Column(Text, nullable=True
		, comment="""Results of fecal tests""")
    urine_test_results = Column(Text, nullable=True
		, comment="""Results of urine tests""")
    milk_quality_test_results = Column(Text, nullable=True
		, comment="""Quality of milk test results""")
    biopsy_tissue_sampling_results = Column(Text, nullable=True
		, comment="""Biopsy or tissue sample results""")
    vaccination_status = Column(Text, nullable=True
		, comment="""Status of vaccinations""")
    deworming_status = Column(Text, nullable=True
		, comment="""Status of deworming""")
    tuberculosis_test = Column(Text, nullable=True
		, comment="""Results of tuberculosis tests""")
    brucellosis_test = Column(Text, nullable=True
		, comment="""Results of brucellosis tests""")
    bvd_test = Column(Text, nullable=True
		, comment="""Results of Bovine Viral Diarrhea (BVD) tests""")
    ultrasound_results = Column(Text, nullable=True
		, comment="""Results of ultrasound scans""")
    x_ray_results = Column(Text, nullable=True
		, comment="""Results of X-ray scans""")
    rfid_scan_id = Column(Text, nullable=True
		, comment="""ID from RFID scan""")
    medications_given = Column(Text, nullable=True
		, comment="""Medications administered""")
    symptoms_present = Column(Text, nullable=True
		, comment="""Symptoms observed""")
    health_comments = Column(Text, nullable=True
		, comment="""Additional comments on health""")
    created_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Creation timestamp""")
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Last update timestamp""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Flag indicating if this record is still valid""")
    feather_condition = Column(Text, nullable=True
		, comment="""Condition of feathers, if applicable""")
    eye_and_comb_condition = Column(Text, nullable=True
		, comment="""Condition of eyes and comb, if applicable""")
    leg_and_claw_condition = Column(Text, nullable=True
		, comment="""Condition of legs and claws, if applicable""")
    animal = relationship(Animal, backref='animal_healths_animal', primaryjoin='AnimalHealth.animal_id_fk == Animal.id')
    health_checked_by = relationship(Person, backref='animal_healths_health_checked_by', primaryjoin='AnimalHealth.health_checked_by_id_fk == Person.id')
    weighed_by = relationship(Person, backref='animal_healths_weighed_by', primaryjoin='AnimalHealth.weighed_by_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Calendar(Model):
    __tablename__ = "calendar"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    title = Column(String)
    description = Column(Text, nullable=True)
    location = Column(String, nullable=True)
    timezone_id_fk = Column(Integer, ForeignKey('timezone.id'), nullable=True)
    start_date = Column(Date, nullable=True)
    end_date = Column(Date, nullable=True)
    duration_unit = Column(Enum(t_interval), nullable=False)
    comments = Column(Text, nullable=True)
    is_deleted = Column(Boolean, default=False, nullable=True
		, comment="""Logical deletion flag""")
    org = relationship(Org, backref='calendars_org', primaryjoin='Calendar.org_id_fk == Org.id')
    person = relationship(Person, backref='calendars_person', primaryjoin='Calendar.person_id_fk == Person.id')
    timezone = relationship(Timezone, backref='calendars_timezone', primaryjoin='Calendar.timezone_id_fk == Timezone.id')

    def __repr__(self):
       return self.title

 ### 


class Contact(Model):
    __tablename__ = "contact"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the contact.""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Reference to the individual associated with this contact.""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Reference to the organization associated with this contact.""")
    address_type_id_fk = Column(Integer, ForeignKey('contact_type.id')
		, comment="""Reference to the type of contact.""")
    contact = Column(String
		, comment="""Actual contact value, e.g., phone number or email address.""")
    priority = Column(Integer
		, comment="""Ordering priority for displaying or using the contact. Lower value indicates higher priority.""")
    best_time_to_contact_start = Column(Time, nullable=True
		, comment="""Preferred start time when the individual/organization is available for contact.""")
    best_time_to_contact_end = Column(Time, nullable=True
		, comment="""Preferred end time for availability.""")
    active_from_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Date when this contact became active or relevant.""")
    active_to_date = Column(Date, nullable=True
		, comment="""Date when this contact ceases to be active or relevant.""")
    for_business_use = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the contact is primarily for business purposes.""")
    for_personal_use = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if the contact is primarily for personal use.""")
    do_not_use = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if there are any restrictions or requests not to use this contact.""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if this contact is currently active and usable.""")
    is_blocked = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this contact is blocked, maybe due to spam or other reasons.""")
    is_verified = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this contact has been verified, e.g., via OTP or email confirmation.""")
    notes = Column(Text, nullable=True
		, comment="""Additional notes or context about the contact.""")
    address_type = relationship(ContactType, backref='contacts_address_type', primaryjoin='Contact.address_type_id_fk == ContactType.id')
    org = relationship(Org, backref='contacts_org', primaryjoin='Contact.org_id_fk == Org.id')
    person = relationship(Person, backref='contacts_person', primaryjoin='Contact.person_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Doc(Model):
    __tablename__ = "doc"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the document.""")
    doc_type_id_fk = Column(Integer, ForeignKey('doc_type.id'), nullable=True
		, comment="""References the type of document e.g. passport, license.""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""The person to whom the document belongs.""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""The organization associated with the document.""")
    doc_name = Column(String, nullable=True
		, comment="""Name or title of the document.""")
    doc_content_type = Column(String, nullable=True
		, comment="""MIME type of the document content e.g. application/pdf, image/jpeg.""")
    expired = Column(Boolean, default=False, nullable=True
		, comment="""Flag to indicate if the document has expired.""")
    verified_date = Column(Date, nullable=True
		, comment="""The date when the document was verified.""")
    expires_on = Column(Date, nullable=True
		, comment="""Expiration date of the document.""")
    issued_on = Column(Date, nullable=True
		, comment="""The date when the document was issued.""")
    issued_by_authority = Column(String, nullable=True
		, comment="""Authority or organization that issued the document.""")
    issued_at = Column(String, nullable=True
		, comment="""Place or location where the document was issued.""")
    identification_number = Column(String, nullable=True
		, comment="""Unique identification number, e.g., passport number.""")
    serial_number = Column(String, nullable=True
		, comment="""Serial number of the document if applicable.""")
    description = Column(Text, nullable=True
		, comment="""Detailed description or remarks about the document.""")
    file_name = Column(Text, nullable=True
		, comment="""Name of the file if stored digitally.""")
    page_count = Column(Integer, nullable=True
		, comment="""Number of pages in the document, if applicable.""")
    doc_url = Column(Text, nullable=True
		, comment="""Actual doc in pdf or other format""")
    doc_length = Column(Integer, nullable=True
		, comment="""Size of the document in bytes or another measure.""")
    doc_text = Column(Text, nullable=True
		, comment="""Text content extracted from the document. Useful for search and analytics. May be stored in another database for scalability.""")
    mime_type_id_fk = Column(Integer, ForeignKey('mime_type.id'), nullable=True)
    language_id_fk = Column(Integer, ForeignKey('languagecodes.id'), nullable=True)
    uploaded_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the document was uploaded into the system.""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the document record was last updated.""")
    uploaded_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who uploaded the document.""")
    doc_type = relationship(DocType, backref='docs_doc_type', primaryjoin='Doc.doc_type_id_fk == DocType.id')
    language = relationship(Languagecodes, backref='docs_language', primaryjoin='Doc.language_id_fk == Languagecodes.id')
    mime_type = relationship(MimeType, backref='docs_mime_type', primaryjoin='Doc.mime_type_id_fk == MimeType.id')
    org = relationship(Org, backref='docs_org', primaryjoin='Doc.org_id_fk == Org.id')
    person = relationship(Person, backref='docs_person', primaryjoin='Doc.person_id_fk == Person.id')
    uploaded_by = relationship(Person, backref='docs_uploaded_by', primaryjoin='Doc.uploaded_by_id_fk == Person.id')

    def __repr__(self):
       return self.doc_name

 ### 


class Fund(Model):
    __tablename__ = "fund"
    # __table_args__ = ( ) # tuple
    __doc__ = """Providers of funds to be loaned or granted through BubeTech"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    fund_name = Column(String, nullable=True)
    provider_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    provider = relationship(Org, backref='funds_provider', primaryjoin='Fund.provider_id_fk == Org.id')

    def __repr__(self):
       return self.fund_name

 ### 


class HerdAnimalLink(Model):
    __tablename__ = "herd_animal_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    herd_id_fk = Column(Integer, ForeignKey('herd.id'), primary_key=True
		, comment="""Reference to the herd.""")
    animal_id_fk = Column(Integer, ForeignKey('animal.id'), primary_key=True
		, comment="""Reference to the individual livestock animal.""")
    date_added = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date and time when the animal was added to the herd.""")
    date_removed = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date and time when the animal was removed from the herd. Null if the animal is currently part of the herd.""")
    reason_for_addition = Column(Text, nullable=True
		, comment="""Reason why the animal was added to the herd, e.g., purchase, birth, transfer.""")
    reason_for_removal = Column(Text, nullable=True
		, comment="""Reason why the animal was removed from the herd, e.g., sold, died, transfer.""")
    added_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Person who added the animal to the herd.""")
    removed_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Person who removed the animal from the herd.""")
    notes = Column(Text, nullable=True
		, comment="""Any additional notes or details about the animal’s membership in the herd.""")
    added_by = relationship(Person, backref='herd_animal_links_added_by', primaryjoin='HerdAnimalLink.added_by_id_fk == Person.id')
    animal = relationship(Animal, backref='herd_animal_links_animal', primaryjoin='HerdAnimalLink.animal_id_fk == Animal.id')
    herd = relationship(Herd, backref='herd_animal_links_herd', primaryjoin='HerdAnimalLink.herd_id_fk == Herd.id')
    removed_by = relationship(Person, backref='herd_animal_links_removed_by', primaryjoin='HerdAnimalLink.removed_by_id_fk == Person.id')

    def __repr__(self):
       return self.herd_id_fk

 ### 


class LoanRiskAnalysis(Model):
    __tablename__ = "loan_risk_analysis"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    client_id_fk = Column(BigInteger, ForeignKey('org.id'), nullable=True
		, comment="""Reference to client""")
    proposed_loan_amount = Column(Numeric, nullable=True
		, comment="""Proposed loan amount for the client""")
    assets_cash = Column(Numeric, nullable=True
		, comment="""Cash assets of the client""")
    assets_bank_accounts = Column(Numeric, nullable=True
		, comment="""Assets in bank accounts""")
    assets_accounts_receivable = Column(Numeric, nullable=True
		, comment="""Amounts owed by customers (receivables)""")
    assets_inventory = Column(Numeric, nullable=True
		, comment="""Value of inventory""")
    assets_total_fixed_business = Column(Numeric, nullable=True
		, comment="""Total fixed business assets""")
    assets_total_business = Column(Numeric, nullable=True
		, comment="""Total business assets""")
    assets_total_household = Column(Numeric, nullable=True
		, comment="""Total household assets""")
    liabilities_accounts_payable = Column(Numeric, nullable=True
		, comment="""Amounts owed to suppliers""")
    liabilities_business_debts = Column(Numeric, nullable=True
		, comment="""Total business debts""")
    liabilities_total_business = Column(Numeric, nullable=True
		, comment="""Total business liabilities""")
    liabilities_equity_working_capital = Column(Numeric, nullable=True
		, comment="""Working capital in equity""")
    liabilities_total_household = Column(Numeric, nullable=True
		, comment="""Total household liabilities""")
    liabilities_household_equity = Column(Numeric, nullable=True
		, comment="""Equity in the household""")
    cashflow_cash_sales = Column(Numeric, nullable=True
		, comment="""Cash sales for cashflow analysis""")
    cashflow_cash_sales2 = Column(Numeric, nullable=True
		, comment="""Alternative cash sales metric""")
    cashflow_cost_goods_sold = Column(Numeric, nullable=True
		, comment="""Cost of goods sold""")
    cashflow_cost_goods_sold2 = Column(Numeric, nullable=True
		, comment="""Alternative metric for cost of goods sold""")
    cashflow_gross_profit = Column(Numeric, nullable=True
		, comment="""Gross profit from cashflow""")
    cashflow_other_income1 = Column(Numeric, nullable=True
		, comment="""Other income streams""")
    cashflow_total_income2 = Column(Numeric, nullable=True
		, comment="""Total income for cashflow analysis""")
    cashflow_household_expense = Column(Numeric, nullable=True
		, comment="""Household expenses""")
    cashflow_payments_to_savings = Column(Numeric, nullable=True
		, comment="""Payments moved to savings""")
    cashflow_operational_expenses = Column(Numeric, nullable=True
		, comment="""Operational expenses""")
    cashflow_disposable_income = Column(Numeric, nullable=True
		, comment="""Income available after expenses""")
    cashflow_amount_loan_installment = Column(Numeric, nullable=True
		, comment="""Installment amount for loan""")
    cashflow_available_surplus = Column(Numeric, nullable=True
		, comment="""Available surplus after accounting for expenses and income""")
    fi_inventory_turnover = Column(Numeric, nullable=True
		, comment="""Inventory turnover ratio""")
    fi_gross_margin = Column(Numeric, nullable=True
		, comment="""Gross margin ratio""")
    fi_indebtedness = Column(Numeric, nullable=True
		, comment="""Ratio of indebtedness""")
    fi_loan_recommendation = Column(Numeric, nullable=True
		, comment="""Recommended loan amount based on financial indicators""")
    fi_roe = Column(Numeric, nullable=True
		, comment="""Return on equity""")
    fi_repayment_capacity = Column(Numeric, nullable=True
		, comment="""Capacity for loan repayment""")
    client = relationship(Org, backref='loan_risk_analysiss_client', primaryjoin='LoanRiskAnalysis.client_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class LtagBatch(Model):
    __tablename__ = "ltag_batch"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each tag batch""")
    supplier_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Supplier or manufacturer of the animal tags""")
    make = Column(String, nullable=True
		, comment="""Brand or make of the animal tags""")
    model = Column(String, nullable=True
		, comment="""Specific model or variant of the tags, if applicable""")
    quantity = Column(Integer, nullable=True
		, comment="""Total number of tags in the batch""")
    received_on = Column(Date, nullable=True
		, comment="""Date when the tag batch was received""")
    tag_type = Column(String, nullable=True
		, comment="""Type of the tag e.g., ear tag, RFID, neck collar, etc.""")
    material = Column(String, nullable=True
		, comment="""Material of the tag e.g., plastic, metal, etc.""")
    purpose = Column(String, nullable=True
		, comment="""Purpose or use case for the tags e.g., identification, tracking, health monitoring, etc.""")
    packaging_notes = Column(Text, nullable=True)
    color = Column(String, nullable=True
		, comment="""Primary color of the tags""")
    tag_size = Column(String, nullable=True
		, comment="""Size or dimensions of the tag, e.g., small, medium, large or specific dimensions""")
    unique_identifiers = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if each tag in the batch has a unique identifier""")
    batch_code = Column(String, nullable=True
		, comment="""A unique code or number associated with the batch for easy reference""")
    expiry_date = Column(Date, nullable=True
		, comment="""Expiry date for the tags if they have a limited usable lifespan""")
    storage_condition = Column(String, nullable=True
		, comment="""Recommended or actual storage conditions for the tags, e.g., cool dry place, away from sunlight, etc.""")
    batch_status = Column(String, nullable=True
		, comment="""Status of the tag batch, e.g., in stock, partially used, fully used, expired, etc.""")
    cost_per_tag = Column(Float, nullable=True
		, comment="""Cost of each individual tag in the batch""")
    total_cost = Column(Float, nullable=True
		, comment="""Total cost for the batch""")
    notes = Column(Text, nullable=True
		, comment="""Any additional notes or remarks about the batch""")
    supplier = relationship(Org, backref='ltag_batchs_supplier', primaryjoin='LtagBatch.supplier_id_fk == Org.id')

    def __repr__(self):
       return self.model

 ### 


class Opportunity(Model):
    __tablename__ = "opportunity"
    # __table_args__ = ( ) # tuple
    __doc__ = """
    - Internet scraping
    - Leads from other sources (Email, Website, Social Media, Referrals, Events, Cold Call)
    We will scrape the internet for tenders and also add leads from other sources here. 
    Then we put them into the piepline. we 
  """
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each opportunity entry.""")
    owner_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Link to the organization tracking the opportunity.""")
    title = Column(String, nullable=True
		, comment="""Name or title of the opportunity.""")
    product_class_id_fk = Column(Integer, ForeignKey('product_class.id'), nullable=True)
    description = Column(Text, nullable=True
		, comment="""Detailed description of the opportunity.""")
    source_url = Column(String, nullable=True
		, comment="""The URL from where the tender information was scraped.""")
    estimated_value = Column(Numeric, nullable=True
		, comment="""Projected or advertised value of the tender.""")
    currency = Column(String, nullable=True
		, comment="""The currency in which the estimated value is specified.""")
    country_id_fk = Column(Integer, ForeignKey('country.id'), nullable=True
		, comment="""Country in Africa where the tender has been issued.""")
    region = Column(String, nullable=True
		, comment="""Specific region or state within the country for the tender.""")
    department = Column(String, nullable=True
		, comment="""Government department or agency issuing the tender.""")
    contact_info = Column(String, nullable=True
		, comment="""Contact information for queries related to the tender.""")
    lead_referred_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    lead_narrative = Column(Text, nullable=True
		, comment="""How did this lead come about""")
    lead_type = Column(String, nullable=True
		, comment="""Type or origin of the lead e.g., Meeting, Newspaper Ad, Personal Contact, Rumour, etc.""")
    lead_quality = Column(String, nullable=True
		, comment="""Qualitative assessment of the lead e.g., Hot, Warm, Cold.""")
    lead_conversion_probability = Column(Float, nullable=True
		, comment="""Probability of the lead converting into a sale. Usually between 0 (0%) and 1 (100%).""")
    lead_contact_info = Column(String, nullable=True
		, comment="""Contact information of the lead.""")
    estimated_close_date = Column(Date, nullable=True
		, comment="""Projected date when the tender decision will be made.""")
    tender_open_date = Column(Date, nullable=True
		, comment="""The date when the tender was officially opened for proposals.""")
    tender_close_date = Column(Date, nullable=True
		, comment="""The last date to submit proposals for the tender.""")
    bid_bond_value = Column(Numeric, nullable=True
		, comment="""Amount for the bid bond or earnest money deposit.""")
    bid_bond_currency = Column(String, nullable=True
		, comment="""Currency for the bid bond amount.""")
    performance_bond_value = Column(Numeric, nullable=True
		, comment="""Value of the performance bond or guarantee required.""")
    performance_bond_currency = Column(String, nullable=True
		, comment="""Currency for the performance bond amount.""")
    other_bonds_values = Column(String, nullable=True
		, comment="""JSON object capturing other types of bonds/values, e.g., advance payment bond.""")
    eligibility_criteria = Column(Text, nullable=True
		, comment="""Criteria that a bidder must meet to be eligible for the tender.""")
    document_requirements = Column(Text, nullable=True
		, comment="""List of documents required to be submitted for the tender.""")
    technical_specifications = Column(Text, nullable=True
		, comment="""Technical details or requirements of the tender.""")
    payment_terms = Column(Text, nullable=True
		, comment="""Terms of payment post awarding of the tender.""")
    status = Column(String, nullable=True
		, comment="""Current status of the tender e.g., Open, Closed, Awarded, Cancelled.""")
    created_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the opportunity was first added to the system.""")
    last_updated = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the opportunity was last updated in the system.""")
    document_links = Column(String, nullable=True
		, comment="""JSON array containing URLs of associated documents like RFP, technical specifications, etc.""")
    country = relationship(Country, backref='opportunitys_country', primaryjoin='Opportunity.country_id_fk == Country.id')
    lead_referred_by = relationship(Person, backref='opportunitys_lead_referred_by', primaryjoin='Opportunity.lead_referred_by_id_fk == Person.id')
    owner = relationship(Org, backref='opportunitys_owner', primaryjoin='Opportunity.owner_id_fk == Org.id')
    product_class = relationship(ProductClass, backref='opportunitys_product_class', primaryjoin='Opportunity.product_class_id_fk == ProductClass.id')

    def __repr__(self):
       return self.title

 ### 


class OrgPeopleLink(Model):
    __tablename__ = "org_people_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    org_id_fk = Column(Integer, ForeignKey('org.id'), primary_key=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), primary_key=True)
    person_org_role = Column(String, nullable=True)
    join_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    notes = Column(Text, nullable=True)
    org = relationship(Org, backref='org_people_links_org', primaryjoin='OrgPeopleLink.org_id_fk == Org.id')
    person = relationship(Person, backref='org_people_links_person', primaryjoin='OrgPeopleLink.person_id_fk == Person.id')

    def __repr__(self):
       return self.org_id_fk

 ### 


class OrgSuppliesLink(Model):
    __tablename__ = "org_supplies_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    org_id_fk = Column(Integer, ForeignKey('org.id'), primary_key=True)
    isic_class_id_fk = Column(Integer, ForeignKey('isic_class.id'), primary_key=True)
    notes = Column(Text, nullable=True)
    isic_class = relationship(IsicClass, backref='org_supplies_links_isic_class', primaryjoin='OrgSuppliesLink.isic_class_id_fk == IsicClass.id')
    org = relationship(Org, backref='org_supplies_links_org', primaryjoin='OrgSuppliesLink.org_id_fk == Org.id')

    def __repr__(self):
       return self.org_id_fk

 ### 


class PersonEmployment(Model):
    __tablename__ = "person_employment"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary Key""")
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Reference to the person associated with this employment record""")
    employment_status = Column(String, nullable=True
		, comment="""Status of employment e.g., Employed, Self-Employed, Unemployed""")
    field_of_employment = Column(String, nullable=True
		, comment="""Field or industry in which the person is employed""")
    employer_name = Column(String, nullable=True
		, comment="""Name of the employer""")
    position_text = Column(String, nullable=True
		, comment="""Position or role of the person within the organization""")
    number_of_years_employed = Column(Integer, nullable=True
		, comment="""Total number of years person has been employed""")
    monthly_salary = Column(Numeric, nullable=True
		, comment="""Monthly salary received by the person""")
    self_employed = Column(Boolean, nullable=True
		, comment="""Indicates if the person is self-employed""")
    field_of_self_employment = Column(String, nullable=True
		, comment="""Field or industry of self-employment""")
    business_address = Column(Text, nullable=True
		, comment="""Business address if self-employed""")
    number_of_employees = Column(Integer, nullable=True
		, comment="""Number of employees if self-employed""")
    monthly_salaries_paid = Column(Numeric, nullable=True
		, comment="""Monthly salaries paid if the person is an employer""")
    monthly_net_income_of_business_activity = Column(Numeric, nullable=True
		, comment="""Net monthly income from business activities""")
    monthly_rent = Column(Numeric, nullable=True
		, comment="""Monthly rent, if applicable""")
    other_income_generating_activities = Column(String, nullable=True
		, comment="""Any other activities that generate income""")
    bookkeeping = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the person/business maintains bookkeeping""")
    loans_with_other_institutions = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the person/business has loans with other institutions""")
    employer_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Reference to the employer organization""")
    employer_address_line1 = Column(String, nullable=True
		, comment="""Employer address details""")
    employer_address_line2 = Column(String, nullable=True)
    employer_address_line3 = Column(String, nullable=True)
    employer_address_line4 = Column(String, nullable=True)
    employer_city_name = Column(String, nullable=True
		, comment="""City of the employer""")
    employer_postal_code_text = Column(String, nullable=True
		, comment="""Postal code of the employer""")
    employer_phone_number = Column(String
		, comment="""Phone number of the employer""")
    annual_income = Column(Integer, nullable=True
		, comment="""Yearly income of the person""")
    monthly_income = Column(Integer, nullable=True
		, comment="""Monthly income of the person""")
    tax_bracket_range = Column(String, nullable=True
		, comment="""Tax bracket range of the person""")
    yearly_income_range = Column(String, nullable=True
		, comment="""Income range if exact yearly income is not available""")
    employer = relationship(Org, backref='person_employments_employer', primaryjoin='PersonEmployment.employer_id_fk == Org.id')
    person = relationship(Person, backref='person_employments_person', primaryjoin='PersonEmployment.person_id_fk == Person.id')

    def __repr__(self):
       return self.employer_name

 ### 


class Pipeline(Model):
    __tablename__ = "pipeline"
    # __table_args__ = ( ) # tuple
    __doc__ = """Each organization can have a pipeline, for which they define standard stages"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each pipeline entry.""")
    owner_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Link to the organization that owns or uses this pipeline.""")
    name = Column(String, nullable=True
		, comment="""Name or title of the pipeline. E.g., Sales Pipeline, Tendering Process""")
    description = Column(Text, nullable=True
		, comment="""A brief overview or purpose of this specific pipeline.""")
    created_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the pipeline was first created.""")
    last_updated = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the pipeline was last updated.""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Flag to indicate if the pipeline is currently active.""")
    order = Column(Integer, nullable=True
		, comment="""To define the order of pipelines if there are multiple pipelines within an organization.""")
    owner = relationship(Org, backref='pipelines_owner', primaryjoin='Pipeline.owner_id_fk == Org.id')

    def __repr__(self):
       return self.name

 ### 


class ProductSkuLink(Model):
    __tablename__ = "product_sku_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary Key for the SKU linkage""")
    product_class_id_fk = Column(Integer, ForeignKey('product_class.id'), nullable=True
		, comment="""Reference to the general product class or category""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Reference to the organization or company selling the product""")
    product_sku = Column(String, nullable=True
		, comment="""Stock Keeping Unit identifier for the product""")
    product_name = Column(String, nullable=True
		, comment="""Friendly name of the product""")
    product_description = Column(Text, nullable=True
		, comment="""Detailed description of the product""")
    product_packaging = Column(Text, nullable=True
		, comment="""Information about the product’s packaging""")
    product_pack_quantity = Column(Integer, nullable=True
		, comment="""Quantity of items in a package or lot""")
    upc = Column(String)
    ean = Column(String)
    jan = Column(String)
    isbn = Column(String)
    mbn = Column(String)
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Indicates if the product SKU is active and available for sale""")
    is_discontinued = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the product SKU has been discontinued""")
    currency_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="""Currency used for the product pricing""")
    Offer_price = Column(Numeric, nullable=True
		, comment="""Offer or sale price of the product, if any""")
    price_min = Column(Numeric, nullable=True
		, comment="""Minimum selling price of the product""")
    price_max = Column(Numeric, nullable=True
		, comment="""Maximum retail price of the product""")
    price_min_with_tax = Column(Numeric, nullable=True
		, comment="""Minimum selling price inclusive of any applicable taxes""")
    price_max_with_tax = Column(Numeric, nullable=True
		, comment="""Maximum retail price inclusive of any applicable taxes""")
    weight = Column(Numeric, nullable=True
		, comment="""Weight of the product""")
    length = Column(Numeric, nullable=True)
    height = Column(Numeric, nullable=True)
    minimum_order = Column(Integer, nullable=True)
    dimensions = Column(Text, nullable=True
		, comment="""Dimensions of the product (L x W x H)""")
    product_image_url = Column(String, nullable=True
		, comment="""URL to the product image""")
    reorder_level = Column(Integer, nullable=True
		, comment="""The stock level at which new stock should be reordered""")
    comment = Column(Text, nullable=True
		, comment="""Any additional notes or comments about the product SKU""")
    created_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who created this SKU entry""")
    created_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this SKU entry was created""")
    last_modified_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who last modified this SKU entry""")
    last_modified_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this SKU entry was last updated""")
    created_by = relationship(Person, backref='product_sku_links_created_by', primaryjoin='ProductSkuLink.created_by_id_fk == Person.id')
    currency = relationship(Currency, backref='product_sku_links_currency', primaryjoin='ProductSkuLink.currency_id_fk == Currency.id')
    last_modified_by = relationship(Person, backref='product_sku_links_last_modified_by', primaryjoin='ProductSkuLink.last_modified_by_id_fk == Person.id')
    org = relationship(Org, backref='product_sku_links_org', primaryjoin='ProductSkuLink.org_id_fk == Org.id')
    product_class = relationship(ProductClass, backref='product_sku_links_product_class', primaryjoin='ProductSkuLink.product_class_id_fk == ProductClass.id')

    def __repr__(self):
       return self.product_name

 ### 


class Quote(Model):
    __tablename__ = "quote"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    customer_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    quote_subject = Column(String, nullable=True)
    quote_date_created = Column(DateTime, server_default=text('NOW()'), nullable=True)
    quote_valid_until = Column(DateTime, server_default=text('NOW()'), nullable=True)
    quote_discount = Column(Float, nullable=True)
    quote_customer_notes = Column(Text, nullable=True)
    quote_status = Column(Enum(t_doc_status), nullable=False)
    customer = relationship(Org, backref='quotes_customer', primaryjoin='Quote.customer_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class ScoringModel(Model):
    __tablename__ = "scoring_model"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each scoring model.""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Link to the organization the model belongs to.""")
    model_name = Column(String, nullable=True
		, comment="""Name of the scoring model.""")
    model_version = Column(String, nullable=True
		, comment="""Version of the scoring model.""")
    model_description = Column(Text, nullable=True
		, comment="""Brief description about what the model does and how it scores leads.""")
    model_parameters = Column(String, nullable=True
		, comment="""JSON structure containing model parameters e.g., weights, coefficients, etc.""")
    model_type = Column(String, nullable=True
		, comment="""Type of the model e.g., Linear Regression, Decision Tree, Neural Network.""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the scoring model was created.""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the scoring model was last updated.""")
    org = relationship(Org, backref='scoring_models_org', primaryjoin='ScoringModel.org_id_fk == Org.id')

    def __repr__(self):
       return self.model_name

 ### 


class SupplierParam(Model):
    __tablename__ = "supplier_param"
    # __table_args__ = ( ) # tuple
    __doc__ = """We are measuring supplier performance"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    supplier_id_fk = Column(Integer, ForeignKey('org.id'))
    param_calc_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    satisfaction_ethics_rank = Column(Integer, nullable=True)
    contract_invoice_accuracy_rate = Column(Integer, nullable=True)
    satisfaction_weight_percent = Column(Integer, nullable=True)
    contract_on_time_delivery_rate = Column(Integer, nullable=True)
    active_from_date = Column(Date)
    active_to_date = Column(Date, nullable=True)
    competitive_warranty_rank = Column(Integer, nullable=True)
    competitive_marketing_rank = Column(Integer, nullable=True)
    contract_delivery_correctness_rate = Column(Integer, nullable=True)
    competitive_weight_score = Column(Integer, nullable=True)
    contract_sl_aissue_rate = Column(Integer, nullable=True)
    competitive_weight_percent = Column(Integer, nullable=True)
    supplier_score = Column(Integer, nullable=True)
    competitive_product_price_rank = Column(Integer, nullable=True)
    contract_weight_percent = Column(Integer, nullable=True)
    supplier_spend = Column(Integer, nullable=True)
    satisfaction_technical_support_rank = Column(Integer, nullable=True)
    contract_weight_score = Column(Integer, nullable=True)
    satisfaction_customer_service_rank = Column(Integer, nullable=True)
    satisfaction_weight_score = Column(Integer, nullable=True)
    contract_sourcing_cycle_days = Column(Integer, nullable=True)
    supplier_type = Column(String, nullable=True)
    is_carrier = Column(Boolean, nullable=True)
    contract_product_return_rate = Column(Integer, nullable=True)
    competitive_cost_avoidance_rank = Column(Integer, nullable=True)
    contract_product_quality_rate = Column(Integer, nullable=True)
    contract_budget_cost_rate = Column(Integer, nullable=True)
    supplier = relationship(Org, backref='supplier_params_supplier', primaryjoin='SupplierParam.supplier_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class UserResponse(Model):
    __tablename__ = "user_response"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    question_id_fk = Column(Integer, ForeignKey('quiz_question.id'), nullable=True)
    person_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    selected_option = Column(String, nullable=True)
    long_answer = Column(Text, nullable=True)
    answered_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    person = relationship(Person, backref='user_responses_person', primaryjoin='UserResponse.person_id_fk == Person.id')
    question = relationship(QuizQuestion, backref='user_responses_question', primaryjoin='UserResponse.question_id_fk == QuizQuestion.id')

    def __repr__(self):
       return self.id

 ### 


class Warehouse(Model):
    __tablename__ = "warehouse"
    # __table_args__ = ( ) # tuple
    __doc__ = """A warehouse has Aisles, An Aisle has Racks, Racks have Shelves, and Shelves have bins. Inventory is put in bins"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Link to the organization owning the warehouse""")
    name = Column(String, nullable=True
		, comment="""Name or identifier of the warehouse""")
    location = Column(String, nullable=True
		, comment="""Physical address of the warehouse""")
    geo_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True)
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Is the warehouse in active use?""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True)
    geo = relationship(Geoname, backref='warehouses_geo', primaryjoin='Warehouse.geo_id_fk == Geoname.id')
    org = relationship(Org, backref='warehouses_org', primaryjoin='Warehouse.org_id_fk == Org.id')

    def __repr__(self):
       return self.name

 ### 


class PurchaseOrderDetails(Model):
    __tablename__ = "Purchase_Order_Details"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    purchase_order_id_fk = Column(Integer, ForeignKey('Purchase_Order.id'), nullable=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    quantity_ordered = Column(Integer, nullable=True)
    unit_price = Column(Numeric, nullable=True)
    quantity_received = Column(Integer, nullable=True)
    received_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(Enum(t_transaction_status), nullable=False)
    product = relationship(ProductSkuLink, backref='Purchase_Order_Detailss_product', primaryjoin='PurchaseOrderDetails.product_id_fk == ProductSkuLink.id')
    purchase_order = relationship(PurchaseOrder, backref='Purchase_Order_Detailss_purchase_order', primaryjoin='PurchaseOrderDetails.purchase_order_id_fk == PurchaseOrder.id')

    def __repr__(self):
       return self.id

 ### 


class SalesOrderDetails(Model):
    __tablename__ = "Sales_Order_Details"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    sales_order_id_fk = Column(Integer, ForeignKey('Sales_Order.id'), nullable=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    quantity_ordered = Column(Integer, nullable=True)
    unit_price = Column(Float, nullable=True)
    shipped_quantity = Column(Integer, nullable=True)
    shipped_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(Enum(t_transaction_status), nullable=False)
    product = relationship(ProductSkuLink, backref='Sales_Order_Detailss_product', primaryjoin='SalesOrderDetails.product_id_fk == ProductSkuLink.id')
    sales_order = relationship(SalesOrder, backref='Sales_Order_Detailss_sales_order', primaryjoin='SalesOrderDetails.sales_order_id_fk == SalesOrder.id')

    def __repr__(self):
       return self.id

 ### 


class AccBalances(Model):
    __tablename__ = "acc_balances"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    account_id_fk = Column(Integer, ForeignKey('acc_gl_account.id'))
    closure_type = Column(Enum(t_closure_type), nullable=False)
    postmonth = Column(Integer, nullable=True
		, comment="""yyyymm format""")
    value_date = Column(DateTime, server_default=text('NOW()'), default=func.now())
    amount = Column(Numeric, nullable=True)
    updated_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    account = relationship(AccGlAccount, backref='acc_balancess_account', primaryjoin='AccBalances.account_id_fk == AccGlAccount.id')

    def __repr__(self):
       return self.id

 ### 


class AccGlJournalEntry(Model):
    __tablename__ = "acc_gl_journal_entry"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the journal entry""")
    account_id_fk = Column(Integer, ForeignKey('acc_gl_account.id')
		, comment="""Account associated with this journal entry""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Organization for which the transaction is recorded""")
    reversal_id_fk = Column(Integer, ForeignKey('acc_gl_journal_entry.id'), nullable=True
		, comment="""If this is a reversal, reference to the original transaction""")
    transaction_id = Column(String, nullable=True
		, comment="""Unique transaction ID, might come from external systems""")
    reversed = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if this transaction is a reversal of another""")
    manual_entry = Column(Boolean, default=False, nullable=True
		, comment="""Flag to indicate if this was manually entered""")
    entry_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date of the journal entry""")
    effective_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Effective date for accounting purposes""")
    trans_status = Column(Enum(t_transaction_status), nullable=False)
    amount = Column(Numeric
		, comment="""Transaction amount""")
    payment_mode = Column(Enum(t_payment_method), nullable=False)
    comments = Column(Text, nullable=True
		, comment="""Any additional notes or comments about the journal entry""")
    is_deleted = Column(Boolean, default=False, nullable=True
		, comment="""Flag to mark the transaction as deleted or inactive""")
    transaction_type = Column(Enum(t_account_transaction_type), nullable=False)
    currency_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="""Currency in which the transaction was recorded""")
    exchange_rate = Column(Numeric, nullable=True
		, comment="""Exchange rate applied, useful if dealing with multi-currency operations""")
    batch_id = Column(Integer, nullable=True
		, comment="""Batch or group ID if transactions are batched""")
    tags = Column(String, nullable=True
		, comment="""Array of tags for categorization and easy search""")
    entered_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who recorded or entered the transaction""")
    transaction_source = Column(Enum(t_transaction_source), nullable=False)
    third_party_reference = Column(String, nullable=True
		, comment="""Reference number or ID from a third-party system, if any""")
    checksum = Column(String, nullable=True
		, comment="""Checksum for data integrity validation""")
    is_locked = Column(Boolean, default=False, nullable=True
		, comment="""Flag to indicate if the transaction is locked from edits""")
    account = relationship(AccGlAccount, backref='acc_gl_journal_entrys_account', primaryjoin='AccGlJournalEntry.account_id_fk == AccGlAccount.id')
    currency = relationship(Currency, backref='acc_gl_journal_entrys_currency', primaryjoin='AccGlJournalEntry.currency_id_fk == Currency.id')
    entered_by = relationship(Person, backref='acc_gl_journal_entrys_entered_by', primaryjoin='AccGlJournalEntry.entered_by_id_fk == Person.id')
    org = relationship(Org, backref='acc_gl_journal_entrys_org', primaryjoin='AccGlJournalEntry.org_id_fk == Org.id')
    reversal = relationship('AccGlJournalEntry', backref='acc_gl_journal_entrys_reversal', primaryjoin='AccGlJournalEntry.reversal_id_fk == AccGlJournalEntry.id', remote_side=[id])

    def __repr__(self):
       return self.id

 ### 


class AccProductLink(Model):
    __tablename__ = "acc_product_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    account_id_fk = Column(Integer, ForeignKey('acc_gl_account.id'), primary_key=True
		, comment="""Reference to the account being linked""")
    product_class_id_fk = Column(Integer, ForeignKey('product_class.id'), primary_key=True
		, comment="""Reference to the product class being linked to the account""")
    financial_account_type = Column(Enum(t_account_type), nullable=False)
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Flag indicating if the link between account and product class is active""")
    comment = Column(Text, nullable=True
		, comment="""Any additional notes or comments about this linkage""")
    created_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who created this linkage""")
    created_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this linkage was created""")
    last_modified_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who last modified this linkage""")
    last_modified_on = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when this linkage was last updated""")
    account = relationship(AccGlAccount, backref='acc_product_links_account', primaryjoin='AccProductLink.account_id_fk == AccGlAccount.id')
    created_by = relationship(Person, backref='acc_product_links_created_by', primaryjoin='AccProductLink.created_by_id_fk == Person.id')
    last_modified_by = relationship(Person, backref='acc_product_links_last_modified_by', primaryjoin='AccProductLink.last_modified_by_id_fk == Person.id')
    product_class = relationship(ProductClass, backref='acc_product_links_product_class', primaryjoin='AccProductLink.product_class_id_fk == ProductClass.id')

    def __repr__(self):
       return self.account_id_fk

 ### 


class Aisle(Model):
    __tablename__ = "aisle"
    # __table_args__ = ( ) # tuple
    __doc__ = """ An Aisle is in a Warehouse"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    warehouse_id_fk = Column(Integer, ForeignKey('warehouse.id'), nullable=True
		, comment="""Link to the parent warehouse""")
    aisle_code = Column(String, nullable=True
		, comment="""Unique identifier for the aisle""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Is the aisle in active use?""")
    warehouse = relationship(Warehouse, backref='aisles_warehouse', primaryjoin='Aisle.warehouse_id_fk == Warehouse.id')

    def __repr__(self):
       return self.id

 ### 


class CalendarEvent(Model):
    __tablename__ = "calendar_event"
    # __table_args__ = ( ) # tuple
    __doc__ = """The calendar_events table captures individual events in the calendar. It has been enhanced with a location field."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key for calendar events""")
    calendar_id_fk = Column(Integer, ForeignKey('calendar.id'), nullable=True
		, comment="""Reference to the associated calendar""")
    uid = Column(String, nullable=True
		, comment="""Unique identifier for the event""")
    summary = Column(String, nullable=True
		, comment="""Short summary or title for the event""")
    description = Column(Text, nullable=True
		, comment="""Detailed description or agenda of the event""")
    interaction_mode = Column(Text, nullable=True
		, comment="""Phone, Zoom, WhatsApp, etc""")
    meeting_minutes = Column(Text, nullable=True)
    location = Column(String, nullable=True
		, comment="""Location or venue of the event""")
    start_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Start time of the event""")
    end_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""End time of the event""")
    duration = Column(Enum(t_interval), nullable=False)
    rrule = Column(String, nullable=True
		, comment="""Recurrence rule for repeating events""")
    dtstamp = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp the event entry was created""")
    last_modified = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp of the last modification""")
    organizer_id_fk = Column(Integer, ForeignKey('contact.id'), nullable=True
		, comment="""Email or identifier of the event organizer""")
    priority = Column(Enum(t_severity_level), nullable=False)
    status = Column(Enum(t_transaction_status), nullable=False)
    categories = Column(String, nullable=True
		, comment="""Category or type of event""")
    geo = Column(String, nullable=True
		, comment="""Geographical coordinates for the event""")
    is_busy = Column(Boolean, default=False, nullable=True
		, comment="""Specifies whether this event should be transparent or opaque to busy time searches""")
    sequence = Column(Integer, nullable=True
		, comment="""Sequence number - used to track changes in events""")
    url = Column(String, nullable=True
		, comment="""URL related to the event""")
    related_to_id_fk = Column(Integer, ForeignKey('calendar_event.id'), nullable=True
		, comment="""Links to another event, often used for recurring events""")
    comments = Column(Text, nullable=True
		, comment="""Additional comments or notes about the event""")
    is_deleted = Column(Boolean, default=False, nullable=True
		, comment="""Flag to mark deleted events""")
    freebusy_start = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Start time for marking free/busy status""")
    freebusy_end = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""End time for marking free/busy status""")
    freebusy_type = Column(String, nullable=True
		, comment="""The type of status being marked (e.g., busy, free)""")
    calendar = relationship(Calendar, backref='calendar_events_calendar', primaryjoin='CalendarEvent.calendar_id_fk == Calendar.id')
    organizer = relationship(Contact, backref='calendar_events_organizer', primaryjoin='CalendarEvent.organizer_id_fk == Contact.id')
    related_to = relationship('CalendarEvent', backref='calendar_events_related_to', primaryjoin='CalendarEvent.related_to_id_fk == CalendarEvent.id', remote_side=[id])

    def __repr__(self):
       return self.id

 ### 


class InventoryOrderMap(Model):
    __tablename__ = "inventory_order_map"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    supplier_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    quote_id_fk = Column(Integer, ForeignKey('quote.id'), nullable=True)
    sales_order_id_fk = Column(Integer, ForeignKey('Sales_Order.id'), nullable=True)
    order_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    expected_delivery_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(Enum(t_transaction_status), nullable=False)
    org = relationship(Org, backref='inventory_order_maps_org', primaryjoin='InventoryOrderMap.org_id_fk == Org.id')
    quote = relationship(Quote, backref='inventory_order_maps_quote', primaryjoin='InventoryOrderMap.quote_id_fk == Quote.id')
    sales_order = relationship(SalesOrder, backref='inventory_order_maps_sales_order', primaryjoin='InventoryOrderMap.sales_order_id_fk == SalesOrder.id')
    supplier = relationship(Org, backref='inventory_order_maps_supplier', primaryjoin='InventoryOrderMap.supplier_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class Invoice(Model):
    __tablename__ = "invoice"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    issue_org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    dest_org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    quote_id_fk = Column(Integer, ForeignKey('quote.id'), nullable=True)
    invoice_subject = Column(Text, nullable=True)
    invoice_date_created = Column(Date, nullable=True)
    invoice_number = Column(String, nullable=True)
    invoice_customer_notes = Column(Text, nullable=True)
    invoice_valid_until = Column(Date, nullable=True)
    invoice_status = Column(Enum(t_transaction_status), nullable=False)
    dest_org = relationship(Org, backref='invoices_dest_org', primaryjoin='Invoice.dest_org_id_fk == Org.id')
    issue_org = relationship(Org, backref='invoices_issue_org', primaryjoin='Invoice.issue_org_id_fk == Org.id')
    quote = relationship(Quote, backref='invoices_quote', primaryjoin='Invoice.quote_id_fk == Quote.id')

    def __repr__(self):
       return self.id

 ### 


class LandParcel(Model):
    __tablename__ = "land_parcel"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the land parcel.""")
    owner_id_fk = Column(Integer, ForeignKey('org.id')
		, comment="""Reference to the organization or individual that owns the land.""")
    latitude = Column(Float, nullable=True
		, comment="""Latitude coordinate of a reference point in the parcel.""")
    longitude = Column(Float, nullable=True
		, comment="""Longitude coordinate of a reference point in the parcel.""")
    altitude = Column(Float, nullable=True
		, comment="""Altitude or elevation of the reference point.""")
    nearest_geoname_id_fk = Column(Integer, ForeignKey('geoname.id'), nullable=True
		, comment="""Reference to the nearest recognized geographical name.""")
    area = Column(Numeric
		, comment="""Calculated area of the land parcel.""")
    soil_type = Column(Enum(t_soil_texture), nullable=False)
    land_use = Column(Enum(t_land_use), nullable=False)
    water_source = Column(Enum(t_water_source), nullable=False)
    land_title = Column(String, nullable=True
		, comment="""Land title or registration details.""")
    land_title_doc_id_fk = Column(Integer, ForeignKey('doc.id'), nullable=True)
    is_leased = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the land is leased.""")
    lease_expiry_date = Column(Date, nullable=True
		, comment="""Expiration date if the land is leased.""")
    land_notes = Column(Text, nullable=True
		, comment="""Additional notes or remarks about the land parcel.""")
    land_title_doc = relationship(Doc, backref='land_parcels_land_title_doc', primaryjoin='LandParcel.land_title_doc_id_fk == Doc.id')
    nearest_geoname = relationship(Geoname, backref='land_parcels_nearest_geoname', primaryjoin='LandParcel.nearest_geoname_id_fk == Geoname.id')
    owner = relationship(Org, backref='land_parcels_owner', primaryjoin='LandParcel.owner_id_fk == Org.id')

    def __repr__(self):
       return self.nearest_geoname_id_fk

 ### 


class LeadScore(Model):
    __tablename__ = "lead_score"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each lead score entry.""")
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Link to the organization the lead belongs to.""")
    opportunity_id_fk = Column(Integer, ForeignKey('opportunity.id'), nullable=True
		, comment="""Link to the specific lead being scored.""")
    score = Column(Integer, nullable=True
		, comment="""Quantitative representation of the leads potential value, typically a value between 0 and 100.""")
    criteria = Column(String, nullable=True
		, comment="""JSON structure containing scoring breakdown based on various criteria e.g., {website_visits: 5, email_opened: 3}.""")
    predictive_score = Column(Float, nullable=True
		, comment="""Score derived from predictive analytics models which predicts the likelihood of lead conversion.""")
    behavior_score = Column(Integer, nullable=True
		, comment="""Score based on the leads interactions like website visits, email clicks, etc.""")
    demographic_score = Column(Integer, nullable=True
		, comment="""Score based on demographic data like job title, company size, etc.""")
    engagement_level = Column(String, nullable=True
		, comment="""Categorization of the leads engagement level, e.g., High, Medium, Low.""")
    lead_source = Column(String, nullable=True
		, comment="""Source from which the lead was generated, e.g., Email Campaign, Webinar.""")
    lead_status = Column(String, nullable=True
		, comment="""Current status of the lead e.g., New, In Progress, Converted, Lost.""")
    last_engagement = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp of the last engagement activity by the lead.""")
    last_updated = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp when the lead score was last updated.""")
    scoring_model_id_fk = Column(Integer, ForeignKey('scoring_model.id'), nullable=True
		, comment="""Link to the scoring model used to compute this score.""")
    opportunity = relationship(Opportunity, backref='lead_scores_opportunity', primaryjoin='LeadScore.opportunity_id_fk == Opportunity.id')
    org = relationship(Org, backref='lead_scores_org', primaryjoin='LeadScore.org_id_fk == Org.id')
    scoring_model = relationship(ScoringModel, backref='lead_scores_scoring_model', primaryjoin='LeadScore.scoring_model_id_fk == ScoringModel.id')

    def __repr__(self):
       return self.scoring_model_id_fk

 ### 


class LoanProduct(Model):
    __tablename__ = "loan_product"
    # __table_args__ = ( ) # tuple
    __doc__ = """Main table for defining loan products"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key, auto-incremented""")
    currency_code_id_fk = Column(Integer, ForeignKey('currency.id')
		, comment="""ISO currency code for the loan""")
    principal_amount = Column(Numeric
		, comment="""Principal loan amount""")
    arrearstolerance_amount = Column(Numeric, nullable=True
		, comment="""Tolerance amount for arrears""")
    name = Column(String
		, comment="""Human-readable name of the loan product""")
    description = Column(String, nullable=True
		, comment="""Description of the loan product""")
    fund_id_fk = Column(BigInteger, ForeignKey('fund.id'), nullable=True
		, comment="""Foreign Key referencing the associated fund""")
    nominal_interest_rate_per_period = Column(Float
		, comment="""Nominal interest rate for each period""")
    interest_period_frequency_enum = Column(SmallInteger
		, comment="""Frequency of interest calculation per period""")
    annual_nominal_interest_rate = Column(Float
		, comment="""Annual nominal interest rate""")
    interest_method_enum = Column(SmallInteger
		, comment="""Method used for interest calculation""")
    interest_calculated_in_period_enum = Column(SmallInteger
		, comment="""How interest is calculated in each period""")
    repay_every = Column(SmallInteger
		, comment="""Frequency of repayment""")
    repayment_period_frequency_enum = Column(SmallInteger
		, comment="""Frequency type of repayment (e.g., monthly, quarterly)""")
    number_of_repayments = Column(SmallInteger
		, comment="""Total number of repayments for the loan""")
    amortization_method_enum = Column(Enum(t_amortization_method), nullable=False)
    accounting_type = Column(SmallInteger
		, comment="""Type of accounting method to be used""")
    loan_transaction_strategy_id_fk = Column(Integer, ForeignKey('loan_transaction_strategy.id'), nullable=True
		, comment="""Foreign key referring to the transaction strategy""")
    note = Column(Text, nullable=True)
    currency_code = relationship(Currency, backref='loan_products_currency_code', primaryjoin='LoanProduct.currency_code_id_fk == Currency.id')
    fund = relationship(Fund, backref='loan_products_fund', primaryjoin='LoanProduct.fund_id_fk == Fund.id')
    loan_transaction_strategy = relationship(LoanTransactionStrategy, backref='loan_products_loan_transaction_strategy', primaryjoin='LoanProduct.loan_transaction_strategy_id_fk == LoanTransactionStrategy.id')

    def __repr__(self):
       return self.name

 ### 


class Ltag(Model):
    __tablename__ = "ltag"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each individual animal tag""")
    ltag_batch_id_fk = Column(Integer, ForeignKey('ltag_batch.id'), nullable=True
		, comment="""Reference to the batch from which the tag originates""")
    serial_number = Column(String, nullable=True
		, comment="""Unique serial number or identifier for the tag""")
    rfid_code = Column(String, nullable=True
		, comment="""RFID code, if the tag is RFID enabled""")
    colour = Column(String, nullable=True
		, comment="""Colour of the individual tag, which might differ even in the same batch""")
    is_active = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the tag is currently active or functional""")
    is_issued = Column(Boolean, default=False, nullable=True
		, comment="""Indicates if the tag has been issued/assigned to an animal""")
    issued_to_id_fk = Column(Integer, ForeignKey('animal.id'), nullable=True
		, comment="""Reference to animal entity if the tag is issued""")
    issue_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date and time when the tag was issued to an animal""")
    location = Column(String, nullable=True
		, comment="""Current location or warehouse where the tag is stored if not issued""")
    manufactured_on = Column(Date, nullable=True
		, comment="""Manufacturing date of the individual tag""")
    expired_on = Column(Date, nullable=True
		, comment="""Expiry date if the tag has a limited usable lifespan""")
    activated_on = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date and time when the tag was activated""")
    deactivated_on = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date and time when the tag was deactivated""")
    deactivation_reason = Column(String, nullable=True
		, comment="""Reason for deactivation if applicable""")
    durability_rating = Column(String, nullable=True
		, comment="""Rating or description of the tag’s durability e.g., high, medium, low""")
    notes = Column(Text, nullable=True
		, comment="""Any additional notes or remarks about the individual tag""")
    issued_to = relationship(Animal, backref='ltags_issued_to', primaryjoin='Ltag.issued_to_id_fk == Animal.id')
    ltag_batch = relationship(LtagBatch, backref='ltags_ltag_batch', primaryjoin='Ltag.ltag_batch_id_fk == LtagBatch.id')

    def __repr__(self):
       return self.id

 ### 


class OpportunityContactLink(Model):
    __tablename__ = "opportunity_contact_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    opportunity_id_fk = Column(Integer, ForeignKey('opportunity.id'), primary_key=True)
    contact_id_fk = Column(Integer, ForeignKey('contact.id'), primary_key=True)
    contact = relationship(Contact, backref='opportunity_contact_links_contact', primaryjoin='OpportunityContactLink.contact_id_fk == Contact.id')
    opportunity = relationship(Opportunity, backref='opportunity_contact_links_opportunity', primaryjoin='OpportunityContactLink.opportunity_id_fk == Opportunity.id')

    def __repr__(self):
       return self.opportunity_id_fk

 ### 


class OpportunityIsicClassLink(Model):
    __tablename__ = "opportunity_isic_class_link"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    opportunity_id_fk = Column(Integer, ForeignKey('opportunity.id'), primary_key=True)
    isic_class_code_id_fk = Column(Integer, ForeignKey('isic_class.id'), primary_key=True)
    isic_class_code = relationship(IsicClass, backref='opportunity_isic_class_links_isic_class_code', primaryjoin='OpportunityIsicClassLink.isic_class_code_id_fk == IsicClass.id')
    opportunity = relationship(Opportunity, backref='opportunity_isic_class_links_opportunity', primaryjoin='OpportunityIsicClassLink.opportunity_id_fk == Opportunity.id')

    def __repr__(self):
       return self.opportunity_id_fk

 ### 


class PipelineStages(Model):
    __tablename__ = "pipeline_stages"
    # __table_args__ = ( ) # tuple
    __doc__ = """Each pipline can have default stages, specified here"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for each stage within a pipeline.""")
    pipeline_id_fk = Column(Integer, ForeignKey('pipeline.id'), nullable=True
		, comment="""Link to the pipeline this stage belongs to.""")
    name = Column(String, nullable=True
		, comment="""Name or title of the stage. E.g., Initial Contact, Proposal Submitted, Negotiation""")
    description = Column(Text, nullable=True
		, comment="""A brief overview or purpose of this specific stage.""")
    pipeline_stage = Column(Enum(t_pipeline_stages), nullable=False)
    std_win_probability = Column(Float, nullable=True
		, comment="""A percentage indicating the likelihood of a deal closing when it reaches this stage. E.g., 0.5 for 50%.""")
    std_duration_estimate = Column(Integer, nullable=True
		, comment="""Optional field indicating the average or expected duration (in days) an opportunity might stay in this stage.""")
    std_entry_criteria = Column(Text, nullable=True
		, comment="""Criteria that an opportunity should meet to enter this stage.""")
    std_exit_criteria = Column(Text, nullable=True
		, comment="""Criteria that need to be met before moving the opportunity to the next stage.""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Flag to indicate if the stage is currently active within its pipeline.""")
    is_expired = Column(Boolean, default=False, nullable=True)
    pipeline = relationship(Pipeline, backref='pipeline_stagess_pipeline', primaryjoin='PipelineStages.pipeline_id_fk == Pipeline.id')

    def __repr__(self):
       return self.name

 ### 


class ProductReturn(Model):
    __tablename__ = "product_return"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True)
    order_id = Column(Integer)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    customer_id = Column(Integer)
    firstname = Column(String)
    lastname = Column(String)
    email = Column(String)
    telephone = Column(String)
    product = Column(String)
    model = Column(String)
    quantity = Column(Integer)
    opened = Column(Boolean, default=False, nullable=True)
    return_action = Column(Enum(t_product_return_action), nullable=False)
    return_reason = Column(Enum(t_product_return_reason), nullable=False)
    comment = Column(Text, nullable=True)
    date_ordered = Column(Date, nullable=True)
    date_added = Column(DateTime, server_default=text('NOW()'), nullable=True)
    date_modified = Column(DateTime, server_default=text('NOW()'), nullable=True)
    product = relationship(ProductSkuLink, backref='product_returns_product', primaryjoin='ProductReturn.product_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.firstname

 ### 


class QuoteDetails(Model):
    __tablename__ = "quote_details"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    quote_item_id = Column(Integer, primary_key=True, autoincrement=True)
    quote_id_fk = Column(Integer, ForeignKey('quote.id'), nullable=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    quote_item_name = Column(String, nullable=True)
    quote_item_description = Column(Text, nullable=True)
    quote_item_price = Column(Numeric, nullable=True)
    quote_item_quantity = Column(Float, nullable=True)
    quote_item_discount = Column(Float, nullable=True)
    quote_item_subtotal = Column(Numeric, nullable=True)
    quote_item_discounted_subtotal = Column(Numeric, nullable=True)
    product = relationship(ProductSkuLink, backref='quote_detailss_product', primaryjoin='QuoteDetails.product_id_fk == ProductSkuLink.id')
    quote = relationship(Quote, backref='quote_detailss_quote', primaryjoin='QuoteDetails.quote_id_fk == Quote.id')

    def __repr__(self):
       return self.quote_item_name

 ### 


class CalendarEventAttachment(Model):
    __tablename__ = "calendar_event_attachment"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    event_id_fk = Column(Integer, ForeignKey('calendar_event.id'), nullable=True)
    attachment_url = Column(String, nullable=True)
    event = relationship(CalendarEvent, backref='calendar_event_attachments_event', primaryjoin='CalendarEventAttachment.event_id_fk == CalendarEvent.id')

    def __repr__(self):
       return self.id

 ### 


class CalendarEventAttendee(Model):
    __tablename__ = "calendar_event_attendee"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key for event attendees""")
    event_id_fk = Column(Integer, ForeignKey('calendar_event.id'), nullable=True
		, comment="""Reference to the associated event""")
    contact_id_fk = Column(Integer, ForeignKey('contact.id'), nullable=True
		, comment="""Email of the attendee""")
    invitee_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    role = Column(String, nullable=True
		, comment="""Role of the attendee (e.g., chair, participant)""")
    participation_status = Column(String, nullable=True
		, comment="""Current participation status of the attendee (e.g., accepted, declined)""")
    rsvp = Column(Boolean, nullable=True
		, comment="""Flag to indicate if the attendee needs to respond""")
    is_confirmed = Column(Boolean, default=False, nullable=True)
    contact = relationship(Contact, backref='calendar_event_attendees_contact', primaryjoin='CalendarEventAttendee.contact_id_fk == Contact.id')
    event = relationship(CalendarEvent, backref='calendar_event_attendees_event', primaryjoin='CalendarEventAttendee.event_id_fk == CalendarEvent.id')
    invitee = relationship(Person, backref='calendar_event_attendees_invitee', primaryjoin='CalendarEventAttendee.invitee_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class CalendarEventRecurrence(Model):
    __tablename__ = "calendar_event_recurrence"
    # __table_args__ = ( ) # tuple
    __doc__ = """The calendar_event_recurrence table handles the recurrence settings of an event."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    event_id_fk = Column(Integer, ForeignKey('calendar_event.id'), primary_key=True
		, comment="""Link to the event""")
    recurrence_pattern_cron = Column(String, nullable=True
		, comment="""CRON-style pattern for recurrence""")
    recurrence_end_date = Column(Date, nullable=True
		, comment="""Optional end date for recurrence pattern""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Allows for pausing a recurrence without deleting it""")
    event = relationship(CalendarEvent, backref='calendar_event_recurrences_event', primaryjoin='CalendarEventRecurrence.event_id_fk == CalendarEvent.id')

    def __repr__(self):
       return self.id

 ### 


class CalendarEventReminders(Model):
    __tablename__ = "calendar_event_reminders"
    # __table_args__ = ( ) # tuple
    __doc__ = """The calendar_event_reminders table handles the multiple reminders that can be set for an event."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    event_id_fk = Column(Integer, ForeignKey('calendar_event.id')
		, comment="""Link to the event""")
    reminder_unit = Column(SmallInteger
		, comment="""Time quantity for the reminder""")
    reminder_interval_type = Column(Enum(t_interval), nullable=False)
    remind_by = Column(Enum(t_remind_by_enum), nullable=False)
    action = Column(String, nullable=True)
    trigger_time = Column(Integer, nullable=True)
    trigger_type = Column(Enum(t_interval), nullable=False)
    repeat_count = Column(Integer, nullable=True)
    duration = Column(Enum(t_interval), nullable=False)
    is_expired = Column(Boolean, default=False, nullable=True)
    event = relationship(CalendarEvent, backref='calendar_event_reminderss_event', primaryjoin='CalendarEventReminders.event_id_fk == CalendarEvent.id')

    def __repr__(self):
       return self.id

 ### 


class InventoryOrderDetail(Model):
    __tablename__ = "inventory_order_detail"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    inventory_order_id_fk = Column(Integer, ForeignKey('inventory_order_map.id'), nullable=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    quantity = Column(Integer, nullable=True)
    price = Column(Numeric, nullable=True)
    inventory_order = relationship(InventoryOrderMap, backref='inventory_order_details_inventory_order', primaryjoin='InventoryOrderDetail.inventory_order_id_fk == InventoryOrderMap.id')
    product = relationship(ProductSkuLink, backref='inventory_order_details_product', primaryjoin='InventoryOrderDetail.product_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.id

 ### 


class InvoiceDetails(Model):
    __tablename__ = "invoice_details"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    invoice_item_id = Column(Integer, primary_key=True, autoincrement=True)
    invoice_id_fk = Column(Integer, ForeignKey('invoice.id'), nullable=True)
    product_sku_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    invoice_item_name = Column(String, nullable=True)
    invoice_item_description = Column(Text, nullable=True)
    invoice_item_price = Column(Numeric, nullable=True)
    invoice_item_quantity = Column(Float, nullable=True)
    invoice_item_discount = Column(Float, nullable=True)
    invoice_item_subtotal = Column(Numeric, nullable=True)
    invoice_item_discounted_subtotal = Column(Numeric, nullable=True)
    invoice_item_notes = Column(Text, nullable=True)
    invoice = relationship(Invoice, backref='invoice_detailss_invoice', primaryjoin='InvoiceDetails.invoice_id_fk == Invoice.id')
    product_sku = relationship(ProductSkuLink, backref='invoice_detailss_product_sku', primaryjoin='InvoiceDetails.product_sku_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.invoice_item_name

 ### 


class InvoicePayments(Model):
    __tablename__ = "invoice_payments"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    invoice_id_fk = Column(Integer, ForeignKey('invoice.id'), nullable=True)
    payment_posting_id_fk = Column(Integer, ForeignKey('acc_gl_journal_entry.id'), nullable=True)
    payment_method = Column(Enum(t_payment_method), nullable=False)
    invoice_payment_amount = Column(Numeric)
    invoice_payment_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    invoice_payment_note = Column(Text, nullable=True)
    invoice_status = Column(Enum(t_transaction_status), nullable=False)
    invoice = relationship(Invoice, backref='invoice_paymentss_invoice', primaryjoin='InvoicePayments.invoice_id_fk == Invoice.id')
    payment_posting = relationship(AccGlJournalEntry, backref='invoice_paymentss_payment_posting', primaryjoin='InvoicePayments.payment_posting_id_fk == AccGlJournalEntry.id')

    def __repr__(self):
       return self.id

 ### 


class LandImprovements(Model):
    __tablename__ = "land_improvements"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id'))
    improvement_type = Column(Enum(t_improvement_type), nullable=False)
    improved_on = Column(Date, nullable=True)
    improved_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    cost = Column(Numeric, nullable=True)
    notes = Column(Text, nullable=True)
    improved_by = relationship(Person, backref='land_improvementss_improved_by', primaryjoin='LandImprovements.improved_by_id_fk == Person.id')
    land_parcel = relationship(LandParcel, backref='land_improvementss_land_parcel', primaryjoin='LandImprovements.land_parcel_id_fk == LandParcel.id')

    def __repr__(self):
       return self.id

 ### 


class LandOwnershipHistory(Model):
    __tablename__ = "land_ownership_history"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id'))
    previous_owner_id_fk = Column(Integer, ForeignKey('person.id'))
    current_owner_id_fk = Column(Integer, ForeignKey('person.id'))
    date_of_transfer = Column(Date, nullable=True)
    transfer_type = Column(Text, nullable=True
		, comment="""Eventually change this to an enum""")
    current_owner = relationship(Person, backref='land_ownership_historys_current_owner', primaryjoin='LandOwnershipHistory.current_owner_id_fk == Person.id')
    land_parcel = relationship(LandParcel, backref='land_ownership_historys_land_parcel', primaryjoin='LandOwnershipHistory.land_parcel_id_fk == LandParcel.id')
    previous_owner = relationship(Person, backref='land_ownership_historys_previous_owner', primaryjoin='LandOwnershipHistory.previous_owner_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class LandUseHistory(Model):
    __tablename__ = "land_use_history"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id'))
    start_on = Column(Date, nullable=True)
    end_on = Column(Date, nullable=True)
    used_for = Column(Enum(t_land_use), nullable=False)
    crop_id_fk = Column(Integer, ForeignKey('crop.id'), nullable=True
		, comment="""ID of the crop that was/is being grown""")
    notes = Column(Text, nullable=True)
    crop = relationship(Crop, backref='land_use_historys_crop', primaryjoin='LandUseHistory.crop_id_fk == Crop.id')
    land_parcel = relationship(LandParcel, backref='land_use_historys_land_parcel', primaryjoin='LandUseHistory.land_parcel_id_fk == LandParcel.id')

    def __repr__(self):
       return self.id

 ### 


class LandUseRecommendations(Model):
    __tablename__ = "land_use_recommendations"
    # __table_args__ = ( ) # tuple
    __doc__ = """Further fields can be added for more specific factors, such as demand forecasting or market price predictions."""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id')
		, comment="""Link to the specific piece of land the recommendation pertains to.""")
    recommended_crop_variety_id_fk = Column(Integer, ForeignKey('crop_variety.id'), nullable=True
		, comment="""Specific crop variety recommended.""")
    recommendation = Column(Text, nullable=True
		, comment="""Details about the specific recommendation given.""")
    category = Column(Enum(t_recommendation_category), nullable=False)
    farm_input_recommendation = Column(String, nullable=True
		, comment="""Specific farm input (like a type of fertilizer) recommended.""")
    pesticide_recommendation = Column(String, nullable=True
		, comment="""Specific pesticide recommended for use.""")
    land_leveling_technique = Column(String, nullable=True
		, comment="""Recommended technique for land leveling.""")
    expect_yield = Column(Text, nullable=True)
    actual_yield = Column(Text, nullable=True)
    recommended_on = Column(Date, default=func.now(), nullable=True
		, comment="""Date when the recommendation was given.""")
    recommendatio_Valid_till = Column(Date, nullable=True)
    recommended_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""The agronomist or expert who provided the recommendation.""")
    based_on_weather = Column(Boolean, nullable=True
		, comment="""Indicates if the recommendation was based on weather data.""")
    based_on_soil_test = Column(Boolean, nullable=True
		, comment="""Indicates if the recommendation was based on soil test results.""")
    based_on_nearby_performance = Column(Boolean, nullable=True
		, comment="""Indicates if the recommendation was based on performance of similar crops in nearby areas.""")
    land_parcel = relationship(LandParcel, backref='land_use_recommendationss_land_parcel', primaryjoin='LandUseRecommendations.land_parcel_id_fk == LandParcel.id')
    recommended_by = relationship(Person, backref='land_use_recommendationss_recommended_by', primaryjoin='LandUseRecommendations.recommended_by_id_fk == Person.id')
    recommended_crop_variety = relationship(CropVariety, backref='land_use_recommendationss_recommended_crop_variety', primaryjoin='LandUseRecommendations.recommended_crop_variety_id_fk == CropVariety.id')

    def __repr__(self):
       return self.id

 ### 


class Loan(Model):
    __tablename__ = "loan"
    # __table_args__ = ( ) # tuple
    __doc__ = """We will have to calculate derived metrics in a batch, pg_cron maybe"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Unique identifier for the loan""")
    client_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""Foreign key reference to the client organization""")
    fund_id_fk = Column(Integer, ForeignKey('fund.id'), nullable=True
		, comment="""Foreign key reference to the funding source""")
    loan_product_id_fk = Column(Integer, ForeignKey('loan_product.id'), nullable=True
		, comment="""Foreign key reference to the loan product""")
    loan_officer_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Foreign key reference to the loan officer managing the loan""")
    loan_purpose = Column(Text, nullable=True
		, comment="""Purpose for which the loan was issued""")
    loan_status = Column(Enum(t_transaction_status), nullable=False)
    loan_sub_status = Column(Enum(t_loan_sub_status), nullable=False)
    currency_code_id_fk = Column(Integer, ForeignKey('currency.id'), nullable=True
		, comment="""Foreign key reference to the currency code""")
    principal_amount = Column(Numeric
		, comment="""Initial loan amount""")
    arrears_tolerance_amount = Column(Numeric, nullable=True
		, comment="""Amount by which the borrower can be in arrears without triggering specific actions""")
    nominal_interest_rate_per_period = Column(Numeric
		, comment="""Nominal interest rate per defined period""")
    interest_period_frequency = Column(Enum(t_interval), nullable=False)
    annual_nominal_interest_rate = Column(Numeric
		, comment="""Nominal annual interest rate""")
    interest_method = Column(Enum(t_interest_method), nullable=False)
    interest_calculated_in_period = Column(Enum(t_interval), nullable=False)
    term_frequency = Column(Enum(t_interval), nullable=False)
    loan_cycle_number = Column(Integer, nullable=True
		, comment="""Number of loan cycles client has gone through, e.g., first loan, second loan, etc.""")
    repay_every = Column(Enum(t_interval), nullable=False)
    number_of_repayments = Column(Integer
		, comment="""Total number of repayments for this loan""")
    amortization_method = Column(Enum(t_amortization_method), nullable=False)
    submitted_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was submitted for approval""")
    submitted_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who submitted the loan for approval""")
    approved_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was approved""")
    approved_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who approved the loan""")
    expected_disbursed_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Expected date for loan disbursement""")
    expected_first_repayment_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Expected date for the first repayment""")
    disbursed_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Actual date of loan disbursement""")
    disbursed_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who performed the loan disbursement""")
    interest_calculated_from_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date from which interest calculation starts""")
    closed_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was closed""")
    closed_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who closed the loan""")
    rejected_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was rejected""")
    rejected_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who rejected the loan""")
    rescheduled_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was rescheduled""")
    withdrawn_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was withdrawn""")
    withdrawn_on_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who withdrew the loan""")
    written_off_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date the loan was written off""")
    written_off_user_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""User who wrote off the loan""")
    expected_maturity_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Expected date the loan will fully mature""")
    matured_on_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Actual date the loan matured""")
    loan_transaction_strategy_id_fk = Column(Integer, ForeignKey('loan_transaction_strategy.id'), nullable=True
		, comment="""Strategy used for loan transactions, ref strategy table""")
    total_charges_due_at_disbursement_derived = Column(Numeric, nullable=True
		, comment="""Sum of all charges that are due at the time of loan disbursement""")
    principal_disbursed_derived = Column(Numeric
		, comment="""Total principal amount that has been disbursed""")
    principal_repaid_derived = Column(Numeric
		, comment="""Total principal amount that has been repaid""")
    principal_writtenoff_derived = Column(Numeric
		, comment="""Total principal amount that has been written off""")
    principal_outstanding_derived = Column(Numeric
		, comment="""Total principal amount that is currently outstanding""")
    interest_charged_derived = Column(Numeric
		, comment="""Total interest that has been charged""")
    interest_repaid_derived = Column(Numeric
		, comment="""Total interest that has been repaid""")
    interest_waived_derived = Column(Numeric
		, comment="""Total interest amount that has been waived""")
    interest_writtenoff_derived = Column(Numeric
		, comment="""Total interest amount that has been written off""")
    interest_outstanding_derived = Column(Numeric
		, comment="""Total interest amount that is currently outstanding""")
    fee_charges_charged_derived = Column(Numeric
		, comment="""Total fees that have been charged""")
    fee_charges_repaid_derived = Column(Numeric
		, comment="""Total fees that have been repaid""")
    fee_charges_waived_derived = Column(Numeric
		, comment="""Total fees that have been waived""")
    fee_charges_writtenoff_derived = Column(Numeric
		, comment="""Total fees that have been written off""")
    fee_charges_outstanding_derived = Column(Numeric
		, comment="""Total fees that are currently outstanding""")
    penalty_charges_charged_derived = Column(Numeric
		, comment="""Total penalty charges that have been levied""")
    penalty_charges_repaid_derived = Column(Numeric
		, comment="""Total penalty charges that have been repaid""")
    penalty_charges_waived_derived = Column(Numeric
		, comment="""Total penalty charges that have been waived""")
    penalty_charges_writtenoff_derived = Column(Numeric
		, comment="""Total penalty charges that have been written off""")
    penalty_charges_outstanding_derived = Column(Numeric
		, comment="""Total penalty charges that are currently outstanding""")
    total_expected_repayment_derived = Column(Numeric
		, comment="""Total amount expected to be repaid, including principal, interest, fees, and penalties""")
    total_repayment_derived = Column(Numeric
		, comment="""Total amount that has been actually repaid""")
    total_expected_cost_of_loan_derived = Column(Numeric
		, comment="""Total expected cost of the loan, calculated as the sum of principal, interest, fees, and penalties""")
    total_costofloan_derived = Column(Numeric
		, comment="""Total actual cost of the loan, calculated based on repayments and other derived fields""")
    total_waived_derived = Column(Numeric
		, comment="""Total amount that has been waived, including interest, fees, and penalties""")
    total_writtenoff_derived = Column(Numeric
		, comment="""Total amount that has been written off, including principal, interest, fees, and penalties""")
    total_outstanding_derived = Column(Numeric
		, comment="""Total amount currently outstanding, calculated as the difference between total_expected_repayment_derived and total_repayment_derived""")
    loan_to_value_ratio_derived = Column(Numeric, nullable=True
		, comment="""Calculated as the loan amount divided by the appraised value of the collateral. Useful for risk assessment.""")
    debt_to_income_ratio_derived = Column(Numeric, nullable=True
		, comment="""Ratio of borrower’s total debt payments to income. Important for evaluating borrower’s ability to repay.""")
    credit_score_derived = Column(Integer, nullable=True
		, comment="""Credit score of the borrower at the time of loan origination or most recent update. Useful for risk profiling.""")
    payment_to_income_ratio_derived = Column(Numeric, nullable=True
		, comment="""Ratio of the monthly loan payment to the borrower’s monthly income.""")
    interest_rate_spread_derived = Column(Numeric, nullable=True
		, comment="""Difference between the loan interest rate and the current base rate.""")
    yield_to_maturity_derived = Column(Numeric, nullable=True
		, comment="""The total yield that would be received if the loan is held until maturity.""")
    effective_annual_rate_derived = Column(Numeric, nullable=True
		, comment="""The annual rate of interest adjusted for the effects of compounding over the course of a year.""")
    days_past_due_derived = Column(Integer, nullable=True
		, comment="""Number of days payment is overdue.""")
    days_to_maturity_derived = Column(Integer, nullable=True
		, comment="""Number of days left for the loan to reach maturity.""")
    missed_payments_count_derived = Column(Integer, nullable=True
		, comment="""Number of missed payments.""")
    on_time_payments_count_derived = Column(Integer, nullable=True
		, comment="""Number of payments made on time.""")
    overpayments_count_derived = Column(Integer, nullable=True
		, comment="""Number of payments exceeding the required amount.""")
    underpayments_count_derived = Column(Integer, nullable=True
		, comment="""Number of payments less than the required amount.""")
    collateral_exposure_derived = Column(Numeric, nullable=True
		, comment="""Value of collateralized assets, reduced by depreciation or other factors.""")
    unsecured_exposure_derived = Column(Numeric, nullable=True
		, comment="""Loan amount that is unsecured by any collateral.""")
    sectoral_exposure_derived = Column(String, nullable=True
		, comment="""Type of economic sector the loan is exposed to (e.g., Real Estate, Agriculture).""")
    inflation_adjusted_principal_outstanding_derived = Column(Numeric, nullable=True
		, comment="""Principal outstanding, adjusted for inflation.""")
    inflation_adjusted_total_repayment_derived = Column(Numeric, nullable=True
		, comment="""Total repayment, adjusted for inflation.""")
    prepayment_amount_derived = Column(Numeric, nullable=True
		, comment="""Total amount that has been prepaid.""")
    prepayment_frequency_derived = Column(Integer, nullable=True
		, comment="""Number of times prepayment has been made.""")
    net_present_value_derived = Column(Numeric, nullable=True
		, comment="""Net present value of the loan, considering cash flows and discount rate.""")
    internal_rate_of_return_derived = Column(Numeric, nullable=True
		, comment="""The discount rate that makes the net present value of the loan’s cash flow zero.""")
    profitability_index_derived = Column(Numeric, nullable=True
		, comment="""Ratio of the present value of cash inflows to the present value of cash outflows.""")
    note = Column(Text, nullable=True)
    approved_on_user = relationship(Person, backref='loans_approved_on_user', primaryjoin='Loan.approved_on_user_id_fk == Person.id')
    client = relationship(Org, backref='loans_client', primaryjoin='Loan.client_id_fk == Org.id')
    closed_on_user = relationship(Person, backref='loans_closed_on_user', primaryjoin='Loan.closed_on_user_id_fk == Person.id')
    currency_code = relationship(Currency, backref='loans_currency_code', primaryjoin='Loan.currency_code_id_fk == Currency.id')
    disbursed_on_user = relationship(Person, backref='loans_disbursed_on_user', primaryjoin='Loan.disbursed_on_user_id_fk == Person.id')
    fund = relationship(Fund, backref='loans_fund', primaryjoin='Loan.fund_id_fk == Fund.id')
    loan_officer = relationship(Person, backref='loans_loan_officer', primaryjoin='Loan.loan_officer_id_fk == Person.id')
    loan_product = relationship(LoanProduct, backref='loans_loan_product', primaryjoin='Loan.loan_product_id_fk == LoanProduct.id')
    loan_transaction_strategy = relationship(LoanTransactionStrategy, backref='loans_loan_transaction_strategy', primaryjoin='Loan.loan_transaction_strategy_id_fk == LoanTransactionStrategy.id')
    rejected_on_user = relationship(Person, backref='loans_rejected_on_user', primaryjoin='Loan.rejected_on_user_id_fk == Person.id')
    submitted_on_user = relationship(Person, backref='loans_submitted_on_user', primaryjoin='Loan.submitted_on_user_id_fk == Person.id')
    withdrawn_on_user = relationship(Person, backref='loans_withdrawn_on_user', primaryjoin='Loan.withdrawn_on_user_id_fk == Person.id')
    written_off_user = relationship(Person, backref='loans_written_off_user', primaryjoin='Loan.written_off_user_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class LoanProductStrategyOverride(Model):
    __tablename__ = "loan_product_strategy_override"
    # __table_args__ = ( ) # tuple
    __doc__ = """Table to capture strategy overrides for specific loan products"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True
		, comment="""Primary key, auto-incremented""")
    loan_product_id_fk = Column(BigInteger, ForeignKey('loan_product.id')
		, comment="""Foreign key to the loan product for which this strategy is being overridden""")
    strategy_id_fk = Column(BigInteger, ForeignKey('loan_transaction_strategy.id')
		, comment="""Foreign key to the strategy to be used as override""")
    start_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Effective start date for this strategy override""")
    end_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Effective end date for this strategy override""")
    note = Column(Text, nullable=True)
    loan_product = relationship(LoanProduct, backref='loan_product_strategy_overrides_loan_product', primaryjoin='LoanProductStrategyOverride.loan_product_id_fk == LoanProduct.id')
    strategy = relationship(LoanTransactionStrategy, backref='loan_product_strategy_overrides_strategy', primaryjoin='LoanProductStrategyOverride.strategy_id_fk == LoanTransactionStrategy.id')

    def __repr__(self):
       return self.id

 ### 


class OpportunityPipelineStageLink(Model):
    __tablename__ = "opportunity_pipeline_stage_link"
    # __table_args__ = ( ) # tuple
    __doc__ = """Each opportunity gets put into the pipeline and is tracked through every stage"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    pipeline_stage_id_fk = Column(Integer, ForeignKey('pipeline_stages.id'), nullable=True
		, comment="""Link to the stage of the pipeline the opportunity is currently at.""")
    opportunity_id_fk = Column(Integer, ForeignKey('opportunity.id')
		, comment="""Link to the opportunity being progressed through the pipeline.""")
    pipeline_stage = Column(Enum(t_pipeline_stages), nullable=False)
    time_in_stage = Column(Integer, nullable=True
		, comment="""The duration of the opportunity at this stage in the pipeline""")
    entered_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True
		, comment="""Timestamp when the opportunity entered this stage.""")
    expected_exit_date = Column(Date, nullable=True
		, comment="""Projected date when the opportunity might move to the next stage or exit this stage.""")
    actual_exit_date = Column(Date, nullable=True)
    contact_notes = Column(Text, nullable=True
		, comment="""Any additional notes or comments about the opportunity at this stage.""")
    next_steps = Column(Text, nullable=True
		, comment="""Text outlining the immediate next actions to progress the opportunity.""")
    progressed_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Who moved this opportunity to this stage""")
    execute_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""who is supposed to develop this opportunity""")
    approve_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""Who verified that the necessary actions have been undertaken""")
    approve_latest_on = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When should the verfification be complete""")
    escalate_to_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True
		, comment="""if note executed and approved on time, exscalate to whoi""")
    escalate_latest_on = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Escalate if not done or approved by this date""")
    status = Column(Enum(t_doc_status), nullable=False)
    approve_by = relationship(Person, backref='opportunity_pipeline_stage_links_approve_by', primaryjoin='OpportunityPipelineStageLink.approve_by_id_fk == Person.id')
    escalate_to = relationship(Person, backref='opportunity_pipeline_stage_links_escalate_to', primaryjoin='OpportunityPipelineStageLink.escalate_to_id_fk == Person.id')
    execute_by = relationship(Person, backref='opportunity_pipeline_stage_links_execute_by', primaryjoin='OpportunityPipelineStageLink.execute_by_id_fk == Person.id')
    opportunity = relationship(Opportunity, backref='opportunity_pipeline_stage_links_opportunity', primaryjoin='OpportunityPipelineStageLink.opportunity_id_fk == Opportunity.id')
    pipeline_stage = relationship(PipelineStages, backref='opportunity_pipeline_stage_links_pipeline_stage', primaryjoin='OpportunityPipelineStageLink.pipeline_stage_id_fk == PipelineStages.id')
    progressed_by = relationship(Person, backref='opportunity_pipeline_stage_links_progressed_by', primaryjoin='OpportunityPipelineStageLink.progressed_by_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class Rack(Model):
    __tablename__ = "rack"
    # __table_args__ = ( ) # tuple
    __doc__ = """ A racks is in a aisle"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    aisle_id_fk = Column(Integer, ForeignKey('aisle.id'), nullable=True
		, comment="""Link to the parent aisle""")
    rack_code = Column(String, nullable=True
		, comment="""Unique identifier for the rack""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Is the rack in active use?""")
    aisle = relationship(Aisle, backref='racks_aisle', primaryjoin='Rack.aisle_id_fk == Aisle.id')

    def __repr__(self):
       return self.id

 ### 


class SoilTests(Model):
    __tablename__ = "soil_tests"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id'))
    sample_depth = Column(Float, nullable=True
		, comment="""Depth at which the soil sample was taken, in meters""")
    test_date = Column(Date, nullable=True
		, comment="""Date of the soil test""")
    tested_by_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True
		, comment="""ID of the lab that conducted the test""")
    ph_level = Column(Float, nullable=True
		, comment="""Soil pH level""")
    organic_matter_percentage = Column(Float, nullable=True
		, comment="""Percentage of organic matter in the soil""")
    texture = Column(Enum(t_soil_texture), nullable=False)
    nitrogen_level = Column(Float, nullable=True
		, comment="""Level of Nitrogen in the soil""")
    phosphorus_level = Column(Float, nullable=True
		, comment="""Level of Phosphorus in the soil""")
    potassium_level = Column(Float, nullable=True
		, comment="""Level of Potassium in the soil""")
    calcium_level = Column(Float, nullable=True
		, comment="""Level of Calcium in the soil""")
    magnesium_level = Column(Float, nullable=True
		, comment="""Level of Magnesium in the soil""")
    sulfur_level = Column(Float, nullable=True
		, comment="""Level of Sulfur in the soil""")
    iron_level = Column(Float, nullable=True
		, comment="""Level of Iron in the soil""")
    manganese_level = Column(Float, nullable=True
		, comment="""Level of Manganese in the soil""")
    copper_level = Column(Float, nullable=True
		, comment="""Level of Copper in the soil""")
    zinc_level = Column(Float, nullable=True
		, comment="""Level of Zinc in the soil""")
    boron_level = Column(Float, nullable=True
		, comment="""Level of Boron in the soil""")
    recommendations = Column(Text, nullable=True
		, comment="""Recommended actions based on soil test""")
    created_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp of when the record was created""")
    updated_at = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Timestamp of the most recent update""")
    land_parcel = relationship(LandParcel, backref='soil_testss_land_parcel', primaryjoin='SoilTests.land_parcel_id_fk == LandParcel.id')
    tested_by = relationship(Org, backref='soil_testss_tested_by', primaryjoin='SoilTests.tested_by_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class Waypoint(Model):
    __tablename__ = "waypoint"
    # __table_args__ = ( ) # tuple
    __doc__ = """So that people can walk their boundaries"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    land_parcel_id_fk = Column(Integer, ForeignKey('land_parcel.id'))
    waypoint_data = Column(Text, nullable=True)
    waypoint_reg_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    waypoint_reg_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    meter_interval = Column(Integer, nullable=True)
    land_parcel = relationship(LandParcel, backref='waypoints_land_parcel', primaryjoin='Waypoint.land_parcel_id_fk == LandParcel.id')
    waypoint_reg_by = relationship(Person, backref='waypoints_waypoint_reg_by', primaryjoin='Waypoint.waypoint_reg_by_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class LoanArrearsAging(Model):
    __tablename__ = "loan_arrears_aging"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    overdue_since_date_derived = Column(Date, nullable=True)
    notification_status = Column(Enum(t_doc_status), nullable=False)
    principal_overdue_derived = Column(Numeric)
    interest_overdue_derived = Column(Numeric)
    fee_charges_overdue_derived = Column(Numeric)
    penalty_charges_overdue_derived = Column(Numeric)
    total_overdue_derived = Column(Numeric)
    loan = relationship(Loan, backref='loan_arrears_agings_loan', primaryjoin='LoanArrearsAging.loan_id_fk == Loan.id')

    def __repr__(self):
       return self.id

 ### 


class LoanCharge(Model):
    __tablename__ = "loan_charge"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    charge_id = Column(Integer, autoincrement=True)
    charge_time = Column(Enum(t_interval), nullable=False)
    calc_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    due_for_collection_as_of_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    charge_calculation = Column(Enum(t_interval), nullable=False)
    calculation_percentage = Column(Numeric, nullable=True)
    calculation_on_amount = Column(Numeric, nullable=True)
    amount = Column(Numeric)
    amount_paid_derived = Column(Numeric, nullable=True)
    amount_waived_derived = Column(Numeric, nullable=True)
    amount_writtenoff_derived = Column(Numeric, nullable=True)
    amount_outstanding_derived = Column(Numeric)
    is_penalty = Column(Boolean, default=False)
    is_active = Column(Boolean, default=False)
    is_deleted = Column(Boolean, default=False)
    is_paid = Column(Boolean, default=False)
    is_waived = Column(Boolean, default=False)
    loan = relationship(Loan, backref='loan_charges_loan', primaryjoin='LoanCharge.loan_id_fk == Loan.id')

    def __repr__(self):
       return self.id

 ### 


class LoanCollateral(Model):
    __tablename__ = "loan_collateral"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    collateral_id_fk = Column(Integer, ForeignKey('doc.id'), nullable=True)
    value = Column(Numeric, nullable=True)
    description = Column(String, nullable=True)
    collateral = relationship(Doc, backref='loan_collaterals_collateral', primaryjoin='LoanCollateral.collateral_id_fk == Doc.id')
    loan = relationship(Loan, backref='loan_collaterals_loan', primaryjoin='LoanCollateral.loan_id_fk == Loan.id')

    def __repr__(self):
       return self.id

 ### 


class LoanGuarantor(Model):
    __tablename__ = "loan_guarantor"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    guarantor_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    guarantor_type = Column(Enum(t_guarantor_type), nullable=False)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    comment = Column(Text, nullable=True)
    guarantor = relationship(Person, backref='loan_guarantors_guarantor', primaryjoin='LoanGuarantor.guarantor_id_fk == Person.id')
    loan = relationship(Loan, backref='loan_guarantors_loan', primaryjoin='LoanGuarantor.loan_id_fk == Loan.id')
    org = relationship(Org, backref='loan_guarantors_org', primaryjoin='LoanGuarantor.org_id_fk == Org.id')

    def __repr__(self):
       return self.id

 ### 


class LoanOfficerAssignmentHistory(Model):
    __tablename__ = "loan_officer_assignment_history"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    loan_officer_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    start_date = Column(DateTime, server_default=text('NOW()'))
    end_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    loan = relationship(Loan, backref='loan_officer_assignment_historys_loan', primaryjoin='LoanOfficerAssignmentHistory.loan_id_fk == Loan.id')
    loan_officer = relationship(Person, backref='loan_officer_assignment_historys_loan_officer', primaryjoin='LoanOfficerAssignmentHistory.loan_officer_id_fk == Person.id')

    def __repr__(self):
       return self.id

 ### 


class LoanRepaymentSchedule(Model):
    __tablename__ = "loan_repayment_schedule"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    loan_id_fk = Column(Integer, ForeignKey('loan.id'), nullable=True)
    from_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    repayment_interval = Column(Enum(t_interval), nullable=False)
    repayment_number = Column(Integer)
    due_date = Column(DateTime, server_default=text('NOW()'))
    installment = Column(SmallInteger)
    principal_amount = Column(Numeric, nullable=True)
    principal_completed_derived = Column(Numeric, nullable=True)
    principal_writtenoff_derived = Column(Numeric, nullable=True)
    interest_amount = Column(Numeric, nullable=True)
    interest_completed_derived = Column(Numeric, nullable=True)
    interest_writtenoff_derived = Column(Numeric, nullable=True)
    fee_charges_amount = Column(Numeric, nullable=True)
    fee_charges_completed_derived = Column(Numeric, nullable=True)
    fee_charges_writtenoff_derived = Column(Numeric, nullable=True)
    fee_charges_waived_derived = Column(Numeric, nullable=True)
    penalty_charges_amount = Column(Numeric, nullable=True)
    penalty_charges_completed_derived = Column(Numeric, nullable=True)
    penalty_charges_writtenoff_derived = Column(Numeric, nullable=True)
    penalty_charges_waived_derived = Column(Numeric, nullable=True)
    completed_derived = Column(Boolean, nullable=True)
    interest_waived_derived = Column(Numeric, nullable=True)
    loan = relationship(Loan, backref='loan_repayment_schedules_loan', primaryjoin='LoanRepaymentSchedule.loan_id_fk == Loan.id')

    def __repr__(self):
       return self.id

 ### 


class Shelf(Model):
    __tablename__ = "shelf"
    # __table_args__ = ( ) # tuple
    __doc__ = """ A Shelf is on a Rack"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    rack_id_fk = Column(Integer, ForeignKey('rack.id'), nullable=True
		, comment="""Link to the parent rack""")
    shelf_code = Column(String, nullable=True
		, comment="""Unique identifier for the shelf""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Is the shelf in active use?""")
    rack = relationship(Rack, backref='shelfs_rack', primaryjoin='Shelf.rack_id_fk == Rack.id')

    def __repr__(self):
       return self.id

 ### 


class WaypointAudit(Model):
    __tablename__ = "waypoint_audit"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    waypoint_id_fk = Column(Integer, ForeignKey('waypoint.id'))
    action = Column(Enum(t_waypoint_audit_action), nullable=False)
    action_by_id_fk = Column(Integer, ForeignKey('person.id'), nullable=True)
    action_at = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    action_by = relationship(Person, backref='waypoint_audits_action_by', primaryjoin='WaypointAudit.action_by_id_fk == Person.id')
    waypoint = relationship(Waypoint, backref='waypoint_audits_waypoint', primaryjoin='WaypointAudit.waypoint_id_fk == Waypoint.id')

    def __repr__(self):
       return self.id

 ### 


class Bin(Model):
    __tablename__ = "bin"
    # __table_args__ = ( ) # tuple
    __doc__ = """ A bin is on a shelf, we store stuff here"""
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    shelf_id_fk = Column(Integer, ForeignKey('shelf.id'), nullable=True
		, comment="""Link to the parent shelf""")
    bin_code = Column(String, nullable=True
		, comment="""Unique identifier for the bin""")
    is_active = Column(Boolean, default=True, nullable=True
		, comment="""Is the bin in active use?""")
    shelf = relationship(Shelf, backref='bins_shelf', primaryjoin='Bin.shelf_id_fk == Shelf.id')

    def __repr__(self):
       return self.id

 ### 


class Inventory(Model):
    __tablename__ = "inventory"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    org_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    bin_id_fk = Column(Integer, ForeignKey('bin.id'), nullable=True
		, comment="""Link to the bin where the inventory is stored""")
    batch_number = Column(String, nullable=True
		, comment="""Batch or lot number especially for perishables or medical items""")
    quantity = Column(Integer, nullable=True
		, comment="""Total number of items in this inventory record""")
    reorder_level = Column(Integer, nullable=True
		, comment="""Minimum number before a reorder is needed""")
    is_serialized = Column(Boolean, default=False, nullable=True
		, comment="""If items have unique serial numbers""")
    is_perishable = Column(Boolean, default=False, nullable=True
		, comment="""If items expire or are perishable""")
    production_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When the product was made""")
    expiration_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When the product expires""")
    best_by_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Suggested best use by date""")
    bin = relationship(Bin, backref='inventorys_bin', primaryjoin='Inventory.bin_id_fk == Bin.id')
    org = relationship(Org, backref='inventorys_org', primaryjoin='Inventory.org_id_fk == Org.id')
    product = relationship(ProductSkuLink, backref='inventorys_product', primaryjoin='Inventory.product_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.id

 ### 


class InventoryLog(Model):
    __tablename__ = "inventory_log"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    inventory_id_fk = Column(Integer, ForeignKey('inventory.id'), nullable=True)
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'), nullable=True)
    bin_id_fk = Column(Integer, ForeignKey('bin.id'), nullable=True
		, comment="""Link to the bin where the inventory is stored""")
    changed_by_id_fk = Column(Integer, ForeignKey('org.id'), nullable=True)
    change_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Date of change""")
    quantity = Column(Integer, nullable=True
		, comment="""Amount of stock added or removed""")
    reason = Column(String, nullable=True
		, comment="""The rationale for the change e.g., Sold, Received, Damaged""")
    is_perishable = Column(Boolean, nullable=True
		, comment="""Is the item perishable?""")
    production_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When was the product made""")
    expiration_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When does the product expire""")
    best_by_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""Suggested best consumption by date""")
    bin = relationship(Bin, backref='inventory_logs_bin', primaryjoin='InventoryLog.bin_id_fk == Bin.id')
    changed_by = relationship(Org, backref='inventory_logs_changed_by', primaryjoin='InventoryLog.changed_by_id_fk == Org.id')
    inventory = relationship(Inventory, backref='inventory_logs_inventory', primaryjoin='InventoryLog.inventory_id_fk == Inventory.id')
    product = relationship(ProductSkuLink, backref='inventory_logs_product', primaryjoin='InventoryLog.product_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.id

 ### 


class PerishableItemAlerts(Model):
    __tablename__ = "perishable_item_alerts"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    inventory_id_fk = Column(Integer, ForeignKey('inventory.id'))
    alert_level = Column(Enum(t_severity_level), nullable=False)
    alert_date = Column(DateTime, server_default=text('NOW()'), default=func.now(), nullable=True)
    note = Column(Text, nullable=True)
    sent = Column(Boolean, nullable=True)
    sent_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    received = Column(Boolean, nullable=True)
    received_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    inventory = relationship(Inventory, backref='perishable_item_alertss_inventory', primaryjoin='PerishableItemAlerts.inventory_id_fk == Inventory.id')

    def __repr__(self):
       return self.id

 ### 


class SerializedItems(Model):
    __tablename__ = "serialized_items"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    serial_number = Column(String
		, comment="""Should not be null if is_serialized""")
    product_id_fk = Column(Integer, ForeignKey('product_sku_link.id'))
    inventory_id_fk = Column(Integer, ForeignKey('inventory.id'))
    status = Column(String
		, comment="""Condition of the product""")
    received_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When the product was received""")
    sold_date = Column(DateTime, server_default=text('NOW()'), nullable=True
		, comment="""When the product was sold""")
    is_perishable = Column(Boolean, nullable=True)
    production_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    expiration_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    best_by_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    is_expired = Column(Boolean, default=False, nullable=True
		, comment="""Is the product expired?""")
    shelf_life_days = Column(Integer, nullable=True
		, comment="""Days before expiry""")
    inventory = relationship(Inventory, backref='serialized_itemss_inventory', primaryjoin='SerializedItems.inventory_id_fk == Inventory.id')
    product = relationship(ProductSkuLink, backref='serialized_itemss_product', primaryjoin='SerializedItems.product_id_fk == ProductSkuLink.id')

    def __repr__(self):
       return self.id

 ### 


class InventorySerialLog(Model):
    __tablename__ = "inventory_serial_log"
    # __table_args__ = ( ) # tuple
    # class_permission_name = "view"
    id = Column(Integer, primary_key=True, autoincrement=True)
    serialized_item_id_fk = Column(Integer, ForeignKey('serialized_items.id'))
    inventory_id_fk = Column(Integer, ForeignKey('inventory.id'))
    bin_id_fk = Column(Integer, ForeignKey('bin.id'), nullable=True
		, comment="""Link to the bin where the inventory is stored""")
    changed_by_id_fk = Column(Integer, ForeignKey('org.id'))
    change_date = Column(DateTime, server_default=text('NOW()'), nullable=True)
    status = Column(String, nullable=True
		, comment="""The product’s new state""")
    reason = Column(String, nullable=True
		, comment="""Why was the change made?""")
    bin = relationship(Bin, backref='inventory_serial_logs_bin', primaryjoin='InventorySerialLog.bin_id_fk == Bin.id')
    changed_by = relationship(Org, backref='inventory_serial_logs_changed_by', primaryjoin='InventorySerialLog.changed_by_id_fk == Org.id')
    inventory = relationship(Inventory, backref='inventory_serial_logs_inventory', primaryjoin='InventorySerialLog.inventory_id_fk == Inventory.id')
    serialized_item = relationship(SerializedItems, backref='inventory_serial_logs_serialized_item', primaryjoin='InventorySerialLog.serialized_item_id_fk == SerializedItems.id')

    def __repr__(self):
       return self.id

 ### 

