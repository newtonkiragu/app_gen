# Generated by corecel

from sqlalchemy import create_engine, MetaData
from sqlalchemy.schema import ForeignKeyConstraint

# Configuration
#DATABASE_URI = 'postgresql://username:password@localhost:5432/mydatabase'
DATABASE_URI = 'postgresql://wakala'
OUTPUT_MODELS_FILE = 'models.py'
OUTPUT_VIEWS_FILE = 'views.py'
OUTPUT_API_FILE = 'api.py'


# Connect to the PostgreSQL database
engine = create_engine(DATABASE_URI)
metadata = MetaData()
metadata.reflect(bind=engine)

# Generate models.py
with open(OUTPUT_MODELS_FILE, 'w') as models_file:
    models_file.write('from flask_appbuilder import Model\n')
    models_file.write('from sqlalchemy import Column, Integer, String, ForeignKey\n')
    models_file.write('from sqlalchemy.orm import relationship\n\n')

    # Track relationships for MultipleView generation
    relationships = {}
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        models_file.write(f'class {model_name}(Model):\n')
        models_file.write(f'    __tablename__ = "{table.name}"\n')

        # Write columns
        for column in table.columns:
            column_type = str(column.type)
            if column.foreign_keys:
                fk = next(iter(column.foreign_keys))
                models_file.write(f'    {column.name} = Column({column_type}, ForeignKey("{fk.target_fullname}"))\n')
            else:
                models_file.write(f'    {column.name} = Column({column_type})\n')

        # Write relationships
        for fk in table.foreign_key_constraints:
            referred_table = fk.referred_table.name.capitalize()
            constraint_name = fk.name if fk.name else f"{table.name}_to_{referred_table}"
            models_file.write(f'    {constraint_name} = relationship("{referred_table}")\n')

        models_file.write('\n')

print(f'Models written to {OUTPUT_MODELS_FILE}')

# Generate views.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file:
    views_file.write('from flask_appbuilder import ModelView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    # Generate ModelViews for all tables
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        columns = table.columns
        list_columns = [column.name for column in columns]
        label_columns = {column.name: column.name.capitalize().replace('_', ' ') for column in columns}
        show_fieldsets = [
            (None, {'fields': list_columns})
        ]

        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n')
        views_file.write(f'    list_columns = {list_columns}\n')
        views_file.write(f'    label_columns = {label_columns}\n')
        views_file.write(f'    show_fieldsets = {show_fieldsets}\n\n')

        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')


#===================
from sqlalchemy import create_engine, MetaData

# Configuration
DATABASE_URI = 'postgresql://username:password@localhost:5432/mydatabase'
OUTPUT_MODELS_FILE = 'models.py'
OUTPUT_VIEWS_FILE = 'views.py'

# Connect to the PostgreSQL database
engine = create_engine(DATABASE_URI)
metadata = MetaData()
metadata.reflect(bind=engine)

# Generate models.py
with open(OUTPUT_MODELS_FILE, 'w') as models_file:
    models_file.write('from flask_appbuilder import Model\n')
    models_file.write('from sqlalchemy import Column, Integer, String, ForeignKey\n')
    models_file.write('from sqlalchemy.orm import relationship\n\n')

    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        models_file.write(f'class {model_name}(Model):\n')
        models_file.write(f'    __tablename__ = "{table.name}"\n')

        # Write columns
        for column in table.columns:
            column_type = str(column.type)
            if column.foreign_keys:
                fk = next(iter(column.foreign_keys))
                models_file.write(f'    {column.name} = Column({column_type}, ForeignKey("{fk.target_fullname}"))\n')
            else:
                models_file.write(f'    {column.name} = Column({column_type})\n')

        # Write relationships
        for fk in table.foreign_keys:
            parent_table = fk.column.table.name
            parent_model_name = parent_table.capitalize()
            child_model_name = fk.parent.table.name
            relationship_name = f'{parent_model_name}_{child_model_name}'.lower()
            models_file.write(f'    {relationship_name} = relationship("{parent_model_name}")\n')

        models_file.write('\n')

print(f'Models written to {OUTPUT_MODELS_FILE}')

# Generate views.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file:
    views_file.write('from flask_appbuilder import ModelView, MasterDetailView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')

        # Check for foreign keys and add master-detail views if necessary
        for fk in table.foreign_keys:
            parent_table = fk.column.table.name
            parent_model_name = parent_table.capitalize()
            child_model_name = fk.parent.table.name
            relationship_name = f'{parent_model_name}_{child_model_name}'.lower()
            views_file.write(f'class {model_name}MasterDetailView(MasterDetailView):\n')
            views_file.write(f'    datamodel = SQLAInterface({parent_model_name})\n')
            views_file.write(f'    related_views = [{model_name}View]\n\n')

        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')


from sqlalchemy import create_engine, MetaData

# Configuration
DATABASE_URI = 'postgresql://username:password@localhost:5432/mydatabase'
OUTPUT_MODELS_FILE = 'models.py'
OUTPUT_VIEWS_FILE = 'views.py'

# Connect to the PostgreSQL database
engine = create_engine(DATABASE_URI)
metadata = MetaData()
metadata.reflect(bind=engine)

# Generate models.py
with open(OUTPUT_MODELS_FILE, 'w') as models_file:
    models_file.write('from flask_appbuilder import Model\n')
    models_file.write('from sqlalchemy import Column, Integer, String, ForeignKey\n')
    models_file.write('from sqlalchemy.orm import relationship\n\n')

    # Track relationships for MultipleView generation
    relationships = {}

    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        models_file.write(f'class {model_name}(Model):\n')
        models_file.write(f'    __tablename__ = "{table.name}"\n')

        # Write columns
        for column in table.columns:
            column_type = str(column.type)
            if column.foreign_keys:
                fk = next(iter(column.foreign_keys))
                models_file.write(f'    {column.name} = Column({column_type}, ForeignKey("{fk.target_fullname}"))\n')
                # Add to relationships for later MultipleView generation
                parent_table = fk.column.table.name
                if parent_table not in relationships:
                    relationships[parent_table] = []
                relationships[parent_table].append((model_name, table.name))
            else:
                models_file.write(f'    {column.name} = Column({column_type})\n')

        models_file.write('\n')

print(f'Models written to {OUTPUT_MODELS_FILE}')

# Generate views.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file:
    views_file.write('from flask_appbuilder import ModelView, MultipleView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    # Generate ModelViews for all tables
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')

    # Generate MultipleViews for tables with relationships
    for parent_table, related_tables in relationships.items():
        parent_model_name = parent_table.capitalize()
        views_file.write(f'class {parent_model_name}MultipleView(MultipleView):\n')
        views_file.write(f'    views = [')
        for model_name, _ in related_tables:
            views_file.write(f'{model_name}View, ')
        views_file.write(']\n\n')

        views_file.write(f'appbuilder.add_view({parent_model_name}MultipleView, "{parent_model_name} Details", category="Menu")\n\n')

    # Add ModelViews to the menu
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')

#=====================================================
from sqlalchemy import create_engine, MetaData

#=====================================================

# Configuration
DATABASE_URI = 'postgresql://username:password@localhost:5432/mydatabase'
OUTPUT_MODELS_FILE = 'models.py'
OUTPUT_VIEWS_FILE = 'views.py'
OUTPUT_API_FILE = 'api.py'

# Connect to the PostgreSQL database
engine = create_engine(DATABASE_URI)
metadata = MetaData()
metadata.reflect(bind=engine)

# Generate models.py
with open(OUTPUT_MODELS_FILE, 'w') as models_file:
    models_file.write('from flask_appbuilder import Model\n')
    models_file.write('from sqlalchemy import Column, Integer, String, ForeignKey\n')
    models_file.write('from sqlalchemy.orm import relationship\n\n')

    # Track relationships for MultipleView generation
    relationships = {}

    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        models_file.write(f'class {model_name}(Model):\n')
        models_file.write(f'    __tablename__ = "{table.name}"\n')

        # Write columns
        for column in table.columns:
            column_type = str(column.type)
            if column.foreign_keys:
                fk = next(iter(column.foreign_keys))
                models_file.write(f'    {column.name} = Column({column_type}, ForeignKey("{fk.target_fullname}"))\n')
                # Add to relationships for later MultipleView generation
                parent_table = fk.column.table.name
                if parent_table not in relationships:
                    relationships[parent_table] = []
                relationships[parent_table].append((model_name, table.name))
            else:
                models_file.write(f'    {column.name} = Column({column_type})\n')

        models_file.write('\n')

print(f'Models written to {OUTPUT_MODELS_FILE}')

# Generate views.py and api.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file, open(OUTPUT_API_FILE, 'w') as api_file:
    views_file.write('from flask_appbuilder import ModelView, MultipleView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    api_file.write('from flask_appbuilder.api import BaseApi, expose\n')
    api_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    api_file.write('from . import appbuilder, db\n')
    api_file.write('from .models import *\n\n')

    # Generate ModelViews and ModelRestApi for all tables
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')

        api_file.write(f'class {model_name}RestApi(BaseApi):\n')
        api_file.write(f'    resource_name = "{table.name}"\n')
        api_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')
        api_file.write('    @expose("/", methods=["GET"])\n')
        api_file.write('    def get_list(self):\n')
        api_file.write('        """Get list of records."""\n')
        api_file.write('        return self.list()\n\n')
        api_file.write('    @expose("/<pk>", methods=["GET"])\n')
        api_file.write('    def get_item(self, pk):\n')
        api_file.write('        """Get record by primary key."""\n')
        api_file.write('        return self.show(pk)\n\n')
        api_file.write('    @expose("/", methods=["POST"])\n')
        api_file.write('    def post(self):\n')
        api_file.write('        """Create a new record."""\n')
        api_file.write('        return self.post()\n\n')
        api_file.write('    @expose("/<pk>", methods=["PUT"])\n')
        api_file.write('    def put(self, pk):\n')
        api_file.write('        """Update existing record."""\n')
        api_file.write('        return self.edit(pk)\n\n')
        api_file.write('    @expose("/<pk>", methods=["DELETE"])\n')
        api_file.write('    def delete(self, pk):\n')
        api_file.write('        """Delete record by primary key."""\n')
        api_file.write('        return self.delete(pk)\n\n')

        api_file.write(f'appbuilder.add_api({model_name}RestApi)\n\n')

    # Generate MultipleViews for tables with relationships
    for parent_table, related_tables in relationships.items():
        parent_model_name = parent_table.capitalize()
        views_file.write(f'class {parent_model_name}MultipleView(MultipleView):\n')
        views_file.write(f'    views = [')
        for model_name, _ in related_tables:
            views_file.write(f'{model_name}View, ')
        views_file.write(']\n\n')

        views_file.write(f'appbuilder.add_view({parent_model_name}MultipleView, "{parent_model_name} Details", category="Menu")\n\n')

    # Add ModelViews to the menu
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')
print(f'APIs written to {OUTPUT_API_FILE}')
# Now includes RESTAPI generation for each models



from sqlalchemy import create_engine, MetaData

# Configuration
DATABASE_URI = 'postgresql://username:password@localhost:5432/mydatabase'
OUTPUT_MODELS_FILE = 'models.py'
OUTPUT_VIEWS_FILE = 'views.py'
OUTPUT_API_FILE = 'api.py'

# Connect to the PostgreSQL database
engine = create_engine(DATABASE_URI)
metadata = MetaData()
metadata.reflect(bind=engine)

# Generate models.py
with open(OUTPUT_MODELS_FILE, 'w') as models_file:
    models_file.write('from flask_appbuilder import Model\n')
    models_file.write('from sqlalchemy import Column, Integer, String, ForeignKey\n')
    models_file.write('from sqlalchemy.orm import relationship\n\n')

    # Track relationships for MultipleView generation
    relationships = {}

    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        models_file.write(f'class {model_name}(Model):\n')
        models_file.write(f'    __tablename__ = "{table.name}"\n')

        # Write columns
        for column in table.columns:
            column_type = str(column.type)
            if column.foreign_keys:
                fk = next(iter(column.foreign_keys))
                models_file.write(f'    {column.name} = Column({column_type}, ForeignKey("{fk.target_fullname}"))\n')
                # Add to relationships for later MultipleView generation
                parent_table = fk.column.table.name
                if parent_table not in relationships:
                    relationships[parent_table] = []
                relationships[parent_table].append((model_name, table.name))
            else:
                models_file.write(f'    {column.name} = Column({column_type})\n')

        models_file.write('\n')

print(f'Models written to {OUTPUT_MODELS_FILE}')

# Generate views.py and api.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file, open(OUTPUT_API_FILE, 'w') as api_file:
    views_file.write('from flask_appbuilder import ModelView, MultipleView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    api_file.write('from flask_appbuilder.api import BaseApi, expose\n')
    api_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    api_file.write('from . import appbuilder, db\n')
    api_file.write('from .models import *\n\n')

    # Generate ModelViews and ModelRestApi for all tables
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')

        api_file.write(f'class {model_name}RestApi(BaseApi):\n')
        api_file.write(f'    resource_name = "{table.name}"\n')
        api_file.write(f'    datamodel = SQLAInterface({model_name})\n\n')
        api_file.write('    @expose("/", methods=["GET"])\n')
        api_file.write('    def get_list(self):\n')
        api_file.write('        """Get list of records."""\n')
        api_file.write('        return self.list()\n\n')
        api_file.write('    @expose("/<pk>", methods=["GET"])\n')
        api_file.write('    def get_item(self, pk):\n')
        api_file.write('        """Get record by primary key."""\n')
        api_file.write('        return self.show(pk)\n\n')
        api_file.write('    @expose("/", methods=["POST"])\n')
        api_file.write('    def post(self):\n')
        api_file.write('        """Create a new record."""\n')
        api_file.write('        return self.post()\n\n')
        api_file.write('    @expose("/<pk>", methods=["PUT"])\n')
        api_file.write('    def put(self, pk):\n')
        api_file.write('        """Update existing record."""\n')
        api_file.write('        return self.edit(pk)\n\n')
        api_file.write('    @expose("/<pk>", methods=["DELETE"])\n')
        api_file.write('    def delete(self, pk):\n')
        api_file.write('        """Delete record by primary key."""\n')
        api_file.write('        return self.delete(pk)\n\n')

        api_file.write(f'appbuilder.add_api({model_name}RestApi)\n\n')

    # Generate MultipleViews for tables with relationships
    for parent_table, related_tables in relationships.items():
        parent_model_name = parent_table.capitalize()
        views_file.write(f'class {parent_model_name}MultipleView(MultipleView):\n')
        views_file.write(f'    views = [')
        for model_name, _ in related_tables:
            views_file.write(f'{model_name}View, ')
        views_file.write(']\n\n')

        views_file.write(f'appbuilder.add_view({parent_model_name}MultipleView, "{parent_model_name} Details", category="Menu")\n\n')

    # Add ModelViews to the menu
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')
print(f'APIs written to {OUTPUT_API_FILE}')


#=================================================================
# Adding list_columns and show_fieldsets
#=================================================================
# ... (other parts of the script remain unchanged)

# Generate views.py
with open(OUTPUT_VIEWS_FILE, 'w') as views_file:
    views_file.write('from flask_appbuilder import ModelView\n')
    views_file.write('from flask_appbuilder.models.sqla.interface import SQLAInterface\n')
    views_file.write('from . import appbuilder, db\n')
    views_file.write('from .models import *\n\n')

    # Generate ModelViews for all tables
    for table in metadata.sorted_tables:
        model_name = table.name.capitalize()
        columns = table.columns
        list_columns = [column.name for column in columns]
        label_columns = {column.name: column.name.capitalize().replace('_', ' ') for column in columns}
        show_fieldsets = [
            (None, {'fields': list_columns})
        ]

        views_file.write(f'class {model_name}View(ModelView):\n')
        views_file.write(f'    datamodel = SQLAInterface({model_name})\n')
        views_file.write(f'    list_columns = {list_columns}\n')
        views_file.write(f'    label_columns = {label_columns}\n')
        views_file.write(f'    show_fieldsets = {show_fieldsets}\n\n')

        views_file.write(f'appbuilder.add_view({model_name}View, "{model_name}", category="Menu")\n\n')

print(f'Views written to {OUTPUT_VIEWS_FILE}')

